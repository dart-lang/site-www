import 'dart:io';
import 'dart:convert' show HtmlEscape, HtmlEscapeMode;
import 'package:html_unescape/html_unescape.dart';
import 'package:logging/logging.dart';

final Logger _log = new Logger('');

final warning = '''{%- comment %}
WARNING: Do NOT EDIT this file directly. It is autogenerated by
  ${Platform.script.path.replaceFirst(new RegExp(r'^.*site-www/'), '')}
from sources in the example folder.
{% endcomment -%}
''';

void main() {
  Logger.root.level = Level.OFF;
  Logger.root.onRecord.listen((LogRecord rec) => print('>> ${rec.message}'));

  final mainExampleSrcAsHtmlWithTips = new Main().getSrcHtmlWithTips();

  final html = [
    warning,
    '<pre class="prettyprint">\n',
    mainExampleSrcAsHtmlWithTips.join('\n'),
    '</pre>\n'
  ].join('');
  new File('../src/_main-example.html').writeAsStringSync(html);
}

class Main {
  final HtmlEscape _htmlEscape =
      new HtmlEscape(new HtmlEscapeMode(escapeLtGt: true));
  final HtmlUnescape _htmlUnescape = new HtmlUnescape();
  final tipRegExp = new RegExp(r'^(.*?) //!tip\("([^"]+)"\)$');
  final tooltips = _getTooltips().toList();

  int indexOfNextTooltip = 0;

  Iterable<String> getSrcHtmlWithTips() =>
      getMainExampleSrcLines().map(processTipInstruction);

  /// Side-effect: increments [indexOfNextTooltip] as it processes tips.
  String processTipInstruction(String line) {
    _log.fine(line);
    line = htmlEscape(line);

    while (line.contains('//!tip(')) {
      var match = tipRegExp.firstMatch(line);
      if (match == null) throw 'Tip instruction match failed for line: $line';
      final lineWithoutTipInstruction = match[1],
          anchor = _htmlUnescape.convert(match[2]),
          tooltip = tooltips[indexOfNextTooltip],
          tooltipAnchor = tooltip[0],
          tooltipText = tooltip[1];
      indexOfNextTooltip += 1;
      if (tooltipAnchor != anchor)
        throw 'Expected tip for $anchor, but instead found tip for ${tooltip[0]}. Aborting.';
      final escapedAnchor = htmlEscape(anchor);
      _log.fine('  ** Replacing "$escapedAnchor" with span');
      line = lineWithoutTipInstruction.replaceFirst(escapedAnchor,
          '<a tabindex="0" role="button" data-toggle="popover" data-content="$tooltipText">$escapedAnchor</a>');
    }
    return line;
  }

  String htmlEscape(String s) => _htmlEscape.convert(s);
}

Iterable<String> getMainExampleSrcLines() {
  final _mainExampleFile = '../examples/misc/lib/pi_monte_carlo.dart';
  return new File(_mainExampleFile)
      .readAsLinesSync()
      .skipWhile((line) => !line.startsWith('import')) // initial comment block
      .where((line) => !line.contains('web-only'))
      .map((line) => line.replaceFirst('numIterations', '500'));
}

Iterable<List<String>> _getTooltips() sync* {
  final _tooltipFile = '../examples/misc/lib/pi_monte_carlo_tooltips.html';
  final _tooltipLineRE = new RegExp(r'^\s*<li name="(.*?)">(.*?)(</li>)?$');
  final _tooltipLineEndRE = new RegExp(r'^\s*(.*?)(</li>)?$');
  final lines = new File(_tooltipFile).readAsLinesSync().iterator;
  _log.info('Processing $_tooltipFile:');

  while (lines.moveNext()) {
    final line = lines.current;
    final match = _tooltipLineRE.firstMatch(line);
    _log.info('  ${match == null ? "Skipping" : "Processing"}: $line.');
    if (match == null) continue;

    String name = match[1], tooltip = match[2], liClosingTag = match[3];
    _log.fine('  >> $name | $tooltip | $liClosingTag');

    while (liClosingTag == null && lines.moveNext()) {
      final line = lines.current;
      final match = _tooltipLineEndRE.firstMatch(line);
      _log.info('  ${match == null ? "Skipping" : "Processing"}: $line.');
      tooltip = _join(tooltip, match[1]);
      liClosingTag = match[2];
    }

    if (liClosingTag == null)
      throw 'Could not find closing <li> tag for line starting at "$tooltip"';

    yield [name, tooltip];
  }
}

/// Returns the concatentation of s1 and s2, separated by a space if both
/// are not empty.
String _join(String s1, String s2) =>
    [s1, s2].where((String s) => s.isNotEmpty).join(' ');
