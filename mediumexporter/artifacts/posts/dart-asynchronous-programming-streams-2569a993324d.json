{"success":true,"payload":{"value":{"id":"2569a993324d","versionId":"9763dce3e93c","creatorId":"fe67f3a27347","homeCollectionId":"23738d481ce8","title":"Dart asynchronous programming: Streams","detectedLanguage":"en","latestVersion":"9763dce3e93c","latestPublishedVersion":"9763dce3e93c","hasUnpublishedEdits":false,"latestRev":1376,"createdAt":1572392572302,"updatedAt":1649936332167,"acceptedAt":0,"firstPublishedAt":1581444062321,"latestPublishedAt":1649936328880,"vote":false,"experimentalCss":"","displayAuthor":"","content":{"subtitle":"This article covers one of the fundamentals of reactive programming: streams, which are objects of type Stream.","bodyModel":{"paragraphs":[{"name":"b94c","type":3,"text":"Dart asynchronous programming: Streams","markups":[]},{"name":"c4e0","type":1,"text":"Note: You might want to check out a version of this article where the code is updated to be null safe. (The video has not changed.)","markups":[{"type":3,"start":36,"end":101,"href":"https://medium.com/dartlang/dart-asynchronous-programming-streams-dab952023ed7","title":"","rel":"","anchorType":0},{"type":1,"start":0,"end":4},{"type":2,"start":0,"end":131}]},{"name":"375c","type":4,"text":"A simple Flutter app that displays data from a stream","markups":[],"layout":1,"metadata":{"id":"1*7v26fZu7zzY0QSBQAwj42Q.gif","originalWidth":272,"originalHeight":309}},{"name":"1369","type":1,"text":"This article covers one of the fundamentals of reactive programming: streams, which are objects of type Stream.","markups":[{"type":10,"start":104,"end":110},{"type":3,"start":104,"end":110,"href":"https://api.dart.dev/stable/dart-async/Stream-class.html","title":"","rel":"noopener","anchorType":0}]},{"name":"8159","type":1,"text":"If you’ve read the previous article on futures, you might remember that each future represents a single value (either an error or data) that it delivers asynchronously. Streams work similarly, but instead of a single thing, a stream can deliver zero or more values and errors over time.","markups":[{"type":3,"start":19,"end":46,"href":"https://medium.com/dartlang/dart-asynchronous-programming-futures-96937f831137","title":"","rel":"","anchorType":0},{"type":1,"start":72,"end":109},{"type":1,"start":153,"end":167},{"type":1,"start":224,"end":276},{"type":1,"start":281,"end":286}]},{"name":"bceb","type":6,"text":"This article is the third one based on the Flutter in Focus video series Asynchronous Programming in Dart. The first article, Isolates and event loops, covered the foundations of Dart’s support for background work. The second one, Futures, discussed the Future class.","markups":[{"type":10,"start":254,"end":260},{"type":3,"start":126,"end":150,"href":"https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a","title":"","rel":"noopener","anchorType":0},{"type":3,"start":231,"end":238,"href":"https://medium.com/dartlang/dart-asynchronous-programming-futures-96937f831137","title":"","rel":"","anchorType":0},{"type":2,"start":43,"end":59},{"type":2,"start":73,"end":105}]},{"name":"63c2","type":6,"text":"If you prefer to learn by watching or listening, everything in this article is covered in the following video.","markups":[]},{"name":"32f6","type":11,"text":"Andrew Brogdon’s video is the inspiration for this article.","markups":[],"layout":1,"iframe":{"mediaResourceId":"19f7572c0ed7e65b2b45fc00703972c6","iframeWidth":854,"iframeHeight":480,"thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fi.ytimg.com%2Fvi%2FnQBpOIHE4eE%2Fhqdefault.jpg&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"4b9d","type":1,"text":"If you think about the way a single value relates to an iterator of the same type, that’s how a future relates to a stream.","markups":[{"type":3,"start":56,"end":64,"href":"https://dart.dev/codelabs/iterables","title":"","rel":"","anchorType":0}]},{"name":"5708","type":4,"text":"","markups":[],"layout":1,"metadata":{"id":"1*q9cqGB5uXOX3tNw07SoJnQ.png","originalWidth":429,"originalHeight":113}},{"name":"f447","type":1,"text":"Just like with futures, the key is deciding in advance, “Here’s what to do when a piece of data is ready, and when there’s an error, and when the stream completes.”","markups":[]},{"name":"00f1","type":1,"text":"Also just like with futures, the Dart event loop is still running the show.","markups":[{"type":2,"start":0,"end":4}]},{"name":"66e9","type":4,"text":"Streams work with the Dart event loop.","markups":[],"layout":1,"metadata":{"id":"0*UVy8BLEUm4CifwDE.png","originalWidth":624,"originalHeight":332}},{"name":"6035","type":1,"text":"If you’re using the File class’s openRead() method to read data from a file, for example, that method returns a stream.","markups":[{"type":10,"start":20,"end":24},{"type":10,"start":33,"end":43},{"type":3,"start":33,"end":43,"href":"https://api.dart.dev/stable/dart-io/File/openRead.html","title":"","rel":"","anchorType":0}]},{"name":"40fe","type":1,"text":"Chunks of data are read from disk and arrive at the event loop. A Dart library looks at them and says, “Ah, I’ve got somebody waiting for this,” adds the data to the stream, and it pops out in your app’s code.","markups":[]},{"name":"17f1","type":1,"text":"When another piece of data arrives, in it goes, and out it comes. Timer-based streams, streaming data from a network socket — they work with the event loop, too, using clock and network events.","markups":[]},{"name":"0082","type":3,"text":"Listening to streams","markups":[]},{"name":"fbff","type":1,"text":"Let’s talk about how to work with data provided by a stream. Say you have a class that gives you a stream that kicks out a new integer once per second: 1, 2, 3, 4, 5…","markups":[]},{"name":"6db1","type":1,"text":"You can use the listen() method to subscribe to the stream. The only required parameter is a function.","markups":[{"type":10,"start":16,"end":24},{"type":3,"start":16,"end":24,"href":"https://api.dart.dev/stable/dart-async/Stream/listen.html","title":"","rel":"","anchorType":0}]},{"name":"817f","type":11,"text":"Simple code for creating and listening to a stream.","markups":[],"layout":1,"iframe":{"mediaResourceId":"c31dc00c60729231ff711a1f2c5a7c06","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"47c4","type":1,"text":"Every time a new value is emitted by the stream, the function gets called and prints the value:","markups":[]},{"name":"6778","type":8,"text":"Data: 1\nData: 2\nData: 3\nData: 4\n...","markups":[]},{"name":"4af9","type":1,"text":"That’s how listen() works.","markups":[{"type":10,"start":11,"end":19}]},{"name":"d37a","type":6,"text":"Important: By default, streams are set up for single subscription. They hold onto their values until someone subscribes, and they only allow a single listener for their entire lifespan. If you try to listen to a stream twice, you’ll get an exception.","markups":[{"type":1,"start":0,"end":10}]},{"name":"1eaf","type":6,"text":"Fortunately Dart also offers broadcast streams. You can use the asBroadcastStream() method to make a broadcast stream from a single subscription one. Broadcast streams work the same as single subscription streams, but they can have multiple listeners, and if nobody’s listening when a piece of data is ready, that data is tossed out.","markups":[{"type":10,"start":64,"end":83},{"type":3,"start":64,"end":83,"href":"https://api.dart.dev/stable/dart-async/Stream/asBroadcastStream.html","title":"","rel":"","anchorType":0}]},{"name":"4e56","type":11,"text":"To listen to a stream more than once, you need to convert it into a broadcast stream.","markups":[],"layout":1,"iframe":{"mediaResourceId":"be6e85178bdfcd755067c7a16de5b022","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"c47a","type":1,"text":"Let’s go back to that first listen() call, because there are a couple more things to talk about.","markups":[{"type":10,"start":28,"end":36}]},{"name":"cbc7","type":1,"text":"As we mentioned earlier, streams can produce errors just like futures can. By adding an onError function to the listen() call, you can catch and process any error.","markups":[{"type":10,"start":88,"end":95},{"type":10,"start":112,"end":120}]},{"name":"d2b1","type":1,"text":"There’s also a cancelOnError property that’s true by default, but can be set to false to keep the subscription going even after an error.","markups":[{"type":10,"start":15,"end":28}]},{"name":"5719","type":1,"text":"And you can add an onDone function to execute some code when the stream is finished sending data, such as when a file has been completely read.","markups":[{"type":10,"start":19,"end":25}]},{"name":"9035","type":1,"text":"With all four of those parameters combined — onError, onDone, cancelOnError, and the required parameter (onData) — you can be ready in advance for whatever happens.","markups":[{"type":10,"start":45,"end":52},{"type":10,"start":54,"end":60},{"type":10,"start":62,"end":75},{"type":10,"start":105,"end":111}]},{"name":"509e","type":11,"text":"This example uses all four parameters to listen().","markups":[],"layout":1,"iframe":{"mediaResourceId":"dea319494190bd75b912520147b65906","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"c27b","type":6,"text":"Tip: The little subscription object that listen() returns has some useful methods of its own. It’s a StreamSubscription, and you can use it to pause, resume, and even cancel the flow of data.","markups":[{"type":10,"start":41,"end":49},{"type":10,"start":101,"end":119},{"type":3,"start":101,"end":119,"href":"https://api.dart.dev/stable/dart-async/StreamSubscription-class.html","title":"","rel":"","anchorType":0},{"type":1,"start":0,"end":4},{"type":2,"start":101,"end":119}]},{"name":"c6f7","type":11,"text":"You might need the StreamSubscription object that listen() returns.","markups":[],"layout":1,"iframe":{"mediaResourceId":"520a9f66cf6b442e8cbcd16bc03dc7b1","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"57fa","type":3,"text":"Using and manipulating streams","markups":[]},{"name":"f1d1","type":1,"text":"Now that you know how to use listen() to subscribe to a stream and receive data events, we can talk about what makes streams really cool: manipulating them. Once you’ve got data in a stream, a lot of operations become fluent and elegant.","markups":[{"type":10,"start":29,"end":37}]},{"name":"08f0","type":1,"text":"Going back to that number stream from earlier, we can use a method called map() to take each value from the stream and convert it on the fly into something else. Give map() a function to do the conversion, and it returns a new stream, typed to match the return value of the function. Instead of a stream of ints, you now have a stream of strings. You can throw a listen() call on the end, give it the print() function, and now you’re printing strings directly off the stream, asynchronously, as they arrive.","markups":[{"type":10,"start":74,"end":79},{"type":10,"start":167,"end":172},{"type":10,"start":363,"end":371},{"type":10,"start":401,"end":408},{"type":3,"start":74,"end":79,"href":"https://api.dart.dev/stable/dart-async/Stream/map.html","title":"","rel":"","anchorType":0}]},{"name":"a15b","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"6ac03783e253fb674f00ca75a2cdf722","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"809f","type":1,"text":"There are a ton of methods that you can chain up like this. If you only want to print the even numbers, for example, you can use where() to filter the stream. Give it a test function that returns a boolean for each element, and it returns a new stream that only includes values that pass the test.","markups":[{"type":10,"start":129,"end":136},{"type":3,"start":129,"end":136,"href":"https://api.dart.dev/stable/dart-async/Stream/where.html","title":"","rel":"","anchorType":0}]},{"name":"cf44","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"8f291bde6b2e14f0acd17743cecf36b3","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"8970","type":1,"text":"The distinct() method is another good one. If you have an app that uses a Redux store, that store emits new app state objects in an onChange stream. You can use map() to convert that stream of state objects to a stream of view models for one part of the app. Then you can use the distinct() method to get a stream that filters out consecutive identical values (in case the store kicks out a change that doesn’t affect the subset of data in the view model). Then you can listen and update the UI whenever you get a new view model.","markups":[{"type":10,"start":4,"end":14},{"type":10,"start":132,"end":140},{"type":10,"start":161,"end":166},{"type":10,"start":280,"end":290},{"type":3,"start":4,"end":14,"href":"https://api.dart.dev/stable/dart-async/Stream/distinct.html","title":"","rel":"","anchorType":0}]},{"name":"dd9a","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"a41b8d1210d6b2168bbbb8d194aea8ba","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"a2e0","type":1,"text":"There are a bunch of additional methods built into Dart that you can use to shape and modify your streams. Plus, when you’re ready for even more advanced stuff, there’s the async package maintained by the Dart team and available on pub.dev. It has classes that can merge two streams together, cache results, and perform other types of stream-based wizardry.","markups":[{"type":3,"start":173,"end":186,"href":"https://pub.dev/packages/async","title":"","rel":"","anchorType":0},{"type":3,"start":232,"end":239,"href":"https://pub.dev","title":"","rel":"","anchorType":0}]},{"name":"f1ec","type":4,"text":"Try the async package for more stream-based wizardry.","markups":[],"layout":1,"metadata":{"id":"1*WTHZRJjgF4qQvSDvY0Z9ow.png","originalWidth":1171,"originalHeight":1070}},{"name":"3764","type":1,"text":"For even more stream magic, take a look at the stream_transform package.","markups":[{"type":3,"start":47,"end":71,"href":"https://pub.dev/packages/stream_transform","title":"","rel":"","anchorType":0}]},{"name":"89ba","type":3,"text":"Creating streams","markups":[]},{"name":"1fb3","type":1,"text":"One advanced topic deserves a mention here, and that’s how to create streams of your own. Just like with futures, most of the time you’re going to be working with streams created for you by network libraries, file libraries, state management, and so on. But you can make your own as well, using a StreamController.","markups":[{"type":10,"start":297,"end":313},{"type":3,"start":297,"end":313,"href":"https://api.dart.dev/stable/dart-async/StreamController-class.html","title":"","rel":"","anchorType":0}]},{"name":"2da8","type":1,"text":"Let’s go back to that NumberCreator we’ve been using so far. Here’s the actual code for it:","markups":[{"type":10,"start":22,"end":35}]},{"name":"1c43","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"7e4d50381bdf969e768232b9fa01a804","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"a0fe","type":1,"text":"As you can see, it keeps a running count, and it uses a timer to increment that count each second. The interesting bit, though, is the stream controller.","markups":[]},{"name":"e666","type":1,"text":"A StreamController creates a brand new stream from scratch, and gives you access to both ends of it. There’s the stream end itself, where data arrives. (We’ve been using that one throughout this article.)","markups":[{"type":10,"start":2,"end":18}]},{"name":"d621","type":8,"text":"Stream<int> get stream => _controller.stream;","markups":[]},{"name":"4ce8","type":1,"text":"Then there’s the sink end, which is where new data gets added to the stream:","markups":[]},{"name":"b180","type":8,"text":"_controller.sink.add(_count);","markups":[]},{"name":"23bc","type":1,"text":"NumberCreator here uses both of them. When the timer goes off, it adds the latest count to the controller’s sink, and then it exposes the controller’s stream with a public property so other objects can subscribe to it.","markups":[{"type":10,"start":0,"end":13}]},{"name":"6e88","type":3,"text":"Building Flutter widgets using streams","markups":[]},{"name":"7b8b","type":1,"text":"Now that we’ve covered creating, manipulating, and listening to streams, let’s talk about how to put them to work building widgets in Flutter.","markups":[]},{"name":"2d7d","type":1,"text":"If you saw the previous video on futures, you might remember FutureBuilder. You give it a future and a builder method, and it builds widgets based on the state of the future.","markups":[{"type":10,"start":61,"end":74},{"type":3,"start":61,"end":74,"href":"https://api.flutter.dev/flutter/widgets/FutureBuilder-class.html","title":"","rel":"","anchorType":0}]},{"name":"e7dd","type":1,"text":"For streams, there’s a similar widget called StreamBuilder. Give it a stream and a builder method, and it will rebuild its children whenever a new value is emitted by the stream.","markups":[{"type":10,"start":45,"end":58},{"type":3,"start":45,"end":58,"href":"https://api.flutter.dev/flutter/widgets/StreamBuilder-class.html","title":"","rel":"","anchorType":0}]},{"name":"b862","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"6a05ff211a85991d373ff0849f0de937","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"2937","type":1,"text":"The snapshot parameter is an AsyncSnapshot, just like with FutureBuilder. You can check its connectionState property to see if the stream hasn’t yet sent any data or if it’s completely finished. You can use the hasError property to see if the latest value is an error. And, of course, you can handle data values.","markups":[{"type":10,"start":29,"end":42},{"type":10,"start":59,"end":72},{"type":10,"start":92,"end":107},{"type":10,"start":211,"end":219},{"type":3,"start":29,"end":42,"href":"https://api.flutter.dev/flutter/widgets/AsyncSnapshot-class.html","title":"","rel":"","anchorType":0}]},{"name":"52f5","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"07b72fea9c66c729c75471dbbeeb3991","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"8b36","type":1,"text":"The main thing is just to make sure your builder knows how to handle all the possible states of the stream. Once you’ve got that, it can react to whatever the stream does.","markups":[]},{"name":"efd1","type":3,"text":"Summary","markups":[]},{"name":"5b21","type":1,"text":"This article talked about what streams represent, how you get values from a stream, ways to manipulate those values, and how StreamBuilder helps you use stream values in a Flutter app.","markups":[{"type":10,"start":125,"end":138}]},{"name":"d163","type":1,"text":"You can learn more about streams from the Dart and Flutter documentation:","markups":[]},{"name":"8be4","type":9,"text":"On dart.dev, see the streams tutorial, the command-line app tutorial, and the stream section of the library tour.","markups":[{"type":3,"start":3,"end":11,"href":"https://dart.dev","title":"","rel":"","anchorType":0},{"type":3,"start":21,"end":37,"href":"https://dart.dev/tutorials/language/streams","title":"","rel":"","anchorType":0},{"type":3,"start":43,"end":68,"href":"https://dart.dev/tutorials/server/cmdline","title":"","rel":"noopener","anchorType":0},{"type":3,"start":78,"end":92,"href":"https://dart.dev/guides/libraries/library-tour#stream","title":"","rel":"","anchorType":0}]},{"name":"a00b","type":9,"text":"On flutter.dev, see Work with WebSockets, which features an example that uses StreamBuilder.","markups":[{"type":10,"start":78,"end":91},{"type":3,"start":3,"end":14,"href":"https://flutter.dev","title":"","rel":"","anchorType":0},{"type":3,"start":20,"end":40,"href":"https://flutter.dev/docs/cookbook/networking/web-sockets","title":"","rel":"","anchorType":0}]},{"name":"7bde","type":1,"text":"Or go on to the next video in the Asynchronous Programming in Dart series. It talks about async and await, which are two keywords that Dart offers to help you keep your asynchronous code tight and easy to read.","markups":[{"type":10,"start":90,"end":95},{"type":10,"start":100,"end":105},{"type":2,"start":34,"end":67}]},{"name":"d504","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"924c442a7c91b7366476ddd092178bfe","iframeWidth":854,"iframeHeight":480,"thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fi.ytimg.com%2Fvi%2FSmTCmDMi4BY%2Fhqdefault.jpg&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"bb5c","type":1,"text":"Big thanks to Andrew Brogdon, who created the video that this article is based on.","markups":[{"type":2,"start":0,"end":82}]},{"name":"7f8f","type":4,"text":"","markups":[],"layout":1,"metadata":{"id":"1*Q2-Ac9rjIDSuXzbrQqGkVA.png","originalWidth":740,"originalHeight":334,"isFeatured":true}}],"sections":[{"name":"28b2","startIndex":0},{"name":"db4a","startIndex":8}]},"postDisplay":{"coverless":true}},"virtuals":{"statusForCollection":"APPROVED","allowNotes":true,"previewImage":{"imageId":"1*Q2-Ac9rjIDSuXzbrQqGkVA.png","filter":"","backgroundSize":"","originalWidth":740,"originalHeight":334,"strategy":"resample","height":0,"width":0},"wordCount":1540,"imageCount":5,"readingTime":6.644654088050314,"subtitle":"This article covers one of the fundamentals of reactive programming: streams, which are objects of type Stream.","userPostRelation":{"userId":"8b6a7f6f197d","postId":"2569a993324d","readAt":0,"readLaterAddedAt":0,"votedAt":0,"collaboratorAddedAt":0,"notesAddedAt":0,"subscribedAt":0,"lastReadSectionName":"","lastReadVersionId":"","lastReadAt":0,"lastReadParagraphName":"","lastReadPercentage":0,"viewedAt":0,"presentedCountInResponseManagement":0,"clapCount":0,"seriesUpdateNotifsOptedInAt":0,"queuedAt":0,"seriesFirstViewedAt":0,"presentedCountInStream":2,"seriesLastViewedAt":0,"audioProgressSec":0},"publishedInCount":1,"usersBySocialRecommends":[],"noIndex":false,"recommends":107,"isBookmarked":false,"tags":[{"slug":"programming","name":"Programming","postCount":400575,"metadata":{"postCount":400575,"coverImage":{"id":"0*7x-LQAg1xBmi-L1p","originalWidth":1800,"originalHeight":1169,"alt":"Screenshot of a desktop with the Cursor application open"}},"type":"Tag"},{"slug":"programming-languages","name":"Programming Languages","postCount":14860,"metadata":{"postCount":14860,"coverImage":{"id":"1*sD09-ccQCGBvaNKvzpbTbw.png","originalWidth":1690,"originalHeight":964,"isFeatured":true}},"type":"Tag"},{"slug":"dartlang","name":"Dartlang","postCount":921,"metadata":{"postCount":921,"coverImage":{"id":"1*HNqQFQ2hdhAgjew1pIMqXA.png","originalWidth":2752,"originalHeight":1536,"isFeatured":true}},"type":"Tag"},{"slug":"asynchronous-programming","name":"Asynchronous Programming","postCount":2129,"metadata":{"postCount":2129,"coverImage":{"id":"1*x4eT5WcXZINAKinGVXySuw.png","originalWidth":1280,"originalHeight":720,"isFeatured":true}},"type":"Tag"},{"slug":"flutter","name":"Flutter","postCount":43303,"metadata":{"postCount":43303,"coverImage":{"id":"1*8zlpgRA1agpvWp-OiFKlJw.png","originalWidth":1536,"originalHeight":1024,"isFeatured":true}},"type":"Tag"}],"socialRecommendsCount":0,"responsesCreatedCount":2,"links":{"entries":[{"url":"https://dart.dev/tutorials/language/streams","alts":[],"httpStatus":200},{"url":"https://medium.com/dartlang/dart-asynchronous-programming-streams-dab952023ed7","alts":[{"type":3,"url":"medium://p/dab952023ed7"},{"type":2,"url":"medium://p/dab952023ed7"}],"httpStatus":200},{"url":"https://dart.dev/codelabs/iterables","alts":[],"httpStatus":200},{"url":"https://dart.dev","alts":[],"httpStatus":200},{"url":"https://dart.dev/tutorials/server/cmdline","alts":[],"httpStatus":200},{"url":"https://dart.dev/guides/libraries/library-tour#stream","alts":[],"httpStatus":200},{"url":"https://flutter.dev","alts":[],"httpStatus":200},{"url":"https://pub.dev","alts":[],"httpStatus":200},{"url":"https://pub.dev/packages/stream_transform","alts":[],"httpStatus":200},{"url":"https://flutter.dev/docs/cookbook/networking/web-sockets","alts":[],"httpStatus":200},{"url":"https://api.flutter.dev/flutter/widgets/StreamBuilder-class.html","alts":[],"httpStatus":200},{"url":"https://api.flutter.dev/flutter/widgets/AsyncSnapshot-class.html","alts":[],"httpStatus":200},{"url":"https://api.flutter.dev/flutter/widgets/FutureBuilder-class.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/dart-async/Stream/listen.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/dart-async/StreamController-class.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/dart-io/File/openRead.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/dart-async/Stream/map.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/dart-async/Stream/where.html","alts":[],"httpStatus":200},{"url":"https://pub.dev/packages/async","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/dart-async/Stream/distinct.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/dart-async/Stream/asBroadcastStream.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/dart-async/StreamSubscription-class.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/dart-async/Stream-class.html","alts":[],"httpStatus":200},{"url":"https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a","alts":[{"type":3,"url":"medium://p/bffc3e296a6a"},{"type":2,"url":"medium://p/bffc3e296a6a"}],"httpStatus":200},{"url":"https://medium.com/dartlang/dart-asynchronous-programming-futures-96937f831137","alts":[{"type":3,"url":"medium://p/96937f831137"},{"type":2,"url":"medium://p/96937f831137"}],"httpStatus":200}],"version":"0.3","generatedAt":1649936330197},"isLockedPreviewOnly":false,"metaDescription":"","totalClapCount":682,"sectionCount":2,"readingList":0,"topics":[{"topicId":"decb52b64abf","slug":"programming","createdAt":1493934116328,"deletedAt":0,"image":{"id":"1*iPa136b1cGEO7lvoXg6uHQ@2x.jpeg","originalWidth":6016,"originalHeight":4016},"name":"Programming","description":"The good, the bad, the buggy.","relatedTopics":[],"visibility":1,"relatedTags":[],"relatedTopicIds":[],"seoTitle":"Programming News and Articles — Medium","type":"Topic"}]},"coverless":true,"slug":"dart-asynchronous-programming-streams","translationSourcePostId":"","translationSourceCreatorId":"","isApprovedTranslation":false,"inResponseToPostId":"","inResponseToRemovedAt":0,"isTitleSynthesized":false,"allowResponses":true,"importedUrl":"","importedPublishedAt":0,"visibility":0,"uniqueSlug":"dart-asynchronous-programming-streams-2569a993324d","previewContent":{"bodyModel":{"paragraphs":[{"name":"previewImage","type":4,"text":"","layout":10,"metadata":{"id":"1*Q2-Ac9rjIDSuXzbrQqGkVA.png","originalWidth":740,"originalHeight":334,"isFeatured":true}},{"name":"previewTitle","type":3,"text":"Dart asynchronous programming: Streams","alignment":1},{"name":"previewSubtitle","type":13,"text":"This article covers one of the fundamentals of reactive…","alignment":1}],"sections":[{"startIndex":0}]},"isFullContent":false,"subtitle":"This article covers one of the fundamentals of reactive programming: streams, which are objects of type Stream."},"license":0,"inResponseToMediaResourceId":"","canonicalUrl":"https://blog.dart.dev/dart-asynchronous-programming-streams-2569a993324d","approvedHomeCollectionId":"23738d481ce8","isNewsletter":false,"newsletterId":"","webCanonicalUrl":"https://blog.dart.dev/dart-asynchronous-programming-streams-2569a993324d","mediumUrl":"https://blog.dart.dev/dart-asynchronous-programming-streams-2569a993324d","migrationId":"","notifyFollowers":true,"notifyTwitter":false,"notifyFacebook":false,"responseHiddenOnParentPostAt":0,"isSeries":false,"isSubscriptionLocked":false,"seriesLastAppendedAt":0,"audioVersionDurationSec":0,"sequenceId":"","isEligibleForRevenue":false,"isBlockedFromHightower":false,"deletedAt":0,"lockedPostSource":0,"hightowerMinimumGuaranteeStartsAt":0,"hightowerMinimumGuaranteeEndsAt":0,"featureLockRequestAcceptedAt":0,"mongerRequestType":1,"layerCake":0,"socialTitle":"","socialDek":"","editorialPreviewTitle":"","editorialPreviewDek":"","curationEligibleAt":0,"isProxyPost":false,"proxyPostFaviconUrl":"","proxyPostProviderName":"","proxyPostType":0,"isSuspended":false,"isLimitedState":false,"seoTitle":"","previewContent2":{"bodyModel":{"paragraphs":[{"name":"b94c","type":3,"text":"Dart asynchronous programming: Streams","markups":[]},{"name":"c4e0","type":1,"text":"Note: You might want to check out a version of this article where the code is updated to be null safe. (The video has not changed.)","markups":[{"type":3,"start":36,"end":101,"href":"https://medium.com/dartlang/dart-asynchronous-programming-streams-dab952023ed7","title":"","rel":"","anchorType":0},{"type":1,"start":0,"end":4},{"type":2,"start":0,"end":131}]},{"name":"375c","type":4,"text":"A simple Flutter app that displays data from a stream","markups":[],"layout":1,"metadata":{"id":"1*7v26fZu7zzY0QSBQAwj42Q.gif","originalWidth":272,"originalHeight":309}},{"name":"1369","type":1,"text":"This article covers one of the fundamentals of reactive programming: streams, which are objects…","markups":[{"type":10,"start":104,"end":110},{"type":3,"start":104,"end":110,"href":"https://api.dart.dev/stable/dart-async/Stream-class.html","title":"","rel":"noopener","anchorType":0}]}],"sections":[{"name":"28b2","startIndex":0}]},"isFullContent":false,"subtitle":"This article covers one of the fundamentals of reactive programming: streams, which are objects of type Stream."},"cardType":0,"isDistributionAlertDismissed":false,"isShortform":false,"shortformType":0,"responsesLocked":false,"isLockedResponse":false,"isPublishToEmail":false,"responseDistribution":0,"isMarkedPaywallOnly":false,"type":"Post"},"mentionedUsers":[],"collaborators":[{"user":{"userId":"26a19a14addb","name":"Andrew Brogdon","username":"redbrogdon","createdAt":1515443572046,"imageId":"0*UfXdwppirgDYRNaj.","backgroundImageId":"","bio":"Engineer at Google, currently cranking out code for the Flutter developer relations team.","twitterScreenName":"","allowNotes":1,"mediumMemberAt":0,"isWriterProgramEnrolled":true,"isSuspended":false,"isMembershipTrialEligible":true,"facebookDisplayName":"","optInToIceland":true,"hasCompletedProfile":false,"userDismissableFlags":[2,8,10,12,46,53,58,59,61],"hasSeenIcelandOnboarding":false,"postSubscribeMembershipUpsellShownAt":0,"languageCode":"en-us","type":"User"},"state":"visible"}],"hideMeter":false,"shareKey":"21bd3c956a6a19251b90942c3d13ca28","collectionUserRelations":[{"collectionId":"23738d481ce8","userId":"8b6a7f6f197d","role":"ADMIN"},{"collectionId":"4da7dfd21a33","userId":"8b6a7f6f197d","role":"WRITER"},{"collectionId":"24d8f4fa8912","userId":"8b6a7f6f197d","role":"WRITER"}],"mode":"canEdit","references":{"User":{"fe67f3a27347":{"userId":"fe67f3a27347","name":"Kathy Walrath","username":"kathyw_39223","createdAt":1479149074481,"imageId":"0*OWxJ0V46ratF_z-r.","backgroundImageId":"","bio":"I write Dart docs! https://dart.dev","twitterScreenName":"","socialStats":{"userId":"fe67f3a27347","usersFollowedCount":19,"usersFollowedByCount":560,"type":"SocialStats"},"social":{"userId":"8b6a7f6f197d","targetUserId":"fe67f3a27347","type":"Social"},"allowNotes":1,"mediumMemberAt":0,"isWriterProgramEnrolled":true,"isSuspended":false,"isMembershipTrialEligible":true,"facebookDisplayName":"","optInToIceland":true,"userFlags":[2],"hasCompletedProfile":false,"userDismissableFlags":[1,2,5,8,12],"hasSeenIcelandOnboarding":false,"postSubscribeMembershipUpsellShownAt":0,"languageCode":"en-us","type":"User"}},"Collection":{"23738d481ce8":{"id":"23738d481ce8","name":"Dart","slug":"dartlang","tags":["MOBILE APP DEVELOPMENT","WEB DEVELOPMENT","DART","PROGRAMMING LANGUAGES","SOFTWARE DEVELOPMENT"],"creatorId":"a6d788faa5e5","description":"Dart is an approachable, portable, and productive language for high-quality apps on any platform. Learn more at https://dart.dev.","shortDescription":"Dart is an approachable, portable, and productive language…","image":{"imageId":"1*uWy1Ajpd0oTUQBO9WBHoQg@2x.png","filter":"","backgroundSize":"","originalWidth":1001,"originalHeight":1001,"strategy":"resample","height":0,"width":0},"metadata":{"followerCount":14031,"activeAt":1762974121956},"virtuals":{"permissions":{"canPublish":true,"canPublishAll":true,"canRepublish":true,"canRemove":true,"canManageAll":true,"canSubmit":true,"canEditPosts":true,"canAddWriters":true,"canViewStats":true,"canSendNewsletter":true,"canViewLockedPosts":true,"canViewCloaked":true,"canEditOwnPosts":true,"canBeAssignedAuthor":true,"canEnrollInHightower":false,"canLockPostsForMediumMembers":false,"canLockOwnPostsForMediumMembers":false,"canViewNewsletterV2Stats":true,"canCreateNewsletterV3":true},"isSubscribed":true,"isEnrolledInHightower":false,"isEligibleForHightower":false,"isSubscribedToCollectionEmails":false,"isMuted":false,"canToggleEmail":false,"isWriter":false},"logo":{"imageId":"1*NRb7RFVWJQFzY47j3v4U7Q.png","filter":"","backgroundSize":"","originalWidth":400,"originalHeight":154,"strategy":"resample","height":0,"width":0},"twitterUsername":"dart_lang","publicEmail":"medium@dartlang.org","domain":"blog.dart.dev","sections":[{"type":2,"collectionHeaderMetadata":{"title":"Dart","description":"An approachable, portable, and productive language for high-quality apps on any platform","backgroundImage":{},"logoImage":{"id":"1*knHF_qpxdtS8h0Z8EeqowA@2x.png","originalWidth":1080,"originalHeight":1080,"alt":"Dart"},"alignment":2,"layout":5}},{"type":1,"postListMetadata":{"source":1,"layout":4,"number":7,"postIds":[]}},{"type":1,"postListMetadata":{"source":1,"layout":5,"number":15,"postIds":[]}}],"tintColor":"#FF042B59","lightText":true,"favicon":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"colorPalette":{"defaultBackgroundSpectrum":{"colorPoints":[{"color":"#FF6588BA","point":0},{"color":"#FF607EAB","point":0.1},{"color":"#FF59759C","point":0.2},{"color":"#FF536B8E","point":0.3},{"color":"#FF4C617F","point":0.4},{"color":"#FF445670","point":0.5},{"color":"#FF3D4B61","point":0.6},{"color":"#FF344052","point":0.7},{"color":"#FF2B3442","point":0.8},{"color":"#FF212832","point":0.9},{"color":"#FF161A22","point":1}],"backgroundColor":"#FFFFFFFF"},"tintBackgroundSpectrum":{"colorPoints":[{"color":"#FF042B59","point":0},{"color":"#FF294871","point":0.1},{"color":"#FF456087","point":0.2},{"color":"#FF5F779B","point":0.3},{"color":"#FF788DAD","point":0.4},{"color":"#FF8FA2BF","point":0.5},{"color":"#FFA5B6CF","point":0.6},{"color":"#FFBBC9DF","point":0.7},{"color":"#FFD1DCEE","point":0.8},{"color":"#FFE6EEFC","point":0.9},{"color":"#FFFBFFFF","point":1}],"backgroundColor":"#FF042B59"},"highlightSpectrum":{"colorPoints":[{"color":"#FFECF3FF","point":0},{"color":"#FFE9F2FF","point":0.1},{"color":"#FFE5F0FF","point":0.2},{"color":"#FFE2EFFF","point":0.3},{"color":"#FFDEEDFF","point":0.4},{"color":"#FFDBEBFF","point":0.5},{"color":"#FFD7EAFF","point":0.6},{"color":"#FFD3E8FF","point":0.7},{"color":"#FFCFE6FF","point":0.8},{"color":"#FFCBE5FF","point":0.9},{"color":"#FFC8E3FF","point":1}],"backgroundColor":"#FFFFFFFF"},"darkBackgroundSpectrum":{"colorPoints":[{"color":"#FF7DA0D3","point":0},{"color":"#FF89A9D8","point":0.1},{"color":"#FF94B1DC","point":0.2},{"color":"#FFA0B9E0","point":0.3},{"color":"#FFABC1E3","point":0.4},{"color":"#FFB6C9E7","point":0.5},{"color":"#FFC0D1EB","point":0.6},{"color":"#FFCBD8EF","point":0.7},{"color":"#FFD5E0F2","point":0.8},{"color":"#FFE0E7F6","point":0.9},{"color":"#FFEAEFFA","point":1}],"backgroundColor":"#FF000000"}},"navItems":[{"type":1,"title":"Announcements","tagSlug":"announcements","url":"https://blog.dart.dev/tagged/announcements","source":"tagSlug"},{"type":5,"title":"Archive","url":"https://blog.dart.dev/archive"},{"type":3,"title":"dart.dev","url":"https://dart.dev"}],"colorBehavior":2,"collectionFeatures":[25],"ampLogo":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"header":{"title":"Dart","description":"An approachable, portable, and productive language for high-quality apps on any platform","backgroundImage":{},"logoImage":{"id":"1*knHF_qpxdtS8h0Z8EeqowA@2x.png","originalWidth":1080,"originalHeight":1080,"alt":"Dart"},"alignment":2,"layout":5},"subscriberCount":14031,"tagline":"Dart is a client-optimized language for fast apps on any platform.","isOptedIntoAurora":false,"isCurationAllowedByDefault":false,"polarisCoverImage":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"ptsQualifiedAt":1616092887098,"type":"Collection"}},"Social":{"fe67f3a27347":{"userId":"8b6a7f6f197d","targetUserId":"fe67f3a27347","type":"Social"}},"SocialStats":{"fe67f3a27347":{"userId":"fe67f3a27347","usersFollowedCount":19,"usersFollowedByCount":560,"type":"SocialStats"}}}},"v":3,"b":"20260130-1012-root"}