{"success":true,"payload":{"value":{"id":"dab952023ed7","versionId":"b55c5ca9a54d","creatorId":"1d07d30c7b26","homeCollectionId":"23738d481ce8","title":"Dart asynchronous programming: Streams","detectedLanguage":"en","latestVersion":"b55c5ca9a54d","latestPublishedVersion":"b55c5ca9a54d","hasUnpublishedEdits":false,"latestRev":1983,"createdAt":1643317278050,"updatedAt":1650075051197,"acceptedAt":0,"firstPublishedAt":1649935934397,"latestPublishedAt":1649935934397,"vote":false,"experimentalCss":"","displayAuthor":"","content":{"subtitle":"This article covers one of the fundamentals of reactive programming: streams, which are objects of type Stream.","bodyModel":{"paragraphs":[{"name":"80c5","type":3,"text":"Dart asynchronous programming: Streams","markups":[]},{"name":"4e3c","type":4,"text":"A simple Flutter app that displays data from a stream","markups":[],"layout":1,"metadata":{"id":"0*yUEX9fxMxoG63vi0.gif","originalWidth":272,"originalHeight":309}},{"name":"3775","type":1,"text":"This article covers one of the fundamentals of reactive programming: streams, which are objects of type Stream.","markups":[{"type":10,"start":104,"end":110},{"type":3,"start":104,"end":110,"href":"https://api.dart.dev/stable/dart-async/Stream-class.html","title":"","rel":"noopener ugc nofollow","anchorType":0}]},{"name":"75b6","type":1,"text":"If you’ve read our previous articles on futures, you might remember that each future represents a single value (either an error or data) delivered asynchronously. Streams work similarly, only instead of a single thing, a stream can deliver zero or more values and errors over time.","markups":[{"type":3,"start":19,"end":47,"href":"https://medium.com/dartlang/dart-asynchronous-programming-futures-96937f831137","title":"","rel":"","anchorType":0},{"type":1,"start":73,"end":111},{"type":1,"start":147,"end":161},{"type":1,"start":219,"end":220},{"type":1,"start":221,"end":227},{"type":1,"start":228,"end":271},{"type":1,"start":276,"end":280}]},{"name":"27dc","type":6,"text":"This article was first published in February 2020. This version updates the included code to null safety.","markups":[{"type":3,"start":36,"end":49,"href":"https://medium.com/dartlang/dart-asynchronous-programming-streams-2569a993324d","title":"","rel":"","anchorType":0}]},{"name":"2f2b","type":6,"text":"This article is the third one based on the Flutter in Focus video series Asynchronous Programming in Dart. The first article, Isolates and event loops, covers the foundations of Dart’s support for background work. The second one, Futures, discusses the Future class.","markups":[{"type":10,"start":253,"end":259},{"type":3,"start":126,"end":150,"href":"https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a","title":"","rel":"","anchorType":0},{"type":2,"start":43,"end":59},{"type":2,"start":73,"end":105}]},{"name":"cc64","type":6,"text":"If you prefer to learn by watching or listening, everything in this article is covered in the following video.","markups":[]},{"name":"1d74","type":11,"text":"Andrew Brogdon’s video is the inspiration for this article.","markups":[],"layout":1,"iframe":{"mediaResourceId":"19f7572c0ed7e65b2b45fc00703972c6","iframeWidth":854,"iframeHeight":480,"thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fi.ytimg.com%2Fvi%2FnQBpOIHE4eE%2Fhqdefault.jpg&key=4fce0568f2ce49e8b54624ef71a8a5bd"}},{"name":"807c","type":6,"text":"Note: The code in this article has been updated to reflect best practices and changes to the Dart language (including null safety), which occurred after the video was released on June 28, 2019.","markups":[{"type":1,"start":0,"end":4}]},{"name":"9850","type":1,"text":"If you think about the way a single value relates to an iterator of the same type, that’s how a future relates to a stream: a future represents a single request with a single response, where a stream represents a single request with multiple responses.","markups":[{"type":3,"start":56,"end":64,"href":"https://dart.dev/codelabs/iterables","title":"","rel":"","anchorType":0}]},{"name":"3c81","type":4,"text":"","markups":[],"layout":1,"metadata":{"id":"0*e0Lz6RaBIx2uK5R4.png","originalWidth":429,"originalHeight":113}},{"name":"5af5","type":1,"text":"Just like with futures, the key is deciding in advance what to do 1) when a piece of data is ready, 2) when there’s an error, and 3) when the stream completes. As with futures, in this process the Dart event loop is still running the show.","markups":[]},{"name":"1fec","type":4,"text":"Streams work with the Dart event loop.","markups":[],"layout":1,"metadata":{"id":"0*tYShCv7ndeKeJFsv"}},{"name":"b053","type":13,"text":"Event loop pinch","markups":[{"type":1,"start":0,"end":16}]},{"name":"60c3","type":1,"text":"If you’re using the File class’sopenRead() method to read data from a file, for example, this method returns a stream.","markups":[{"type":10,"start":20,"end":24},{"type":10,"start":32,"end":42},{"type":3,"start":32,"end":40,"href":"https://api.dart.dev/stable/dart-io/File/openRead.html","title":"","rel":"","anchorType":0}]},{"name":"31c0","type":1,"text":"Chunks of data are read from disk and arrive at the event loop. The Dart library looks at them and says, “Ah, someone is waiting for this,” adds the data to the stream, and sends it to your app.","markups":[]},{"name":"be93","type":1,"text":"When another piece of data arrives — in it goes, and out it comes. Timer-based streams and streaming data from a network socket work with the event loop too, using clock and network events.","markups":[]},{"name":"cd3d","type":4,"text":"The event loop sorts the data.","markups":[],"layout":1,"metadata":{"id":"0*4NRFcYLryiLlUIrT","originalWidth":429,"originalHeight":232,"isFeatured":true}},{"name":"ee91","type":13,"text":"Listening to streams","markups":[{"type":1,"start":0,"end":20}]},{"name":"708b","type":1,"text":"The next thing to understand is how to work with data provided by a stream.","markups":[]},{"name":"9662","type":1,"text":"Say you have a class that gives you a stream that emits a new integer once every second (1, 2, 3, 4, 5…). You can use the listen()method to subscribe to the stream. The only required parameter is a function.","markups":[{"type":10,"start":122,"end":130},{"type":3,"start":122,"end":128,"href":"https://api.dart.dev/stable/dart-async/Stream/listen.html","title":"","rel":"","anchorType":0}]},{"name":"3cc3","type":8,"text":"final myStream = NumberCreator().stream;","markups":[]},{"name":"de6a","type":8,"text":"final subscription = myStream.listen(\n    (data) => print(‘Data: $data’),\n);","markups":[]},{"name":"7392","type":1,"text":"Every time a new value is emitted by the stream, the function gets called and prints the value:","markups":[]},{"name":"5e11","type":8,"text":"Data: 1\nData: 2\nData: 3\nData: 4\n...","markups":[]},{"name":"6982","type":1,"text":"That’s how listen()works.","markups":[{"type":10,"start":11,"end":19}]},{"name":"c5d3","type":6,"text":"Important: By default, streams are set up for single subscription. They hold onto their values until someone subscribes, and they only allow a single listener for their entire lifespan. If you try to listen to a stream twice, you’ll get an exception.","markups":[{"type":1,"start":0,"end":10}]},{"name":"6a0c","type":6,"text":"Fortunately Dart also offers broadcast streams. You can use the asBroadcastStream() method to make a broadcast stream from a single subscription one. Broadcast streams work the same as single subscription streams, but they can have multiple listeners.","markups":[{"type":10,"start":64,"end":83},{"type":3,"start":64,"end":83,"href":"https://api.dart.dev/stable/dart-async/Stream/asBroadcastStream.html","title":"","rel":"noopener ugc nofollow","anchorType":0}]},{"name":"c214","type":6,"text":"Another difference of broadcast streams: if nobody’s listening when a piece of data is ready, that data is tossed out.","markups":[{"type":1,"start":0,"end":41}]},{"name":"603b","type":8,"text":"final myStream = NumberCreator().stream;","markups":[{"type":10,"start":0,"end":40}]},{"name":"83df","type":8,"text":"final subscription = myStream.listen(\n  (data) => print(‘Data: $data’),\n);","markups":[{"type":10,"start":0,"end":74}]},{"name":"abfd","type":8,"text":"final subscription2 = myStream.listen(\n  (data) => print(‘Data again: $data’),\n);","markups":[{"type":10,"start":0,"end":81}]},{"name":"87d2","type":1,"text":"Let’s go back to that first listen()call, because there are a couple more things to talk about.","markups":[{"type":10,"start":28,"end":36}]},{"name":"caed","type":1,"text":"As mentioned earlier, streams can produce errors just like futures can. By adding an onError function to the listen() call, you can catch and process any errors.","markups":[{"type":10,"start":85,"end":92},{"type":10,"start":109,"end":117},{"type":3,"start":85,"end":92,"href":"https://api.dart.dev/stable/2.16.2/dart-async/StreamSubscription/onError.html","title":"","rel":"","anchorType":0}]},{"name":"dbc0","type":1,"text":"There’s also a cancelOnError property that’s true by default, but can be set to false to keep the subscription going even after an error.","markups":[{"type":10,"start":15,"end":28},{"type":2,"start":28,"end":29}]},{"name":"4b6a","type":1,"text":"You can add the onDone function to execute some code when the stream is finished sending data, such as when a file has been completely read.","markups":[{"type":10,"start":16,"end":23},{"type":3,"start":16,"end":22,"href":"https://api.dart.dev/stable/2.16.2/dart-async/StreamSubscription/onDone.html","title":"","rel":"","anchorType":0}]},{"name":"6461","type":1,"text":"With all four of those parameters combined — onError, onDone, cancelOnError, and the required parameter (onData) — you can be ready in advance for whatever happens.","markups":[{"type":10,"start":45,"end":52},{"type":10,"start":54,"end":60},{"type":10,"start":62,"end":75},{"type":10,"start":105,"end":111},{"type":3,"start":105,"end":111,"href":"https://api.dart.dev/stable/2.16.2/dart-async/StreamSubscription/onData.html","title":"","rel":"","anchorType":0}]},{"name":"b00b","type":8,"text":"final myStream = NumberCreator().stream;","markups":[{"type":10,"start":0,"end":40}]},{"name":"991d","type":8,"text":"final subscription = myStream.listen(\n  (data){\n    print(‘Data: $data’);\n},\nonError: (err) {\n  print(‘Error!’);\n},\ncancelOnError: false,\nonDone: () {\n  print(‘Done!’):\n },\n);","markups":[{"type":10,"start":0,"end":175}]},{"name":"7d44","type":6,"text":"Tip: The object that listen() returns has some useful methods of its own. It’s called a StreamSubscription, and you can use it to pause, resume, and even cancel the flow of data.","markups":[{"type":10,"start":21,"end":29},{"type":10,"start":88,"end":106},{"type":1,"start":0,"end":4}]},{"name":"228b","type":8,"text":"final subscription = myStream.listen(…);","markups":[{"type":10,"start":0,"end":40}]},{"name":"f01b","type":8,"text":"subscription.pause();\nsubscription.resume();\nsubscription.cancel();","markups":[{"type":10,"start":0,"end":67}]},{"name":"7b40","type":13,"text":"Using and manipulating streams","markups":[{"type":1,"start":0,"end":30}]},{"name":"ee33","type":1,"text":"Now that you know how to use listen() to subscribe to a stream and receive data events, let’s talk about what makes streams really cool: manipulating them.","markups":[{"type":10,"start":29,"end":37}]},{"name":"e93f","type":1,"text":"Once you’ve got data in a stream, there are a lot of operations that suddenly become fluent and elegant.","markups":[]},{"name":"5601","type":1,"text":"Let’s go back to that number stream from earlier.","markups":[]},{"name":"e76a","type":1,"text":"Using a method called map(), you can take each value from the stream and convert it on the fly into something else. Give map() a function to do the conversion, and it returns a new stream, typed to match the return value of the function.","markups":[{"type":10,"start":22,"end":27},{"type":10,"start":121,"end":126},{"type":3,"start":22,"end":25,"href":"https://api.dart.dev/stable/dart-async/Stream/map.html","title":"","rel":"","anchorType":0},{"type":2,"start":27,"end":28}]},{"name":"da6b","type":1,"text":"Instead of a stream of integers, now there is a stream of strings. Throw a listen()call on the end, pass it the print()function, and now it prints strings directly off the stream — asynchronously, as they arrive.","markups":[{"type":10,"start":75,"end":83},{"type":10,"start":112,"end":119},{"type":3,"start":112,"end":117,"href":"https://api.dart.dev/stable/2.16.2/dart-async/Zone/print.html","title":"","rel":"","anchorType":0}]},{"name":"5ffa","type":8,"text":"NumberCreator().stream\n    .map((i) => ‘String $i’)\n    .listen(print) ;","markups":[{"type":10,"start":0,"end":72}]},{"name":"78d9","type":8,"text":"String 1\nString 2\nString 3\nString 4\n*/","markups":[{"type":10,"start":0,"end":38}]},{"name":"5566","type":1,"text":"There are many methods you can chain up like this. If you only want to print the even numbers, for example, you can use where() to filter the stream. Give it a test function that returns a boolean for each element, and it returns a new stream that only includes values that pass the test.","markups":[{"type":10,"start":120,"end":127}]},{"name":"a4fb","type":8,"text":"NumberCreator().stream\n    .where((i) => i % 2 == 0)\n    .map((i) => ‘String $i’)\n    .listen(print) ;","markups":[{"type":10,"start":0,"end":102}]},{"name":"c903","type":8,"text":"String 2\nString 4\nString 6\nString 8","markups":[{"type":10,"start":0,"end":35}]},{"name":"5c92","type":1,"text":"The distinct() method is another good one. With an app that uses a Redux store, that store emits new app state objects in an onChange stream.","markups":[{"type":10,"start":4,"end":14},{"type":10,"start":125,"end":133},{"type":3,"start":4,"end":12,"href":"https://api.dart.dev/stable/dart-async/Stream/distinct.html","title":"","rel":"","anchorType":0},{"type":3,"start":125,"end":133,"href":"https://api.dart.dev/stable/2.16.2/dart-html/Document/onChange.html","title":"","rel":"","anchorType":0}]},{"name":"3c63","type":1,"text":"You can use map() to convert the stream of state objects to a stream of view models for one part of the app. Then you can use the distinct() method to get a stream that filters out consecutive identical values (in case the store kicks out a change that doesn’t affect the subset of data in the view model).","markups":[{"type":10,"start":12,"end":17},{"type":10,"start":130,"end":140}]},{"name":"9af9","type":1,"text":"You can then listen and update the UI whenever you get a new view model.","markups":[]},{"name":"fb51","type":8,"text":"myReduxStore.onChange\n    .map((s) => MyViewModel(s))\n    .distinct()\n    .listen( /* update UI */ )","markups":[{"type":10,"start":0,"end":100}]},{"name":"cc9b","type":1,"text":"There are additional methods built into Dart that you can use to shape and modify your streams. Plus, when you’re ready for more advanced features, there’s the async package maintained by the Dart team and available on pub.dev. It has classes that can merge two streams together, cache results, and perform other types of stream-based wizardry.","markups":[{"type":3,"start":160,"end":173,"href":"https://pub.dev/packages/async","title":"","rel":"","anchorType":0},{"type":3,"start":219,"end":226,"href":"https://pub.dev/","title":"","rel":"","anchorType":0}]},{"name":"0acc","type":4,"text":"Try the async package for more stream-based wizardry.","markups":[],"layout":1,"metadata":{"id":"1*x-uuwOB-kV_dlw80Gx5kkA.png","originalWidth":1205,"originalHeight":880}},{"name":"cf01","type":1,"text":"For even more stream magic, take a look at the stream_transform package.","markups":[{"type":3,"start":47,"end":71,"href":"https://pub.dev/packages/stream_transform","title":"","rel":"noopener ugc nofollow","anchorType":0}]},{"name":"3e0d","type":13,"text":"Creating streams","markups":[{"type":1,"start":0,"end":16}]},{"name":"ac88","type":1,"text":"Finally, one more advanced topic that deserves a mention here is how to create streams of your own.","markups":[]},{"name":"1175","type":1,"text":"Just like with futures, most of the time you’re going to be working with streams created for you by network libraries, file libraries, state management, and so on, but you can make your own using a StreamController.","markups":[{"type":10,"start":198,"end":214},{"type":3,"start":198,"end":214,"href":"https://api.dart.dev/stable/dart-async/StreamController-class.html","title":"","rel":"","anchorType":0}]},{"name":"941b","type":1,"text":"Let’s go back to that NumberCreator example we’ve been using so far. Here’s the actual code for it:","markups":[{"type":10,"start":22,"end":35}]},{"name":"d449","type":8,"text":"class NumberCreator {\n  NumberCreator() {\n    Timer.periodic(const Duration(seconds: 1), (timer) {\n      _controller.sink.add(_count);\n     _count += 1;\n   });\n }","markups":[{"type":10,"start":0,"end":162}]},{"name":"4644","type":8,"text":" final _controller = StreamController<int>();\n var _count = 0;\n Stream<int> get stream => _controller.stream;\n}","markups":[{"type":10,"start":0,"end":111}]},{"name":"46cf","type":1,"text":"As you can see, it keeps a running count and uses a timer to increment that count each second. The interesting bit, though, is the stream controller.","markups":[]},{"name":"7fd3","type":1,"text":"A StreamController creates a brand new stream from scratch and gives you access to both ends of it. There’s the stream end itself, where data arrives. (We’ve been using that one throughout this article.)","markups":[{"type":10,"start":2,"end":18},{"type":3,"start":2,"end":18,"href":"https://api.dart.dev/stable/2.16.2/dart-async/StreamController-class.html","title":"","rel":"","anchorType":0}]},{"name":"e277","type":1,"text":"Stream<int> get stream => _controller.stream;","markups":[{"type":10,"start":0,"end":45}]},{"name":"4de6","type":1,"text":"And there’s the sink end, which is where new data gets added to the stream:","markups":[]},{"name":"313b","type":1,"text":"_controller.sink.add(_count);","markups":[{"type":10,"start":0,"end":29}]},{"name":"2e6c","type":1,"text":"NumberCreator uses both of them. When the timer goes off, it adds the latest count to the controller’s sink, and then it exposes the controller’s stream with a public property so other objects can subscribe to it.","markups":[{"type":10,"start":0,"end":13}]},{"name":"e9d2","type":13,"text":"Building Flutter widgets using streams","markups":[{"type":1,"start":0,"end":38}]},{"name":"af58","type":1,"text":"Now that we’ve covered creating, manipulating, and listening to streams, let’s talk about how to put them to work building widgets in Flutter.","markups":[]},{"name":"cac5","type":1,"text":"If you read the previous article on Futures, you may remember FutureBuilder. You give it a future and a builder method, and it builds widgets based on the state of the future.","markups":[{"type":10,"start":62,"end":75},{"type":3,"start":36,"end":43,"href":"https://medium.com/dartlang/dart-asynchronous-programming-futures-96937f831137","title":"","rel":"","anchorType":0},{"type":3,"start":62,"end":75,"href":"https://api.flutter.dev/flutter/widgets/FutureBuilder-class.html","title":"","rel":"","anchorType":0}]},{"name":"8da0","type":1,"text":"For streams, there’s a similar widget called StreamBuilder. Give it a stream like the one from number creator and a builder method, and it rebuilds its children whenever a new value is emitted by the stream.","markups":[{"type":10,"start":45,"end":58},{"type":3,"start":45,"end":58,"href":"https://api.flutter.dev/flutter/widgets/StreamBuilder-class.html","title":"","rel":"","anchorType":0}]},{"name":"409a","type":8,"text":"StreamBuilder<String>(\n  stream: NumberCreator().stream.map((i) => ‘String $i’),\n  builder: (context, snapshot) {\n    // Build some widgets\n    throw UnimplementedError(“Case not handled yet”);\n  },\n);","markups":[{"type":10,"start":0,"end":201}]},{"name":"b1ff","type":1,"text":"The snapshot parameter is an AsyncSnapshot, just like with FutureBuilder.","markups":[{"type":10,"start":29,"end":42},{"type":10,"start":59,"end":72},{"type":3,"start":29,"end":42,"href":"https://api.flutter.dev/flutter/widgets/AsyncSnapshot-class.html","title":"","rel":"","anchorType":0}]},{"name":"68a6","type":8,"text":"StreamBuilder<String>(\n  stream: NumberCreator().stream.map((i) => ‘String $i’),\n  builder: (context, snapshot) {\n    if (snapshot.connectionState == ConnectionState.waiting) {\n      return const Text(‘No data yet.’);\n  }\n  throw UnimplementedError(“Case not handled yet”);\n},","markups":[{"type":10,"start":0,"end":276}]},{"name":"4dac","type":8,"text":");","markups":[{"type":10,"start":0,"end":2}]},{"name":"5481","type":1,"text":"You can check its connectionState property to see if the stream hasn’t yet sent any data, or if it’s completely finished.","markups":[{"type":10,"start":18,"end":34}]},{"name":"885b","type":8,"text":"StreamBuilder<String>(\n   stream: NumberCreator().stream.map((i) => 'String $i'),\n   builder: (context, snapshot) {\n      if (snapshot.connectionState == ConnectionState.waiting) {      \n        return const Text('No data yet.');\n      } else if (snapshot.connectionState == ConnectionState.done){\n        return const Text('Done!');\n      }\n      throw UnimplementedError(\"Case not handled yet\");\n    },\n );","markups":[]},{"name":"23a4","type":1,"text":"You can use the hasError property to handle data values and see if the latest value is an error.","markups":[{"type":10,"start":16,"end":24}]},{"name":"58a2","type":8,"text":"StreamBuilder<String>(\n  stream: NumberCreator().stream.map((i) => ‘String $i’),\n  builder: (context, snapshot) {\n    if (snapshot.connectionState == ConnectionState.waiting) {\n      return const Text(‘No data yet.’);\n    } else if (snapshot.connectionState == ConnectionState.done) {\n      return const Text(‘Done!’);\n    } else if (snapshot.hasError) {\n      return const Text(‘Error!’);\n    } else {\n      return Text(snapshot.data ?? ‘’);\n    } \n  },\n);","markups":[{"type":10,"start":0,"end":457}]},{"name":"3124","type":1,"text":"The main thing is to make sure your builder knows how to handle all possible states of the stream. Once you’ve got that, it can react to whatever the stream does. (For more information, including a DartPad instance that you can play with, see the StreamBuilder API page.)","markups":[{"type":10,"start":247,"end":260},{"type":3,"start":247,"end":260,"href":"https://api.flutter.dev/flutter/widgets/StreamBuilder-class.html","title":"","rel":"","anchorType":0}]},{"name":"9e29","type":3,"text":"Summary","markups":[]},{"name":"de65","type":1,"text":"This article has covered what streams represent, how to get values from a stream, ways to manipulate those values, and how StreamBuilder helps you use stream values in a Flutter app.","markups":[{"type":10,"start":123,"end":136}]},{"name":"7b02","type":1,"text":"You can learn more about streams from the Dart and Flutter documentation:","markups":[]},{"name":"7b75","type":9,"text":"On dart.dev, see the streams tutorial, the command-line app tutorial, and the stream section of the library tour.","markups":[{"type":3,"start":3,"end":11,"href":"https://dart.dev/","title":"","rel":"noopener ugc nofollow","anchorType":0},{"type":3,"start":21,"end":37,"href":"https://dart.dev/tutorials/language/streams","title":"","rel":"noopener ugc nofollow","anchorType":0},{"type":3,"start":43,"end":68,"href":"https://dart.dev/tutorials/server/cmdline","title":"","rel":"noopener ugc nofollow","anchorType":0},{"type":3,"start":78,"end":92,"href":"https://dart.dev/guides/libraries/library-tour#stream","title":"","rel":"noopener ugc nofollow","anchorType":0}]},{"name":"9592","type":9,"text":"On flutter.dev, see Work with WebSockets, which features an example that uses StreamBuilder.","markups":[{"type":10,"start":78,"end":91},{"type":3,"start":3,"end":14,"href":"https://flutter.dev/","title":"","rel":"noopener ugc nofollow","anchorType":0},{"type":3,"start":20,"end":40,"href":"https://flutter.dev/docs/cookbook/networking/web-sockets","title":"","rel":"noopener ugc nofollow","anchorType":0}]},{"name":"f814","type":1,"text":"Stay tuned for more articles coming in this series. Next up we’ll be talking about async and await. These are two keywords Dart offers to help you keep your asynchronous code concise and easy to read.","markups":[{"type":10,"start":83,"end":88},{"type":10,"start":93,"end":98},{"type":1,"start":0,"end":10}]},{"name":"afab","type":1,"text":"In the meantime you can watch the next video series on Asynchronous Programming in Dart our YouTube channel, or head over to our websites for more info on Dart and Flutter.","markups":[{"type":3,"start":155,"end":159,"href":"https://dart.dev/","title":"","rel":"","anchorType":0},{"type":3,"start":164,"end":171,"href":"https://flutter.dev/","title":"","rel":"","anchorType":0},{"type":1,"start":24,"end":51},{"type":1,"start":112,"end":137},{"type":2,"start":55,"end":88}]},{"name":"a443","type":11,"text":"Big thanks to Andrew Brogdon, who created the video that this article is based on.","markups":[{"type":2,"start":0,"end":82}],"layout":1,"iframe":{"mediaResourceId":"924c442a7c91b7366476ddd092178bfe","iframeWidth":854,"iframeHeight":480,"thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fi.ytimg.com%2Fvi%2FSmTCmDMi4BY%2Fhqdefault.jpg&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"a358","type":4,"text":"","markups":[],"layout":1,"metadata":{"id":"0*IGPMOenc2CSAeOFH.png","originalWidth":740,"originalHeight":334}}],"sections":[{"name":"e2b0","startIndex":0}]},"postDisplay":{"coverless":true}},"virtuals":{"statusForCollection":"APPROVED","allowNotes":true,"previewImage":{"imageId":"0*4NRFcYLryiLlUIrT","filter":"","backgroundSize":"","originalWidth":429,"originalHeight":232,"strategy":"resample","height":0,"width":0},"wordCount":1883,"imageCount":6,"readingTime":8.05566037735849,"subtitle":"This article covers one of the fundamentals of reactive programming: streams, which are objects of type Stream.","userPostRelation":{"userId":"8b6a7f6f197d","postId":"dab952023ed7","readAt":0,"readLaterAddedAt":0,"votedAt":0,"collaboratorAddedAt":0,"notesAddedAt":0,"subscribedAt":0,"lastReadSectionName":"","lastReadVersionId":"","lastReadAt":0,"lastReadParagraphName":"","lastReadPercentage":0,"viewedAt":0,"presentedCountInResponseManagement":0,"clapCount":0,"seriesUpdateNotifsOptedInAt":0,"queuedAt":0,"seriesFirstViewedAt":0,"presentedCountInStream":3,"seriesLastViewedAt":0,"audioProgressSec":0},"publishedInCount":1,"usersBySocialRecommends":[],"noIndex":false,"recommends":20,"isBookmarked":false,"tags":[{"slug":"programming","name":"Programming","postCount":400575,"metadata":{"postCount":400575,"coverImage":{"id":"0*7x-LQAg1xBmi-L1p","originalWidth":1800,"originalHeight":1169,"alt":"Screenshot of a desktop with the Cursor application open"}},"type":"Tag"},{"slug":"programming-languages","name":"Programming Languages","postCount":14860,"metadata":{"postCount":14860,"coverImage":{"id":"1*sD09-ccQCGBvaNKvzpbTbw.png","originalWidth":1690,"originalHeight":964,"isFeatured":true}},"type":"Tag"},{"slug":"dartlang","name":"Dartlang","postCount":921,"metadata":{"postCount":921,"coverImage":{"id":"1*HNqQFQ2hdhAgjew1pIMqXA.png","originalWidth":2752,"originalHeight":1536,"isFeatured":true}},"type":"Tag"},{"slug":"asynchronous-programming","name":"Asynchronous Programming","postCount":2129,"metadata":{"postCount":2129,"coverImage":{"id":"1*x4eT5WcXZINAKinGVXySuw.png","originalWidth":1280,"originalHeight":720,"isFeatured":true}},"type":"Tag"},{"slug":"flutter","name":"Flutter","postCount":43303,"metadata":{"postCount":43303,"coverImage":{"id":"1*8zlpgRA1agpvWp-OiFKlJw.png","originalWidth":1536,"originalHeight":1024,"isFeatured":true}},"type":"Tag"}],"socialRecommendsCount":0,"responsesCreatedCount":2,"links":{"entries":[{"url":"https://dart.dev/","alts":[],"httpStatus":200},{"url":"https://dart.dev/tutorials/language/streams","alts":[],"httpStatus":200},{"url":"https://dart.dev/guides/libraries/library-tour#stream","alts":[],"httpStatus":200},{"url":"https://pub.dev/","alts":[],"httpStatus":200},{"url":"https://medium.com/dartlang/dart-asynchronous-programming-futures-96937f831137","alts":[{"type":3,"url":"medium://p/96937f831137"},{"type":2,"url":"medium://p/96937f831137"}],"httpStatus":200},{"url":"https://pub.dev/packages/async","alts":[],"httpStatus":200},{"url":"https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a","alts":[{"type":3,"url":"medium://p/bffc3e296a6a"},{"type":2,"url":"medium://p/bffc3e296a6a"}],"httpStatus":200},{"url":"https://medium.com/dartlang/dart-asynchronous-programming-streams-2569a993324d","alts":[{"type":3,"url":"medium://p/2569a993324d"},{"type":2,"url":"medium://p/2569a993324d"}],"httpStatus":200},{"url":"https://flutter.dev/","alts":[],"httpStatus":200},{"url":"https://api.flutter.dev/flutter/widgets/AsyncSnapshot-class.html","alts":[],"httpStatus":200},{"url":"https://api.flutter.dev/flutter/widgets/StreamBuilder-class.html","alts":[],"httpStatus":200},{"url":"https://pub.dev/packages/stream_transform","alts":[],"httpStatus":200},{"url":"https://dart.dev/tutorials/server/cmdline","alts":[],"httpStatus":200},{"url":"https://api.flutter.dev/flutter/widgets/FutureBuilder-class.html","alts":[],"httpStatus":200},{"url":"https://dart.dev/codelabs/iterables","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/2.16.2/dart-async/StreamSubscription/onData.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/2.16.2/dart-async/StreamController-class.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/2.16.2/dart-async/StreamSubscription/onDone.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/2.16.2/dart-async/StreamSubscription/onError.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/2.16.2/dart-html/Document/onChange.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/dart-async/StreamController-class.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/dart-async/Stream/listen.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/2.16.2/dart-async/Zone/print.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/dart-async/Stream-class.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/dart-async/Stream/map.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/dart-async/Stream/asBroadcastStream.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/dart-io/File/openRead.html","alts":[],"httpStatus":200},{"url":"https://flutter.dev/docs/cookbook/networking/web-sockets","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/dart-async/Stream/distinct.html","alts":[],"httpStatus":200}],"version":"0.3","generatedAt":1649935935004},"isLockedPreviewOnly":false,"metaDescription":"","totalClapCount":90,"sectionCount":1,"readingList":0,"topics":[{"topicId":"decb52b64abf","slug":"programming","createdAt":1493934116328,"deletedAt":0,"image":{"id":"1*iPa136b1cGEO7lvoXg6uHQ@2x.jpeg","originalWidth":6016,"originalHeight":4016},"name":"Programming","description":"The good, the bad, the buggy.","relatedTopics":[],"visibility":1,"relatedTags":[],"relatedTopicIds":[],"seoTitle":"Programming News and Articles — Medium","type":"Topic"}]},"coverless":true,"slug":"dart-asynchronous-programming-streams","translationSourcePostId":"","translationSourceCreatorId":"","isApprovedTranslation":false,"inResponseToPostId":"","inResponseToRemovedAt":0,"isTitleSynthesized":true,"allowResponses":true,"importedUrl":"","importedPublishedAt":0,"visibility":0,"uniqueSlug":"dart-asynchronous-programming-streams-dab952023ed7","previewContent":{"bodyModel":{"paragraphs":[{"name":"previewImage","type":4,"text":"","layout":10,"metadata":{"id":"0*4NRFcYLryiLlUIrT","originalWidth":429,"originalHeight":232,"isFeatured":true}},{"name":"80c5","type":3,"text":"Dart asynchronous programming: Streams","markups":[],"alignment":1}],"sections":[{"startIndex":0}]},"isFullContent":false,"subtitle":"This article covers one of the fundamentals of reactive programming: streams, which are objects of type Stream."},"license":0,"inResponseToMediaResourceId":"","canonicalUrl":"https://blog.dart.dev/dart-asynchronous-programming-streams-dab952023ed7","approvedHomeCollectionId":"23738d481ce8","isNewsletter":false,"newsletterId":"","webCanonicalUrl":"https://blog.dart.dev/dart-asynchronous-programming-streams-dab952023ed7","mediumUrl":"https://blog.dart.dev/dart-asynchronous-programming-streams-dab952023ed7","migrationId":"","notifyFollowers":true,"notifyTwitter":false,"notifyFacebook":false,"responseHiddenOnParentPostAt":0,"isSeries":false,"isSubscriptionLocked":false,"seriesLastAppendedAt":0,"audioVersionDurationSec":0,"sequenceId":"","isEligibleForRevenue":false,"isBlockedFromHightower":false,"deletedAt":0,"lockedPostSource":0,"hightowerMinimumGuaranteeStartsAt":0,"hightowerMinimumGuaranteeEndsAt":0,"featureLockRequestAcceptedAt":0,"mongerRequestType":1,"layerCake":3,"socialTitle":"","socialDek":"","editorialPreviewTitle":"","editorialPreviewDek":"","curationEligibleAt":0,"primaryTopic":{"topicId":"decb52b64abf","slug":"programming","createdAt":1493934116328,"deletedAt":0,"image":{"id":"1*iPa136b1cGEO7lvoXg6uHQ@2x.jpeg","originalWidth":6016,"originalHeight":4016},"name":"Programming","description":"The good, the bad, the buggy.","relatedTopics":[],"visibility":1,"relatedTags":[],"relatedTopicIds":[],"seoTitle":"Programming News and Articles — Medium","type":"Topic"},"primaryTopicId":"decb52b64abf","isProxyPost":false,"proxyPostFaviconUrl":"","proxyPostProviderName":"","proxyPostType":0,"isSuspended":false,"isLimitedState":false,"seoTitle":"","previewContent2":{"bodyModel":{"paragraphs":[{"name":"80c5","type":3,"text":"Dart asynchronous programming: Streams","markups":[]},{"name":"4e3c","type":4,"text":"A simple Flutter app that displays data from a stream","markups":[],"layout":1,"metadata":{"id":"0*yUEX9fxMxoG63vi0.gif","originalWidth":272,"originalHeight":309}},{"name":"3775","type":1,"text":"This article covers one of the fundamentals of reactive programming: streams, which are objects of type Stream.","markups":[{"type":10,"start":104,"end":110},{"type":3,"start":104,"end":110,"href":"https://api.dart.dev/stable/dart-async/Stream-class.html","title":"","rel":"noopener ugc nofollow","anchorType":0}]},{"name":"75b6","type":1,"text":"If you’ve read our previous articles on futures, you might remember that each future represents a single value (either an error or data)…","markups":[{"type":3,"start":19,"end":47,"href":"https://medium.com/dartlang/dart-asynchronous-programming-futures-96937f831137","title":"","rel":"","anchorType":0},{"type":1,"start":73,"end":111},{"type":1,"start":147,"end":161},{"type":1,"start":219,"end":220},{"type":1,"start":221,"end":227},{"type":1,"start":228,"end":271},{"type":1,"start":276,"end":280}]}],"sections":[{"name":"e2b0","startIndex":0}]},"isFullContent":false,"subtitle":"This article covers one of the fundamentals of reactive programming: streams, which are objects of type Stream."},"cardType":0,"isDistributionAlertDismissed":false,"isShortform":false,"shortformType":0,"responsesLocked":false,"isLockedResponse":false,"isPublishToEmail":false,"responseDistribution":0,"isMarkedPaywallOnly":false,"type":"Post"},"mentionedUsers":[],"collaborators":[],"hideMeter":false,"shareKey":"1b3d5e62ff20705563a98233fd361e59","collectionUserRelations":[{"collectionId":"23738d481ce8","userId":"8b6a7f6f197d","role":"ADMIN"},{"collectionId":"4da7dfd21a33","userId":"8b6a7f6f197d","role":"WRITER"},{"collectionId":"24d8f4fa8912","userId":"8b6a7f6f197d","role":"WRITER"}],"mode":"canEdit","references":{"User":{"1d07d30c7b26":{"userId":"1d07d30c7b26","name":"Flutter Devrel Medium","username":"flutter.devrel","createdAt":1642196606522,"imageId":"1*dmbNkD5D-u45r44go_cf0g.png","backgroundImageId":"","bio":"","twitterScreenName":"","socialStats":{"userId":"1d07d30c7b26","usersFollowedCount":1,"usersFollowedByCount":17,"type":"SocialStats"},"social":{"userId":"8b6a7f6f197d","targetUserId":"1d07d30c7b26","type":"Social"},"allowNotes":1,"mediumMemberAt":0,"isWriterProgramEnrolled":true,"isSuspended":false,"isMembershipTrialEligible":true,"facebookDisplayName":"","optInToIceland":true,"hasCompletedProfile":false,"userDismissableFlags":[2,12,21,29,52,58,59,62],"hasSeenIcelandOnboarding":false,"postSubscribeMembershipUpsellShownAt":0,"languageCode":"en-us","type":"User"}},"Collection":{"23738d481ce8":{"id":"23738d481ce8","name":"Dart","slug":"dartlang","tags":["MOBILE APP DEVELOPMENT","WEB DEVELOPMENT","DART","PROGRAMMING LANGUAGES","SOFTWARE DEVELOPMENT"],"creatorId":"a6d788faa5e5","description":"Dart is an approachable, portable, and productive language for high-quality apps on any platform. Learn more at https://dart.dev.","shortDescription":"Dart is an approachable, portable, and productive language…","image":{"imageId":"1*uWy1Ajpd0oTUQBO9WBHoQg@2x.png","filter":"","backgroundSize":"","originalWidth":1001,"originalHeight":1001,"strategy":"resample","height":0,"width":0},"metadata":{"followerCount":14031,"activeAt":1762974121956},"virtuals":{"permissions":{"canPublish":true,"canPublishAll":true,"canRepublish":true,"canRemove":true,"canManageAll":true,"canSubmit":true,"canEditPosts":true,"canAddWriters":true,"canViewStats":true,"canSendNewsletter":true,"canViewLockedPosts":true,"canViewCloaked":true,"canEditOwnPosts":true,"canBeAssignedAuthor":true,"canEnrollInHightower":false,"canLockPostsForMediumMembers":false,"canLockOwnPostsForMediumMembers":false,"canViewNewsletterV2Stats":true,"canCreateNewsletterV3":true},"isSubscribed":true,"isEnrolledInHightower":false,"isEligibleForHightower":false,"isSubscribedToCollectionEmails":false,"isMuted":false,"canToggleEmail":false,"isWriter":false},"logo":{"imageId":"1*NRb7RFVWJQFzY47j3v4U7Q.png","filter":"","backgroundSize":"","originalWidth":400,"originalHeight":154,"strategy":"resample","height":0,"width":0},"twitterUsername":"dart_lang","publicEmail":"medium@dartlang.org","domain":"blog.dart.dev","sections":[{"type":2,"collectionHeaderMetadata":{"title":"Dart","description":"An approachable, portable, and productive language for high-quality apps on any platform","backgroundImage":{},"logoImage":{"id":"1*knHF_qpxdtS8h0Z8EeqowA@2x.png","originalWidth":1080,"originalHeight":1080,"alt":"Dart"},"alignment":2,"layout":5}},{"type":1,"postListMetadata":{"source":1,"layout":4,"number":7,"postIds":[]}},{"type":1,"postListMetadata":{"source":1,"layout":5,"number":15,"postIds":[]}}],"tintColor":"#FF042B59","lightText":true,"favicon":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"colorPalette":{"defaultBackgroundSpectrum":{"colorPoints":[{"color":"#FF6588BA","point":0},{"color":"#FF607EAB","point":0.1},{"color":"#FF59759C","point":0.2},{"color":"#FF536B8E","point":0.3},{"color":"#FF4C617F","point":0.4},{"color":"#FF445670","point":0.5},{"color":"#FF3D4B61","point":0.6},{"color":"#FF344052","point":0.7},{"color":"#FF2B3442","point":0.8},{"color":"#FF212832","point":0.9},{"color":"#FF161A22","point":1}],"backgroundColor":"#FFFFFFFF"},"tintBackgroundSpectrum":{"colorPoints":[{"color":"#FF042B59","point":0},{"color":"#FF294871","point":0.1},{"color":"#FF456087","point":0.2},{"color":"#FF5F779B","point":0.3},{"color":"#FF788DAD","point":0.4},{"color":"#FF8FA2BF","point":0.5},{"color":"#FFA5B6CF","point":0.6},{"color":"#FFBBC9DF","point":0.7},{"color":"#FFD1DCEE","point":0.8},{"color":"#FFE6EEFC","point":0.9},{"color":"#FFFBFFFF","point":1}],"backgroundColor":"#FF042B59"},"highlightSpectrum":{"colorPoints":[{"color":"#FFECF3FF","point":0},{"color":"#FFE9F2FF","point":0.1},{"color":"#FFE5F0FF","point":0.2},{"color":"#FFE2EFFF","point":0.3},{"color":"#FFDEEDFF","point":0.4},{"color":"#FFDBEBFF","point":0.5},{"color":"#FFD7EAFF","point":0.6},{"color":"#FFD3E8FF","point":0.7},{"color":"#FFCFE6FF","point":0.8},{"color":"#FFCBE5FF","point":0.9},{"color":"#FFC8E3FF","point":1}],"backgroundColor":"#FFFFFFFF"},"darkBackgroundSpectrum":{"colorPoints":[{"color":"#FF7DA0D3","point":0},{"color":"#FF89A9D8","point":0.1},{"color":"#FF94B1DC","point":0.2},{"color":"#FFA0B9E0","point":0.3},{"color":"#FFABC1E3","point":0.4},{"color":"#FFB6C9E7","point":0.5},{"color":"#FFC0D1EB","point":0.6},{"color":"#FFCBD8EF","point":0.7},{"color":"#FFD5E0F2","point":0.8},{"color":"#FFE0E7F6","point":0.9},{"color":"#FFEAEFFA","point":1}],"backgroundColor":"#FF000000"}},"navItems":[{"type":1,"title":"Announcements","tagSlug":"announcements","url":"https://blog.dart.dev/tagged/announcements","source":"tagSlug"},{"type":5,"title":"Archive","url":"https://blog.dart.dev/archive"},{"type":3,"title":"dart.dev","url":"https://dart.dev"}],"colorBehavior":2,"collectionFeatures":[25],"ampLogo":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"header":{"title":"Dart","description":"An approachable, portable, and productive language for high-quality apps on any platform","backgroundImage":{},"logoImage":{"id":"1*knHF_qpxdtS8h0Z8EeqowA@2x.png","originalWidth":1080,"originalHeight":1080,"alt":"Dart"},"alignment":2,"layout":5},"subscriberCount":14031,"tagline":"Dart is a client-optimized language for fast apps on any platform.","isOptedIntoAurora":false,"isCurationAllowedByDefault":false,"polarisCoverImage":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"ptsQualifiedAt":1616092887098,"type":"Collection"}},"Social":{"1d07d30c7b26":{"userId":"8b6a7f6f197d","targetUserId":"1d07d30c7b26","type":"Social"}},"SocialStats":{"1d07d30c7b26":{"userId":"1d07d30c7b26","usersFollowedCount":1,"usersFollowedByCount":17,"type":"SocialStats"}}}},"v":3,"b":"20260130-1012-root"}