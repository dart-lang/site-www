{"success":true,"payload":{"value":{"id":"547ef3d6459b","versionId":"2a120c557e83","creatorId":"ae996dbdd76e","homeCollectionId":"23738d481ce8","title":"Better isolate management with Isolate.run()","detectedLanguage":"en","latestVersion":"2a120c557e83","latestPublishedVersion":"2a120c557e83","hasUnpublishedEdits":false,"latestRev":425,"createdAt":1674060552072,"updatedAt":1674696063781,"acceptedAt":0,"firstPublishedAt":1674589578995,"latestPublishedAt":1674696062743,"vote":false,"experimentalCss":"","displayAuthor":"","content":{"subtitle":"Dart 2.19 introduces a new function that makes implementing concurrency as simple as a single line of code.","bodyModel":{"paragraphs":[{"name":"c240","type":3,"text":"Better isolate management with Isolate.run()","markups":[]},{"name":"dbe8","type":13,"text":"Dart 2.19 introduces a new function that makes implementing concurrency as simple as a single line of code.","markups":[]},{"name":"8c0c","type":4,"text":"A benchmark test showcasing the speed of the new Isolate.run() function","markups":[],"layout":1,"metadata":{"id":"0*Bt-V4nlGjNKquFhK","originalWidth":597,"originalHeight":386,"isFeatured":true}},{"name":"9695","type":1,"text":"All Dart code runs in isolates. Whether you implement multiple isolates to enable concurrency in your Dart programs is up to you. How you can implement multiple isolates is up to us on the Dart team, and in Dart 2.19, we’ve made a huge upgrade to the process that we’re excited to share. Meet Isolate.run()!","markups":[{"type":10,"start":293,"end":306},{"type":3,"start":82,"end":93,"href":"https://dart.dev/guides/language/concurrency","title":"","rel":"","anchorType":0},{"type":2,"start":130,"end":133}]},{"name":"1458","type":1,"text":"run() takes all of the complexity of setting up and managing isolates and completely abstracts it into a single function call. It’s been possible to use isolates with a handful of primitives for a while now. But, even with all the recent performance improvements for isolates, the process was at best, tedious, and at worst, error-prone.","markups":[{"type":10,"start":0,"end":5},{"type":3,"start":227,"end":262,"href":"https://medium.com/dartlang/dart-2-15-7e7a598e508a#:~:text=publishers%2C%20and%20more.-,Fast%20concurrency%20with%20worker%20isolates,-Just%20about%20all","title":"","rel":"","anchorType":0}]},{"name":"e302","type":1,"text":"To appreciate how much of an improvement run() is, this article breaks down the previous method of building out the functionality piece-by-piece from low-level primitives. Then, we’ll contrast that to using Isolate.run(), and show you how it works on the inside. Even if you’ve never used isolates before, we’re sure that run() will get you excited to try them out!","markups":[{"type":10,"start":41,"end":46},{"type":10,"start":207,"end":220},{"type":10,"start":322,"end":327}]},{"name":"e34e","type":13,"text":"Isolates","markups":[]},{"name":"9c4e","type":1,"text":"Isolates are a fairly straightforward concept. An isolate is essentially a single thread of execution in Dart. They let you execute parts of your code in parallel. You can start new parallel executions (as many as you want) and tell them what to do, right from main (the main thread, or main isolate). Isolates don’t share memory; instead, they pass messages back and forth to communicate. So, you don’t have to worry about typical multithreading problems, like race conditions, or mutexes and locks.","markups":[{"type":10,"start":261,"end":265},{"type":3,"start":50,"end":57,"href":"https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a","title":"","rel":"","anchorType":0},{"type":3,"start":287,"end":299,"href":"https://dart.dev/guides/language/concurrency#the-main-isolate","title":"","rel":"","anchorType":0}]},{"name":"ee87","type":4,"text":"","markups":[],"layout":1,"metadata":{"id":"0*eCogwJXZtpbg5Hbq.png","originalWidth":613,"originalHeight":183}},{"name":"b04d","type":1,"text":"Sounds great! But how do you use them? Before Isolate.run(), that’s where things became tricky.","markups":[{"type":10,"start":46,"end":59}]},{"name":"4724","type":1,"text":"The isolate API is made up of low-level primitives that provide a wide range of functionality. Granularity like that is great when you need to customize your isolates’ functionality. Granularity is not so great, though, when it’s necessary to use isolates at all. Especially since almost all of the use cases for isolates require the same basic configurations for setup and management. This basically meant exposing every implementation detail for you, Dart’s users, to handle yourselves.","markups":[{"type":3,"start":0,"end":15,"href":"https://api.dart.dev/stable/dart-isolate/Isolate-class.html","title":"","rel":"","anchorType":0},{"type":2,"start":256,"end":262}]},{"name":"e27e","type":1,"text":"Let’s take a look at a typical isolate setup to better understand the tedious process that Isolate.run() solves.","markups":[{"type":10,"start":91,"end":104}]},{"name":"8c08","type":13,"text":"Using Isolates (before)","markups":[]},{"name":"52ae","type":1,"text":"You can think of Isolate.spawn() as the old starting point for isolates. Flutter’s compute function was built off of spawn(). It takes a method to invoke as its entrypoint argument, plus any arguments for that method, and other configurations for the isolate itself. In the past, this entrypoint could only be a top-level or static method.","markups":[{"type":10,"start":17,"end":32},{"type":10,"start":117,"end":124},{"type":10,"start":161,"end":171},{"type":10,"start":285,"end":295},{"type":3,"start":17,"end":32,"href":"https://api.dart.dev/stable/dart-isolate/Isolate/spawn.html","title":"","rel":"","anchorType":0}]},{"name":"416b","type":1,"text":"Isolate.spawn(_readAndParseJson, filename);","markups":[{"type":10,"start":0,"end":43}]},{"name":"bbae","type":1,"text":"Isolate created, all done! Just kidding. Not even close.","markups":[]},{"name":"91ba","type":1,"text":"Calling spawn won’t return anything to actually work with. It only returns an isolate object, which simply confirms the isolate has started.","markups":[{"type":10,"start":8,"end":13}]},{"name":"4a3d","type":1,"text":"The main isolate and the spawned isolate (the isolate created by spawn()) can’t communicate directly, beyond the initial arguments passed on creation. Realistically, even if you don’t need any computation results back from the spawned isolate, you would still want some kind of verification that the computation succeeded, so you’re always going to want a message back.","markups":[{"type":10,"start":65,"end":72}]},{"name":"5dcb","type":1,"text":"To enable communication, you have to set up ports. You create a ReceivePort object before calling spawn. The sendPort member of the ReceivePort object goes to the spawned isolate as another argument for spawn.","markups":[{"type":10,"start":64,"end":75},{"type":10,"start":109,"end":117},{"type":10,"start":132,"end":143},{"type":10,"start":203,"end":208}]},{"name":"88df","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"a4077fd46ce2a68512e9f71114184b0d","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"3654","type":1,"text":"This means the function you pass to spawn has to be specifically configured to do something with that sendPort. In other words, you can’t just reuse existing functions with isolates. So instead of passing spawn a regular function that just reads and parses a JSON file, you would create something like:","markups":[{"type":10,"start":36,"end":41},{"type":10,"start":102,"end":110},{"type":10,"start":205,"end":210},{"type":2,"start":52,"end":64}]},{"name":"6b38","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"3c3916b9af5918d16e89f9437412f5be","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"6738","type":1,"text":"Your special, isolate-friendly, JSON-decoding function can simply “return result” and you’re all done, right? Not quite. The result needs to be sent through responsePort. That’s how isolates communicate with ports. You can use another primitive, Isolate.exit() to return the result efficiently and close the spawned isolate at the same time:","markups":[{"type":10,"start":67,"end":80},{"type":10,"start":157,"end":169},{"type":10,"start":246,"end":260},{"type":3,"start":246,"end":260,"href":"https://api.dart.dev/stable/dart-isolate/Isolate/exit.html","title":"","rel":"","anchorType":0}]},{"name":"ec55","type":1,"text":"Isolate.exit(responsePort, result);","markups":[{"type":10,"start":0,"end":35}]},{"name":"7b86","type":1,"text":"The exit() function transfers the memory that holds the message in the spawned isolate to the main isolate (as opposed to copying it over) and safely closes the isolate.","markups":[{"type":10,"start":4,"end":10},{"type":2,"start":20,"end":29}]},{"name":"87fb","type":1,"text":"Let’s string this all together. Since result in this example is parsed JSON , you’d probably want to destructure it a little to actually use it. For the sake of clean code, instead of planting those three lines that create the receivePort and the isolate, and await their response, right into main(), we should put them in their own function.","markups":[{"type":10,"start":38,"end":44},{"type":10,"start":227,"end":238},{"type":10,"start":293,"end":299}]},{"name":"ac85","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"6f6acb3dc6833cf9b34ee4a65fd474b9","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"ecb9","type":1,"text":"What’s being accomplished is relatively straightforward. It’s the exposure of implementation details that makes it feel complicated, like ports for message passing, and needing a dedicated function for dealing with ports that’s otherwise isolate-agnostic.","markups":[{"type":2,"start":115,"end":119}]},{"name":"fb41","type":13,"text":"Error handling","markups":[]},{"name":"a7f8","type":1,"text":"The example so far still isn’t really a “complete”, production-ready implementation. You’d be doing yourself a disservice to leave out any kind of error handling, but it’s commonly forgotten as an additional step in an already substantial process. Without any error handling, if an uncaught async error were to crash your isolate, for example, you wouldn’t know what happened to cause the error, or even be alerted that anything had happened at all.","markups":[{"type":2,"start":19,"end":24},{"type":2,"start":420,"end":448}]},{"name":"0c57","type":1,"text":"Covering every error handling possibility for isolates would be extensive, but in general it would involve a few more additions to the code.","markups":[]},{"name":"dc20","type":1,"text":"You could, as a minimum, add the errorsAreFatal, onExit, and onError parameters to the spawn call:","markups":[{"type":10,"start":33,"end":47},{"type":10,"start":49,"end":55},{"type":10,"start":61,"end":68}]},{"name":"7ee5","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"b60a3ddf74c038ebee17f3be498ea7d0","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"0782","type":1,"text":"This ensures that resultPort receives a message even if the spawned isolate terminates without sending a result, or if it has any uncaught errors. Making errors fatal means uncaught errors exit the isolate as a safety precaution, to ensure it terminates at all.","markups":[{"type":10,"start":18,"end":28}]},{"name":"4aef","type":1,"text":"The onExit argument makes the isolate send null to the port upon exiting. The onError argument makes an uncaught error send a list of two strings to the port (the toString of both the error and stack trace).","markups":[{"type":10,"start":4,"end":10},{"type":10,"start":43,"end":47},{"type":10,"start":78,"end":85},{"type":10,"start":163,"end":171}]},{"name":"24ed","type":1,"text":"Reusing the result port lets you avoid creating more ports, so you only have to look for messages in one place. But it also means you need to distinguish the onExit and onError messages from the result value. Here, we assume that the JSON must be a Map, so it cannot be a list or null. Otherwise you’d also have to wrap the result in something recognizable. You would have to create a (trivial) message protocol on top of the port messages.","markups":[{"type":10,"start":158,"end":164},{"type":10,"start":169,"end":176},{"type":10,"start":249,"end":252},{"type":10,"start":280,"end":284}]},{"name":"0798","type":1,"text":"Beyond that minimum, you could then check response for specific errors. One such case would be checking if resultPort is null, meaning the isolate terminated without sending results:","markups":[{"type":10,"start":42,"end":50},{"type":10,"start":107,"end":117},{"type":10,"start":121,"end":125}]},{"name":"9ad3","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"1f9685110e29257f5f98445596375d34","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"4670","type":1,"text":"Another would be checking if the result is a list, meaning an uncaught error occurred:","markups":[]},{"name":"c91c","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"72f7164fb07f16c509283dadd6b23501","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"dae1","type":1,"text":"Then, finally, handle an actual result:","markups":[]},{"name":"90a7","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"01681a8643cf50c9bc1c0956bf05ac27","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"69e4","type":1,"text":"In any case, you’d want to put spawn in a try block to check if sending the entrypoint to the new isolate failed. If it did, the result port won’t get any message, and needs to be closed:","markups":[{"type":10,"start":31,"end":36},{"type":10,"start":42,"end":45},{"type":10,"start":76,"end":86}]},{"name":"1ade","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"3e3b35ae765e1ef261a74858b73e2d49","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"aedc","type":1,"text":"Providing a bare minimum of error handling ensures that the result port is always closed, and _spawnAndReceieve always completes, no matter how the spawned isolate exits. You could also make things nicer, for example, by catching and sending errors and stack traces back as actual objects, not just strings like the onError handler.","markups":[{"type":10,"start":94,"end":111},{"type":10,"start":316,"end":323},{"type":2,"start":198,"end":203}]},{"name":"3c32","type":1,"text":"Error handling obviously introduces a lot of variation, and with it the mental overhead of deciding how to approach it and what to factor for. It’s understandable that it’s commonly left out of primitive isolate setup.","markups":[]},{"name":"8025","type":13,"text":"Using Isolates (after)","markups":[]},{"name":"b659","type":1,"text":"Isolate.run() sets up all parts of isolate implementation with the primitives you previously had to use yourself, in a single function call:","markups":[{"type":10,"start":0,"end":13}]},{"name":"aeda","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"27ee342686cba4d9546ef2a49a0dbfd9","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"fc85","type":1,"text":"No ports, no separate spawning, exiting, or error handling, and no special return structure. Perhaps the best part, the entrypoint you pass to run can be any existing function:","markups":[{"type":10,"start":120,"end":130},{"type":10,"start":143,"end":146}]},{"name":"26c2","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"20a0d24ac90487ddb8d0cc1cf66a71be","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"70ef","type":1,"text":"This example shows an asynchronous function, but run could just as easily execute a synchronous function. The run function itself always returns asynchronously, which is all that matters.","markups":[{"type":10,"start":49,"end":52},{"type":10,"start":110,"end":113},{"type":2,"start":22,"end":34},{"type":2,"start":84,"end":95}]},{"name":"1390","type":1,"text":"The entrypoint can also be a function expression, written directly inline wherever you call run. Isolates, and any higher-level APIs written on top, are no longer limited to running only static or top-level functions.","markups":[{"type":10,"start":4,"end":14},{"type":10,"start":92,"end":95},{"type":2,"start":29,"end":48}]},{"name":"f469","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"c270b53649cac8d66aaea6af997502dd","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"f026","type":1,"text":"The additional message parameter is no longer necessary, and you can avoid packing and unpacking arguments in data structures like lists.","markups":[]},{"name":"3fa4","type":1,"text":"You don’t have to think much about error handling at all. The run function combines local and remote error capturing, handling and cross-isolate communication, and exposes the result as a single normal (asynchronous) error that you can catch in a standard try/catch. You can forget isolates, and treat it as a normal function.","markups":[{"type":10,"start":62,"end":65},{"type":10,"start":256,"end":259},{"type":10,"start":260,"end":265}]},{"name":"f4f8","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"e9bf5b788a505cbf800d506948ba838d","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"1dd4","type":1,"text":"Isolate.run() enables much cleaner and ergonomic code. Flutter’s compute function even switched over to using run instead of spawn!","markups":[{"type":10,"start":0,"end":13},{"type":10,"start":65,"end":72},{"type":10,"start":110,"end":113},{"type":10,"start":125,"end":130}]},{"name":"bbfc","type":13,"text":"Inside Isolate.run()","markups":[]},{"name":"26bc","type":1,"text":"Take a look at the implementation of run itself. It digs into all the low-level isolate-related APIs (which would’ve been your job to implement before) to construct a “perfect”, comprehensive isolate setup. It takes the method to execute, computation, and sets up all the ports and their returns to account for efficient message passing between isolates.","markups":[{"type":10,"start":37,"end":40},{"type":10,"start":239,"end":250},{"type":3,"start":19,"end":40,"href":"https://api.dart.dev/dev/3.0.0-125.0.dev/dart-isolate/Isolate/run.html#implementation:~:text=isolate%20for%20debugging.-,Implementation,-%40Since(%222.19","title":"","rel":"noopener","anchorType":0}]},{"name":"917a","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"4ca8d776662ead618f17933fb574dc36","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"19d0","type":1,"text":"There’s thorough error handling for every potential case. The run function checks whether an isolate dies before it’s done computing. If the computation throws, the isolate terminates and throws the same error to the main isolate.","markups":[{"type":10,"start":62,"end":65},{"type":2,"start":8,"end":16}]},{"name":"0976","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"2f15aa7cd2ffcaec4c1c64f9f57f22be","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"309e","type":1,"text":"If an uncaught asynchronous error occurs, the isolate terminates and reports the error asynchronously to the main isolate. If the main isolate terminates first, the spawned isolate terminates and treats the situation as an uncaught async error.","markups":[]},{"name":"ee40","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"87593ee587c105fb32549fe1368bb783","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"4f94","type":1,"text":"Lastly, run always uses exit to safely shut down. That means data is efficiently transferred from isolate to isolate without actually copying it.","markups":[{"type":10,"start":8,"end":11},{"type":10,"start":24,"end":28}]},{"name":"75b3","type":13,"text":"Summary","markups":[]},{"name":"f7c9","type":1,"text":"The run function is ideal for starting one computation and waiting for the results. The primitives are still there if you want to build out your own isolate setup for something that run doesn’t cover, like a long-running isolate that can send and receive messages multiple times. For most cases though, replacing spawn and all its supporting configurations with a single run statement should be used over any other configuration.","markups":[{"type":10,"start":4,"end":7},{"type":10,"start":182,"end":185},{"type":10,"start":313,"end":318},{"type":10,"start":371,"end":374},{"type":3,"start":208,"end":228,"href":"https://github.com/dart-lang/samples/blob/master/isolates/bin/long_running_isolate.dart","title":"","rel":"","anchorType":0}]},{"name":"fce6","type":1,"text":"If you’d never tried isolate management before run, it would be hard to believe all this functionality previously had to be implemented by the user! Isolate.run() — available in Dart 2.19 and Flutter 3.7 — makes code so much more ergonomic, and makes isolates so much easier to use. What will you do with all the time run saves you?","markups":[{"type":10,"start":47,"end":50},{"type":10,"start":149,"end":162},{"type":10,"start":318,"end":321}]}],"sections":[{"name":"4117","startIndex":0}]},"postDisplay":{"coverless":true}},"virtuals":{"statusForCollection":"APPROVED","allowNotes":true,"previewImage":{"imageId":"0*Bt-V4nlGjNKquFhK","filter":"","backgroundSize":"","originalWidth":597,"originalHeight":386,"strategy":"resample","height":0,"width":0},"wordCount":1759,"imageCount":2,"readingTime":7.021069182389938,"subtitle":"Dart 2.19 introduces a new function that makes implementing concurrency as simple as a single line of code.","userPostRelation":{"userId":"8b6a7f6f197d","postId":"547ef3d6459b","readAt":0,"readLaterAddedAt":0,"votedAt":0,"collaboratorAddedAt":0,"notesAddedAt":0,"subscribedAt":0,"lastReadSectionName":"","lastReadVersionId":"","lastReadAt":0,"lastReadParagraphName":"","lastReadPercentage":0,"viewedAt":0,"presentedCountInResponseManagement":0,"clapCount":0,"seriesUpdateNotifsOptedInAt":0,"queuedAt":0,"seriesFirstViewedAt":0,"presentedCountInStream":10,"seriesLastViewedAt":0,"audioProgressSec":0},"publishedInCount":1,"usersBySocialRecommends":[],"noIndex":false,"recommends":127,"isBookmarked":false,"tags":[{"slug":"dart","name":"Dart","postCount":13858,"metadata":{"postCount":13858,"coverImage":{"id":"1*rQugDrmwFFsEDL_CqSBJNw.png","originalWidth":1536,"originalHeight":1024,"isFeatured":true}},"type":"Tag"},{"slug":"concurrency","name":"Concurrency","postCount":6496,"metadata":{"postCount":6496,"coverImage":{"id":"1*zaXhPPm7SXqfMfgDWoTVPw.png","originalWidth":2270,"originalHeight":2070,"isFeatured":true}},"type":"Tag"},{"slug":"dartlang","name":"Dartlang","postCount":921,"metadata":{"postCount":921,"coverImage":{"id":"1*HNqQFQ2hdhAgjew1pIMqXA.png","originalWidth":2752,"originalHeight":1536,"isFeatured":true}},"type":"Tag"},{"slug":"asynchronous-programming","name":"Asynchronous Programming","postCount":2129,"metadata":{"postCount":2129,"coverImage":{"id":"1*x4eT5WcXZINAKinGVXySuw.png","originalWidth":1280,"originalHeight":720,"isFeatured":true}},"type":"Tag"},{"slug":"flutter","name":"Flutter","postCount":43303,"metadata":{"postCount":43303,"coverImage":{"id":"1*8zlpgRA1agpvWp-OiFKlJw.png","originalWidth":1536,"originalHeight":1024,"isFeatured":true}},"type":"Tag"}],"socialRecommendsCount":0,"responsesCreatedCount":8,"links":{"entries":[{"url":"https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a","alts":[{"type":3,"url":"medium://p/bffc3e296a6a"},{"type":2,"url":"medium://p/bffc3e296a6a"}],"httpStatus":200},{"url":"https://medium.com/dartlang/dart-2-15-7e7a598e508a#:~:text=publishers%2C%20and%20more.-,Fast%20concurrency%20with%20worker%20isolates,-Just%20about%20all","alts":[{"type":3,"url":"medium://p/7e7a598e508a"},{"type":2,"url":"medium://p/7e7a598e508a"}],"httpStatus":200},{"url":"https://dart.dev/guides/language/concurrency#the-main-isolate","alts":[],"httpStatus":200},{"url":"https://dart.dev/guides/language/concurrency","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/dart-isolate/Isolate-class.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/dev/3.0.0-125.0.dev/dart-isolate/Isolate/run.html#implementation:~:text=isolate%20for%20debugging.-,Implementation,-%40Since(%222.19","alts":[],"httpStatus":200},{"url":"https://github.com/dart-lang/samples/blob/master/isolates/bin/long_running_isolate.dart","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/dart-isolate/Isolate/exit.html","alts":[],"httpStatus":200},{"url":"https://api.dart.dev/stable/dart-isolate/Isolate/spawn.html","alts":[],"httpStatus":200}],"version":"0.3","generatedAt":1674696063357},"isLockedPreviewOnly":false,"metaDescription":"","totalClapCount":1218,"sectionCount":1,"readingList":0,"topics":[{"topicId":"decb52b64abf","slug":"programming","createdAt":1493934116328,"deletedAt":0,"image":{"id":"1*iPa136b1cGEO7lvoXg6uHQ@2x.jpeg","originalWidth":6016,"originalHeight":4016},"name":"Programming","description":"The good, the bad, the buggy.","relatedTopics":[],"visibility":1,"relatedTags":[],"relatedTopicIds":[],"seoTitle":"Programming News and Articles — Medium","type":"Topic"}]},"coverless":true,"slug":"better-isolate-management-with-isolate-run","translationSourcePostId":"","translationSourceCreatorId":"","isApprovedTranslation":false,"inResponseToPostId":"","inResponseToRemovedAt":0,"isTitleSynthesized":true,"allowResponses":true,"importedUrl":"","importedPublishedAt":0,"visibility":0,"uniqueSlug":"better-isolate-management-with-isolate-run-547ef3d6459b","previewContent":{"bodyModel":{"paragraphs":[{"name":"previewImage","type":4,"text":"","layout":10,"metadata":{"id":"0*Bt-V4nlGjNKquFhK","originalWidth":597,"originalHeight":386,"isFeatured":true}},{"name":"c240","type":3,"text":"Better isolate management with Isolate.run()","markups":[],"alignment":1},{"name":"dbe8","type":13,"text":"Dart 2.19 introduces a new function that makes…","markups":[],"alignment":1}],"sections":[{"startIndex":0}]},"isFullContent":false,"subtitle":"Dart 2.19 introduces a new function that makes implementing concurrency as simple as a single line of code."},"license":0,"inResponseToMediaResourceId":"","canonicalUrl":"https://blog.dart.dev/better-isolate-management-with-isolate-run-547ef3d6459b","approvedHomeCollectionId":"23738d481ce8","isNewsletter":false,"newsletterId":"","webCanonicalUrl":"https://blog.dart.dev/better-isolate-management-with-isolate-run-547ef3d6459b","mediumUrl":"https://blog.dart.dev/better-isolate-management-with-isolate-run-547ef3d6459b","migrationId":"","notifyFollowers":true,"notifyTwitter":false,"notifyFacebook":false,"responseHiddenOnParentPostAt":0,"isSeries":false,"isSubscriptionLocked":false,"seriesLastAppendedAt":0,"audioVersionDurationSec":0,"sequenceId":"","isEligibleForRevenue":false,"isBlockedFromHightower":false,"deletedAt":0,"lockedPostSource":0,"hightowerMinimumGuaranteeStartsAt":0,"hightowerMinimumGuaranteeEndsAt":0,"featureLockRequestAcceptedAt":0,"mongerRequestType":1,"layerCake":3,"socialTitle":"","socialDek":"","editorialPreviewTitle":"","editorialPreviewDek":"","curationEligibleAt":0,"primaryTopic":{"topicId":"decb52b64abf","slug":"programming","createdAt":1493934116328,"deletedAt":0,"image":{"id":"1*iPa136b1cGEO7lvoXg6uHQ@2x.jpeg","originalWidth":6016,"originalHeight":4016},"name":"Programming","description":"The good, the bad, the buggy.","relatedTopics":[],"visibility":1,"relatedTags":[],"relatedTopicIds":[],"seoTitle":"Programming News and Articles — Medium","type":"Topic"},"primaryTopicId":"decb52b64abf","isProxyPost":false,"proxyPostFaviconUrl":"","proxyPostProviderName":"","proxyPostType":0,"isSuspended":false,"isLimitedState":false,"seoTitle":"","previewContent2":{"bodyModel":{"paragraphs":[{"name":"c240","type":3,"text":"Better isolate management with Isolate.run()","markups":[]},{"name":"dbe8","type":13,"text":"Dart 2.19 introduces a new function that makes implementing concurrency as simple as a single line of code.","markups":[]},{"name":"8c0c","type":4,"text":"A benchmark test showcasing the speed of the new Isolate.run() function","markups":[],"layout":1,"metadata":{"id":"0*Bt-V4nlGjNKquFhK","originalWidth":597,"originalHeight":386,"isFeatured":true}},{"name":"9695","type":1,"text":"All Dart code runs in isolates. Whether you implement multiple isolates to enable concurrency in your Dart programs is up to you. How you can implement multiple isolates is up to us on the Dart team, and in Dart 2.19, we’ve made a huge upgrade to the process that we’re…","markups":[{"type":10,"start":293,"end":306},{"type":3,"start":82,"end":93,"href":"https://dart.dev/guides/language/concurrency","title":"","rel":"","anchorType":0},{"type":2,"start":130,"end":133}]}],"sections":[{"name":"4117","startIndex":0}]},"isFullContent":false,"subtitle":"Dart 2.19 introduces a new function that makes implementing concurrency as simple as a single line of code."},"cardType":0,"isDistributionAlertDismissed":false,"isShortform":false,"shortformType":0,"responsesLocked":false,"isLockedResponse":false,"isPublishToEmail":false,"responseDistribution":0,"isMarkedPaywallOnly":false,"type":"Post"},"mentionedUsers":[],"collaborators":[],"hideMeter":false,"shareKey":"f149642ff9d2351865a77468693125de","collectionUserRelations":[{"collectionId":"23738d481ce8","userId":"8b6a7f6f197d","role":"ADMIN"},{"collectionId":"4da7dfd21a33","userId":"8b6a7f6f197d","role":"WRITER"},{"collectionId":"24d8f4fa8912","userId":"8b6a7f6f197d","role":"WRITER"}],"mode":"canEdit","references":{"User":{"ae996dbdd76e":{"userId":"ae996dbdd76e","name":"Marya Belanger","username":"mbelanger_65682","createdAt":1661376028922,"imageId":"1*dvfKkfTnezv7BhXgB51pGA.png","backgroundImageId":"","bio":"Technical Writer for Dart","twitterScreenName":"","socialStats":{"userId":"ae996dbdd76e","usersFollowedCount":2,"usersFollowedByCount":436,"type":"SocialStats"},"social":{"userId":"8b6a7f6f197d","targetUserId":"ae996dbdd76e","type":"Social"},"allowNotes":1,"mediumMemberAt":0,"isWriterProgramEnrolled":true,"isSuspended":false,"isMembershipTrialEligible":true,"facebookDisplayName":"","optInToIceland":true,"hasCompletedProfile":false,"userDismissableFlags":[2,8,29,32,33],"hasSeenIcelandOnboarding":false,"postSubscribeMembershipUpsellShownAt":0,"languageCode":"en-us","type":"User"}},"Collection":{"23738d481ce8":{"id":"23738d481ce8","name":"Dart","slug":"dartlang","tags":["MOBILE APP DEVELOPMENT","WEB DEVELOPMENT","DART","PROGRAMMING LANGUAGES","SOFTWARE DEVELOPMENT"],"creatorId":"a6d788faa5e5","description":"Dart is an approachable, portable, and productive language for high-quality apps on any platform. Learn more at https://dart.dev.","shortDescription":"Dart is an approachable, portable, and productive language…","image":{"imageId":"1*uWy1Ajpd0oTUQBO9WBHoQg@2x.png","filter":"","backgroundSize":"","originalWidth":1001,"originalHeight":1001,"strategy":"resample","height":0,"width":0},"metadata":{"followerCount":14031,"activeAt":1762974121956},"virtuals":{"permissions":{"canPublish":true,"canPublishAll":true,"canRepublish":true,"canRemove":true,"canManageAll":true,"canSubmit":true,"canEditPosts":true,"canAddWriters":true,"canViewStats":true,"canSendNewsletter":true,"canViewLockedPosts":true,"canViewCloaked":true,"canEditOwnPosts":true,"canBeAssignedAuthor":true,"canEnrollInHightower":false,"canLockPostsForMediumMembers":false,"canLockOwnPostsForMediumMembers":false,"canViewNewsletterV2Stats":true,"canCreateNewsletterV3":true},"isSubscribed":true,"isEnrolledInHightower":false,"isEligibleForHightower":false,"isSubscribedToCollectionEmails":false,"isMuted":false,"canToggleEmail":false,"isWriter":false},"logo":{"imageId":"1*NRb7RFVWJQFzY47j3v4U7Q.png","filter":"","backgroundSize":"","originalWidth":400,"originalHeight":154,"strategy":"resample","height":0,"width":0},"twitterUsername":"dart_lang","publicEmail":"medium@dartlang.org","domain":"blog.dart.dev","sections":[{"type":2,"collectionHeaderMetadata":{"title":"Dart","description":"An approachable, portable, and productive language for high-quality apps on any platform","backgroundImage":{},"logoImage":{"id":"1*knHF_qpxdtS8h0Z8EeqowA@2x.png","originalWidth":1080,"originalHeight":1080,"alt":"Dart"},"alignment":2,"layout":5}},{"type":1,"postListMetadata":{"source":1,"layout":4,"number":7,"postIds":[]}},{"type":1,"postListMetadata":{"source":1,"layout":5,"number":15,"postIds":[]}}],"tintColor":"#FF042B59","lightText":true,"favicon":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"colorPalette":{"defaultBackgroundSpectrum":{"colorPoints":[{"color":"#FF6588BA","point":0},{"color":"#FF607EAB","point":0.1},{"color":"#FF59759C","point":0.2},{"color":"#FF536B8E","point":0.3},{"color":"#FF4C617F","point":0.4},{"color":"#FF445670","point":0.5},{"color":"#FF3D4B61","point":0.6},{"color":"#FF344052","point":0.7},{"color":"#FF2B3442","point":0.8},{"color":"#FF212832","point":0.9},{"color":"#FF161A22","point":1}],"backgroundColor":"#FFFFFFFF"},"tintBackgroundSpectrum":{"colorPoints":[{"color":"#FF042B59","point":0},{"color":"#FF294871","point":0.1},{"color":"#FF456087","point":0.2},{"color":"#FF5F779B","point":0.3},{"color":"#FF788DAD","point":0.4},{"color":"#FF8FA2BF","point":0.5},{"color":"#FFA5B6CF","point":0.6},{"color":"#FFBBC9DF","point":0.7},{"color":"#FFD1DCEE","point":0.8},{"color":"#FFE6EEFC","point":0.9},{"color":"#FFFBFFFF","point":1}],"backgroundColor":"#FF042B59"},"highlightSpectrum":{"colorPoints":[{"color":"#FFECF3FF","point":0},{"color":"#FFE9F2FF","point":0.1},{"color":"#FFE5F0FF","point":0.2},{"color":"#FFE2EFFF","point":0.3},{"color":"#FFDEEDFF","point":0.4},{"color":"#FFDBEBFF","point":0.5},{"color":"#FFD7EAFF","point":0.6},{"color":"#FFD3E8FF","point":0.7},{"color":"#FFCFE6FF","point":0.8},{"color":"#FFCBE5FF","point":0.9},{"color":"#FFC8E3FF","point":1}],"backgroundColor":"#FFFFFFFF"},"darkBackgroundSpectrum":{"colorPoints":[{"color":"#FF7DA0D3","point":0},{"color":"#FF89A9D8","point":0.1},{"color":"#FF94B1DC","point":0.2},{"color":"#FFA0B9E0","point":0.3},{"color":"#FFABC1E3","point":0.4},{"color":"#FFB6C9E7","point":0.5},{"color":"#FFC0D1EB","point":0.6},{"color":"#FFCBD8EF","point":0.7},{"color":"#FFD5E0F2","point":0.8},{"color":"#FFE0E7F6","point":0.9},{"color":"#FFEAEFFA","point":1}],"backgroundColor":"#FF000000"}},"navItems":[{"type":1,"title":"Announcements","tagSlug":"announcements","url":"https://blog.dart.dev/tagged/announcements","source":"tagSlug"},{"type":5,"title":"Archive","url":"https://blog.dart.dev/archive"},{"type":3,"title":"dart.dev","url":"https://dart.dev"}],"colorBehavior":2,"collectionFeatures":[25],"ampLogo":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"header":{"title":"Dart","description":"An approachable, portable, and productive language for high-quality apps on any platform","backgroundImage":{},"logoImage":{"id":"1*knHF_qpxdtS8h0Z8EeqowA@2x.png","originalWidth":1080,"originalHeight":1080,"alt":"Dart"},"alignment":2,"layout":5},"subscriberCount":14031,"tagline":"Dart is a client-optimized language for fast apps on any platform.","isOptedIntoAurora":false,"isCurationAllowedByDefault":false,"polarisCoverImage":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"ptsQualifiedAt":1616092887098,"type":"Collection"}},"Social":{"ae996dbdd76e":{"userId":"8b6a7f6f197d","targetUserId":"ae996dbdd76e","type":"Social"}},"SocialStats":{"ae996dbdd76e":{"userId":"ae996dbdd76e","usersFollowedCount":2,"usersFollowedByCount":436,"type":"SocialStats"}}}},"v":3,"b":"20260130-1012-root"}