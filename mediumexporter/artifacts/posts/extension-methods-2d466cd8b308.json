{"success":true,"payload":{"value":{"id":"2d466cd8b308","versionId":"76d63c701036","creatorId":"c8676a6d3189","homeCollectionId":"23738d481ce8","title":"Dart extension method fundamentals","detectedLanguage":"en","latestVersion":"76d63c701036","latestPublishedVersion":"76d63c701036","hasUnpublishedEdits":false,"latestRev":1293,"createdAt":1570439249782,"updatedAt":1639319072179,"acceptedAt":0,"firstPublishedAt":1572971622147,"latestPublishedAt":1576067448394,"vote":false,"experimentalCss":"","displayAuthor":"","content":{"subtitle":"Read about the design considerations behind extension methods, a new feature landing in a future Dart SDK release","bodyModel":{"paragraphs":[{"name":"8f19","type":3,"text":"Dart Extension Methods Fundamentals","markups":[]},{"name":"186a","type":4,"text":"","markups":[],"layout":1,"metadata":{"id":"1*D57vLbx-SwCUSnLXA9zHRQ.png","originalWidth":903,"originalHeight":482,"isFeatured":true}},{"name":"1cc6","type":1,"text":"In a future release, the Dart language is adding a new feature, extension methods, which allows you to (pretend to) add new members to existing types. An extension method can be invoked just like a normal method, o.extensionMethod(42), even though it really is just a static function.","markups":[{"type":10,"start":213,"end":234},{"type":2,"start":64,"end":81}]},{"name":"2dd9","type":1,"text":"Why are we adding extension methods? What are they good for? How do you use them? And why do I call them “extension methods” when you can add other members too? (The last one is easy: I personally think of them as extension members, but “extension methods” was the working title, and it’s what the similar feature is called in other languages, so in good Dart tradition, we went for the familiar and unsurprising name. I won’t be needing extension getters, setters or operators here, but you can totally add a % operator to String if you want to, no matter what we call the feature.)","markups":[{"type":10,"start":510,"end":511},{"type":10,"start":524,"end":530},{"type":2,"start":116,"end":123},{"type":2,"start":224,"end":231}]},{"name":"7313","type":1,"text":"Since I’m one of the people who designed the feature, I’ll opportunistically answer all these questions before anyone else has a chance. (And, because I released this article before we finished the feature, I’ve even gotten to edit out the things that are no longer true!)","markups":[]},{"name":"6d1d","type":1,"text":"But first, a detour!","markups":[]},{"name":"d34e","type":3,"text":"What I Would Have Done Before Extension Methods","markups":[]},{"name":"69ee","type":1,"text":"Assume, purely hypothetically, that I think the catchError function on Future is awful and should be replaced by something newer, shinier and better. Say, because it takes aFunction as argument instead of a proper function type, which it does for perfectly reasonable historical reasons, and that means you won’t get any static type checking. That is bad, and the method should feel bad.","markups":[{"type":10,"start":48,"end":58},{"type":10,"start":71,"end":77},{"type":10,"start":173,"end":181},{"type":3,"start":48,"end":58,"href":"https://api.dartlang.org/stable/2.5.0/dart-async/Future/catchError.html","title":"","rel":"","anchorType":0},{"type":3,"start":71,"end":77,"href":"https://api.dartlang.org/stable/2.5.0/dart-async/Future-class.html","title":"","rel":"","anchorType":0},{"type":3,"start":173,"end":181,"href":"https://api.dartlang.org/stable/2.5.0/dart-core/Function-class.html","title":"","rel":"","anchorType":0},{"type":2,"start":268,"end":278}]},{"name":"6aed","type":1,"text":"Obviously I can’t remove the function, that would break, like, every serious Dart program ever.","markups":[{"type":2,"start":90,"end":94}]},{"name":"8318","type":1,"text":"Then I’d want to at least add a new method to Future<T> so that users can use that one instead, say one like:","markups":[{"type":10,"start":46,"end":55}]},{"name":"9ebf","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"ac8e3c2944d7498df333d648eb83fd92","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"44db","type":1,"text":"which you can call as:","markups":[]},{"name":"1ed3","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"6fb6ffc04790bb7fa325dc0d1ccb599d","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"a616","type":1,"text":"Sadly, I can’t just add that to the Future class. If I do that, I also add it to the Future interface, and any other class implementing that interface will then be incomplete and will no longer compile. At some point we counted 76 classes implementing Future. That was a while ago, and we’ve stopped counting. We still can't break everybody, so that option is also not on the table.","markups":[{"type":10,"start":36,"end":42},{"type":10,"start":85,"end":91},{"type":10,"start":252,"end":258}]},{"name":"31a0","type":1,"text":"Well, then I’ll use a static helper function:","markups":[]},{"name":"e74f","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"83d27b15c8cc3571a182ff54519c2d9f","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"abc7","type":1,"text":"which you can call as:","markups":[]},{"name":"571e","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"761f39a73ad7c35d7e493ec885defe61","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"e5a7","type":1,"text":"Almost as sadly, that simply doesn’t read well. We like using .-based method chaining because it allows us to read from left to right: “Do this, then do that, then do something more”. Using the static helper function forces us to read it as: “Do that to the following: Do this. After that, do something more” … say what? It just doesn't have the same flow, the same schwung. It's darn nigh unreadable in practice.","markups":[{"type":10,"start":62,"end":63},{"type":2,"start":51,"end":55},{"type":2,"start":351,"end":355},{"type":2,"start":366,"end":373}]},{"name":"15c9","type":1,"text":"OK then, I’m undeterred in my quest, so instead of improving the Future class, I'll introduce a new and improved interface and give users a way to wrap the old interface:","markups":[{"type":10,"start":65,"end":71}]},{"name":"4338","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"17cc7f58a241152d9eb13179c4346b3a","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"1f97","type":1,"text":"which you can use as:","markups":[]},{"name":"baaf","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"d5bbc43d94a9674ee0b7f39df02e41d5","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"7273","type":1,"text":"I’d probably even let MyFuture implement Future and forward all the Future members to the _wrappee future, and then also let all the methods return a MyFuture wrapper again, so I can keep going.","markups":[{"type":10,"start":22,"end":30},{"type":10,"start":41,"end":47},{"type":10,"start":68,"end":74},{"type":10,"start":90,"end":98},{"type":10,"start":150,"end":158}]},{"name":"710f","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"54e8a2aff584549c21f950a6f66a158a","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"0199","type":1,"text":"Nice and smooth, if I do say so myself!","markups":[]},{"name":"b94f","type":1,"text":"This was pretty much as good as it got, back before extension methods … which meant manually adding the wrapper and taking the performance hit from the extra wrapper objects and intermediate forwarding functions.","markups":[]},{"name":"ae66","type":3,"text":"What I Will Do With Extension Methods","markups":[]},{"name":"94f7","type":1,"text":"Once we’re out of the dark no-extension ages, I can use extension methods to get what I really, really want. I’ll write:","markups":[]},{"name":"e977","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"f4b16ef1cf90ab30709c87b401136bc7","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"9d92","type":1,"text":"and then you can call it as:","markups":[]},{"name":"3c73","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"366a3bf4f049bad6a8f80998181eaf91","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"4684","type":1,"text":"and that is all. Mission accomplished in five lines!","markups":[]},{"name":"f1d0","type":1,"text":"“But how does it work?”, you might ask. It works very well, thank you.","markups":[{"type":2,"start":17,"end":21}]},{"name":"e02e","type":1,"text":"In truth, it behaves almost exactly the same way as the wrapper class, even though it really is just a static helper function. You can even write MyFuture(eventualInteger).onError(...) explicitly, as if the extension was a wrapper class. It isn't, but it looks and acts almost as if it was. And you can omit the explicit wrapping and have it implicitly applied when the types are right.","markups":[{"type":10,"start":146,"end":184},{"type":2,"start":10,"end":69},{"type":2,"start":270,"end":276},{"type":2,"start":342,"end":352}]},{"name":"b3f7","type":3,"text":"It’s (not) a Wrapper Class","markups":[]},{"name":"ca8d","type":1,"text":"The design of the extension declaration is deliberately made so that it looks like a class or mixin declaration, and it acts just as if it was a wrapper class with a hidden _wrappee. You can even have static members in the declaration, and they work just like static members on a class or mixin declaration.","markups":[{"type":10,"start":18,"end":27},{"type":10,"start":85,"end":90},{"type":10,"start":94,"end":99},{"type":10,"start":173,"end":181},{"type":10,"start":280,"end":285},{"type":10,"start":289,"end":294}]},{"name":"dc92","type":1,"text":"There is one improvement over the wrapper class: You can write this inside instance members to refer to the _wrappee instead of the wrapper object.","markups":[{"type":10,"start":63,"end":67},{"type":10,"start":108,"end":116},{"type":2,"start":13,"end":24}]},{"name":"757a","type":1,"text":"Changing the meaning of this was not just an improvement. These are static extension methods, and as I said earlier, they are really just a more convenient way to call static functions. That means that there is no wrapper object. It never existed, we just pretended that it did, but that means that we can't let this refer to the non-existing object.","markups":[{"type":10,"start":24,"end":28},{"type":10,"start":312,"end":316},{"type":2,"start":68,"end":74},{"type":2,"start":222,"end":228}]},{"name":"93a9","type":1,"text":"We also can't allow you to use MyFuture(eventualInteger) as a value, so if you try to do var myFuture = MyFuture(eventualInteger), we won't allow it. The only way to use MyFuture(eventualInteger) is as the target of an extension member invocation.","markups":[{"type":10,"start":31,"end":56},{"type":10,"start":89,"end":129},{"type":10,"start":170,"end":195}]},{"name":"e454","type":8,"text":"MyFuture(eventualInteger).onError(...); // GOOD: Use to call method.\nvar x = MyFuture(eventualInteger); // BAD: Use as stand-alone value.","markups":[]},{"name":"0e9e","type":1,"text":"It’s the same as how you can use super to call methods, but not for its value. Or just like a library prefix. All you can do is access a member; you cannot treat it as a value because it has no value, and there is no value for it to have.","markups":[{"type":10,"start":33,"end":38}]},{"name":"e19b","type":1,"text":"Because there is no object, you can’t declare instance fields in an extension declaration. You can declare getters and setters though, and perhaps even back them by an Expando. An extension also cannot declare any constructors since nothing is being constructed; it just pretends to have a constructor taking the wrappee object.","markups":[{"type":10,"start":68,"end":77},{"type":10,"start":168,"end":175},{"type":3,"start":168,"end":175,"href":"https://api.dartlang.org/stable/2.5.1/dart-core/Expando-class.html","title":"","rel":"","anchorType":0},{"type":2,"start":46,"end":61},{"type":2,"start":95,"end":98}]},{"name":"cf25","type":3,"text":"It Does (not) Extend the Type","markups":[]},{"name":"ff46","type":1,"text":"If you had to write the MyFuture(...) wrapping every time you used an extension member, then it wouldn't be much of an improvement. We could probably just write the wrapper classes directly and spend some compiler engineer hours ensuring that we optimize away the intermediate object.","markups":[{"type":10,"start":24,"end":37}]},{"name":"6ddc","type":1,"text":"I said above that you can write eventualInteger.onError(...). This works because we implicitly wrap expressions based on their static type and the name of the member they call. We automatically wrap expr.method() as Ext(expr).method() when all of the following are true:","markups":[{"type":10,"start":32,"end":60},{"type":10,"start":199,"end":212},{"type":10,"start":216,"end":234},{"type":2,"start":84,"end":99}]},{"name":"8fa3","type":9,"text":"The static type of expr does not have a member with (base-)name method (the interface always wins).","markups":[{"type":10,"start":19,"end":23},{"type":10,"start":64,"end":70}]},{"name":"0ca3","type":9,"text":"The extension Ext is imported or declared in the current library scope (the extension is accessible).","markups":[{"type":10,"start":14,"end":17},{"type":2,"start":89,"end":99}]},{"name":"0056","type":9,"text":"The extension declares a member with base-name method, and the static type of expr is a subtype of the on type of the Ext declaration (the extension is applicable).","markups":[{"type":10,"start":47,"end":53},{"type":10,"start":78,"end":82},{"type":10,"start":103,"end":105},{"type":10,"start":118,"end":121},{"type":2,"start":55,"end":59},{"type":2,"start":152,"end":162}]},{"name":"119b","type":1,"text":"If there is more than one accessible and applicable extension for a member invocation, there are rules about which one will win the conflict. In some cases, there’s no way to pick a winner, and then it’s just a compile-time error. These rules depend only on the extension declaration’s on type, not on member declaration. (Dart does not have “overloading” — multiple methods with the same name and different signatures, which you choose between based on the argument structure or types — and extension methods do not provide a back-door to get overloading.)","markups":[{"type":10,"start":286,"end":288}]},{"name":"85f6","type":3,"text":"It Is All Static","markups":[]},{"name":"020c","type":1,"text":"I said “static extension methods” above, and I did so for a reason!","markups":[{"type":2,"start":9,"end":14}]},{"name":"6d12","type":1,"text":"Dart is statically typed. The compiler knows the type of every expression at compile-time, so if you write target.member(42), and member is an extension member, then the compiler needs to figure out which extension to implicitly wrap target with, in order to find the type of the entire member invocation.","markups":[{"type":10,"start":107,"end":124},{"type":10,"start":130,"end":136},{"type":10,"start":234,"end":240},{"type":2,"start":199,"end":204}]},{"name":"300c","type":1,"text":"If implicit extension wrapping has to happen between finding the type of the target expression and finding the type of the member invocation, it seems obvious that “extension inference” has to happen during the increasingly more inaccurately named “type inference” phase. That’s the phase which is mostly known for filling in missing generics.","markups":[{"type":2,"start":45,"end":52},{"type":2,"start":95,"end":98}]},{"name":"3e0a","type":1,"text":"I did write eventualInteger.onError((FormatException e, s) {...}), even though both the MyFuture extension and the onError method are generic. While doing type inference, the Dart compiler both selects the extension and infers missing type arguments. Here it first decides to use the MyFuture extension, then inserts the implicit wrapper, and finally performs type inference for the extension application MyFuture(eventualInteger).onError((FormatException e, s) {...}) in exactly the same way as it would for a corresponding wrapper class:","markups":[{"type":10,"start":12,"end":65},{"type":10,"start":88,"end":96},{"type":10,"start":115,"end":122},{"type":10,"start":284,"end":292},{"type":10,"start":405,"end":468},{"type":2,"start":472,"end":492}]},{"name":"d2a0","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"23c1d0ef98ac0e46adb0a20e492b1f0a","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"e58a","type":1,"text":"In this case, the type inference would infer the following extension application and complete types for the invocation:","markups":[]},{"name":"b9ad","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"6d78ab68999204ae9a6e1355970a1d81","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"6d1f","type":1,"text":"This means that the type arguments to the extension are based on the static type of the wrapped expression. If you have a Future<num> fut = Future<int>.value(42); then fut.onError(...) will bind the T type parameter of MyFuture to num at compile-time, not to int. It's all static, just as for any other inferred type arguments.","markups":[{"type":10,"start":122,"end":162},{"type":10,"start":168,"end":184},{"type":10,"start":199,"end":200},{"type":10,"start":219,"end":227},{"type":10,"start":231,"end":234},{"type":10,"start":259,"end":262},{"type":2,"start":16,"end":106}]},{"name":"8af8","type":1,"text":"That also means that you will never be able to call an extension member on a target typed as dynamic.","markups":[{"type":10,"start":93,"end":100}]},{"name":"ea63","type":3,"text":"Conflict Resolution","markups":[]},{"name":"2dca","type":1,"text":"As stated above, there are rules about which extension wins when there is more than one in scope which applies. Basically, the winner is the extension with an on type closest to the actual type of the expression you are calling a member on, with some caveats and tie-breakers. It usually “just works” for extensions which are written together. Instead of going into those details, I'll tell you what to do when it doesn't just work.","markups":[{"type":10,"start":159,"end":161},{"type":2,"start":414,"end":421}]},{"name":"76f0","type":1,"text":"You might have a problem when two different authors have written conflicting extensions for the same type and member name. Say the extensions Ext1 and Ext2 both define a bubbleSort method that applies to your List object, and either there is no clear winner of the conflict, or the one which wins is not the one you actually want to call (say Ext2 wins and you want to call Ext1.bubbleSort). Then you have to do something.","markups":[{"type":10,"start":142,"end":146},{"type":10,"start":151,"end":155},{"type":10,"start":170,"end":180},{"type":10,"start":209,"end":213},{"type":10,"start":343,"end":347},{"type":10,"start":374,"end":389},{"type":2,"start":412,"end":421}]},{"name":"4565","type":1,"text":"The easiest solution is to use an explicit extension application: Ext1(list).bubbleSort(). This avoids the automatic resolution and just picks the one that you want. If you only have a few conflicts, then that's both easy and readable.","markups":[{"type":10,"start":66,"end":89}]},{"name":"f16a","type":1,"text":"However, if you have three hundred conflicts in the same file, then you might want to avoid the extra typing. It’s hard to change whether an extension is applicable to an invocation, but you can change whether it’s accessible.","markups":[{"type":2,"start":154,"end":164},{"type":2,"start":215,"end":225}]},{"name":"31d2","type":1,"text":"You do that by hiding the conflicting extension (or extensions, if you are really unlucky) where you import it: import \"ext2lib.dart\" hide Ext2;. Doing so will prevent the Ext2 extension from being imported into the current library scope, which makes it not accessible. Obviously, so will not importing ext2lib.dart at all, but unless the extension is the only thing you use from that library, that’s not practical.","markups":[{"type":10,"start":112,"end":144},{"type":10,"start":172,"end":176},{"type":10,"start":303,"end":315},{"type":2,"start":15,"end":21},{"type":2,"start":61,"end":63}]},{"name":"04cd","type":1,"text":"(Edited Dec. 11th) Here I used to say that you could import one of the conflicting extensions with a prefix and that then it would not be available for implicit use. Turns out that some people declare extension methods in the same library as the class they extend, and it is really annoying if that library doesn’t work when imported with a prefix. So we fixed that. Extensions imported with a prefix do work implicitly as well. If you really need to use two conflicting extension in the same library, you will have to use explicit extension application everywhere there is a conflict. We may consider adding a different way to disable implicit extensions in the future, at least if conflicting extensions turn out to be a recurring issue.","markups":[{"type":2,"start":101,"end":107},{"type":2,"start":401,"end":403}]},{"name":"bdef","type":3,"text":"Summary","markups":[]},{"name":"63a5","type":1,"text":"Dart will get extension methods in an upcoming release — a pretty way to call static functions.","markups":[{"type":2,"start":14,"end":32},{"type":2,"start":55,"end":57}]},{"name":"7e22","type":1,"text":"You can define extension members for instance methods, operators, setters and getters, but not fields.","markups":[{"type":1,"start":37,"end":53},{"type":1,"start":55,"end":64},{"type":1,"start":66,"end":73},{"type":1,"start":78,"end":85},{"type":1,"start":91,"end":101}]},{"name":"dd37","type":1,"text":"You can invoke extension methods either explicitly or — when there’s no conflict with an interface member or another extension — implicitly:","markups":[]},{"name":"2ec5","type":8,"text":"Ext1(list).bubbleSort() // Explicit, like it's a wrapper class.\nlist.bubbleSort()       // Implicitly, like it extends the type.","markups":[{"type":10,"start":0,"end":128}]},{"name":"6941","type":1,"text":"Implicit invocations work the same as explicit invocations, but they first infer which extension is being applied. If extension inference fails due to conflicting extensions, then you can do any one of the following:","markups":[{"type":2,"start":75,"end":80}]},{"name":"7c28","type":9,"text":"Apply the extension explicitly.","markups":[]},{"name":"a77c","type":9,"text":"Don’t import the conflicting extension at all (remove the import or hide the extension).","markups":[]},{"name":"c045","type":9,"text":"(Edited Dec 11th): And that is it (for now).","markups":[]},{"name":"7001","type":1,"text":"Extensions are static. Everything about them is decided based on static types.","markups":[{"type":2,"start":15,"end":21}]},{"name":"c6eb","type":1,"text":"Enjoy responsibly!","markups":[]}],"sections":[{"name":"c085","startIndex":0}]},"postDisplay":{"coverless":true}},"virtuals":{"statusForCollection":"APPROVED","allowNotes":true,"previewImage":{"imageId":"1*D57vLbx-SwCUSnLXA9zHRQ.png","filter":"","backgroundSize":"","originalWidth":903,"originalHeight":482,"strategy":"resample","height":0,"width":0},"wordCount":2145,"imageCount":1,"readingTime":8.294339622641509,"subtitle":"Read about the design considerations behind extension methods, a new feature landing in a future Dart SDK release","userPostRelation":{"userId":"8b6a7f6f197d","postId":"2d466cd8b308","readAt":0,"readLaterAddedAt":0,"votedAt":0,"collaboratorAddedAt":0,"notesAddedAt":0,"subscribedAt":0,"lastReadSectionName":"","lastReadVersionId":"","lastReadAt":0,"lastReadParagraphName":"","lastReadPercentage":0,"viewedAt":1731401866207,"presentedCountInResponseManagement":0,"clapCount":0,"seriesUpdateNotifsOptedInAt":0,"queuedAt":0,"seriesFirstViewedAt":0,"presentedCountInStream":2,"seriesLastViewedAt":0,"audioProgressSec":0},"publishedInCount":1,"usersBySocialRecommends":[],"noIndex":false,"recommends":134,"isBookmarked":false,"tags":[{"slug":"dartlang","name":"Dartlang","postCount":921,"metadata":{"postCount":921,"coverImage":{"id":"1*HNqQFQ2hdhAgjew1pIMqXA.png","originalWidth":2752,"originalHeight":1536,"isFeatured":true}},"type":"Tag"},{"slug":"programming-languages","name":"Programming Languages","postCount":14860,"metadata":{"postCount":14860,"coverImage":{"id":"1*sD09-ccQCGBvaNKvzpbTbw.png","originalWidth":1690,"originalHeight":964,"isFeatured":true}},"type":"Tag"},{"slug":"extension-method","name":"Extension Method","postCount":129,"metadata":{"postCount":129,"coverImage":{"id":"1*3zrioJ_WFOaU-Ngbm763tA@2x.jpeg","originalWidth":3024,"originalHeight":4032,"backgroundSize":"","filter":"","isFeatured":false,"externalSrc":"","focusPercentX":-1,"focusPercentY":-1,"alt":"","repairedAt":0,"unsplashPhotoId":""}},"type":"Tag"}],"socialRecommendsCount":0,"responsesCreatedCount":3,"links":{"entries":[{"url":"https://api.dartlang.org/stable/2.5.0/dart-async/Future/catchError.html","alts":[],"httpStatus":200},{"url":"https://api.dartlang.org/stable/2.5.0/dart-core/Function-class.html","alts":[],"httpStatus":200},{"url":"https://api.dartlang.org/stable/2.5.1/dart-core/Expando-class.html","alts":[],"httpStatus":200},{"url":"https://api.dartlang.org/stable/2.5.0/dart-async/Future-class.html","alts":[],"httpStatus":200}],"version":"0.3","generatedAt":1576067449191},"isLockedPreviewOnly":false,"metaDescription":"","totalClapCount":1263,"sectionCount":1,"readingList":0,"topics":[{"topicId":"decb52b64abf","slug":"programming","createdAt":1493934116328,"deletedAt":0,"image":{"id":"1*iPa136b1cGEO7lvoXg6uHQ@2x.jpeg","originalWidth":6016,"originalHeight":4016},"name":"Programming","description":"The good, the bad, the buggy.","relatedTopics":[],"visibility":1,"relatedTags":[],"relatedTopicIds":[],"seoTitle":"Programming News and Articles — Medium","type":"Topic"}]},"coverless":true,"slug":"dart-extension-method-fundamentals","translationSourcePostId":"","translationSourceCreatorId":"","isApprovedTranslation":false,"inResponseToPostId":"","inResponseToRemovedAt":0,"isTitleSynthesized":false,"allowResponses":true,"importedUrl":"","importedPublishedAt":0,"visibility":0,"uniqueSlug":"extension-methods-2d466cd8b308","previewContent":{"bodyModel":{"paragraphs":[{"name":"previewImage","type":4,"text":"","layout":10,"metadata":{"id":"1*D57vLbx-SwCUSnLXA9zHRQ.png","originalWidth":903,"originalHeight":482,"isFeatured":true}},{"name":"previewTitle","type":3,"text":"Dart extension method fundamentals","alignment":1},{"name":"previewSubtitle","type":13,"text":"Read about the design considerations behind extension methods, a…","alignment":1}],"sections":[{"startIndex":0}]},"isFullContent":false,"subtitle":"Read about the design considerations behind extension methods, a new feature landing in a future Dart SDK release"},"license":0,"inResponseToMediaResourceId":"","canonicalUrl":"https://blog.dart.dev/extension-methods-2d466cd8b308","approvedHomeCollectionId":"23738d481ce8","isNewsletter":false,"newsletterId":"","webCanonicalUrl":"https://blog.dart.dev/extension-methods-2d466cd8b308","mediumUrl":"https://blog.dart.dev/extension-methods-2d466cd8b308","migrationId":"","notifyFollowers":true,"notifyTwitter":false,"notifyFacebook":false,"responseHiddenOnParentPostAt":0,"isSeries":false,"isSubscriptionLocked":false,"seriesLastAppendedAt":0,"audioVersionDurationSec":0,"sequenceId":"","isEligibleForRevenue":false,"isBlockedFromHightower":false,"deletedAt":0,"lockedPostSource":0,"hightowerMinimumGuaranteeStartsAt":0,"hightowerMinimumGuaranteeEndsAt":0,"featureLockRequestAcceptedAt":0,"mongerRequestType":1,"layerCake":0,"socialTitle":"","socialDek":"","editorialPreviewTitle":"","editorialPreviewDek":"","curationEligibleAt":0,"isProxyPost":false,"proxyPostFaviconUrl":"","proxyPostProviderName":"","proxyPostType":0,"isSuspended":false,"isLimitedState":false,"seoTitle":"","previewContent2":{"bodyModel":{"paragraphs":[{"name":"8f19","type":3,"text":"Dart Extension Methods Fundamentals","markups":[]},{"name":"186a","type":4,"text":"","markups":[],"layout":1,"metadata":{"id":"1*D57vLbx-SwCUSnLXA9zHRQ.png","originalWidth":903,"originalHeight":482,"isFeatured":true}},{"name":"1cc6","type":1,"text":"In a future release, the Dart language is adding a new feature, extension methods, which allows you to (pretend to) add new members to existing types. An extension method can be invoked just like a normal method, o.extensionMethod(42), even though it really is just a static function.","markups":[{"type":10,"start":213,"end":234},{"type":2,"start":64,"end":81}]},{"name":"2dd9","type":1,"text":"Why are we…","markups":[{"type":10,"start":510,"end":511},{"type":10,"start":524,"end":530},{"type":2,"start":116,"end":123},{"type":2,"start":224,"end":231}]}],"sections":[{"name":"c085","startIndex":0}]},"isFullContent":false,"subtitle":"Read about the design considerations behind extension methods, a new feature landing in a future Dart SDK release"},"cardType":0,"isDistributionAlertDismissed":false,"isShortform":false,"shortformType":0,"responsesLocked":false,"isLockedResponse":false,"isPublishToEmail":false,"responseDistribution":0,"isMarkedPaywallOnly":false,"type":"Post"},"mentionedUsers":[],"collaborators":[{"user":{"userId":"fe67f3a27347","name":"Kathy Walrath","username":"kathyw_39223","createdAt":1479149074481,"imageId":"0*OWxJ0V46ratF_z-r.","backgroundImageId":"","bio":"I write Dart docs! https://dart.dev","twitterScreenName":"","allowNotes":1,"mediumMemberAt":0,"isWriterProgramEnrolled":true,"isSuspended":false,"isMembershipTrialEligible":true,"facebookDisplayName":"","optInToIceland":true,"userFlags":[2],"hasCompletedProfile":false,"userDismissableFlags":[1,2,5,8,12],"hasSeenIcelandOnboarding":false,"postSubscribeMembershipUpsellShownAt":0,"languageCode":"en-us","type":"User"},"state":"visible"},{"user":{"userId":"a6d788faa5e5","name":"Michael Thomsen","username":"mit.mit","createdAt":1481367237471,"imageId":"0*Y_CFLc1qadgr3tPK.","backgroundImageId":"","bio":"Product Manager working on Dart and Flutter. Helping developers is my passion!","twitterScreenName":"","allowNotes":1,"mediumMemberAt":1752847030513,"isWriterProgramEnrolled":true,"isSuspended":false,"isMembershipTrialEligible":true,"facebookDisplayName":"","optInToIceland":true,"hasCompletedProfile":false,"userDismissableFlags":[1,2,5,8,12,17,18,21,30,32,33,53,58,59,61],"hasSeenIcelandOnboarding":true,"postSubscribeMembershipUpsellShownAt":0,"languageCode":"da","type":"User"},"state":"visible"},{"user":{"userId":"696ae61bc6e2","name":"Filip Hracek","username":"filiph","createdAt":1440499743108,"imageId":"1*dZx7Dxmr4VXmjc5U8yDf3w.jpeg","backgroundImageId":"","bio":"I’m a pro­gram­ming buff with formal train­ing in jour­nal­ism. I build games, teach pro­gram­ming, explain things, and create silly soft­ware experiments.","twitterScreenName":"","allowNotes":1,"mediumMemberAt":0,"isWriterProgramEnrolled":true,"isSuspended":false,"isMembershipTrialEligible":true,"facebookDisplayName":"","optInToIceland":true,"subdomainCreatedAt":1619463171044,"hasCompletedProfile":false,"userDismissableFlags":[1,2,3,8,12,21,29,33,53,58],"hasSeenIcelandOnboarding":false,"postSubscribeMembershipUpsellShownAt":0,"languageCode":"en-us","type":"User"},"state":"visible"}],"hideMeter":false,"shareKey":"e505d33f9785cc512a7af1a9ab0bf67d","collectionUserRelations":[{"collectionId":"23738d481ce8","userId":"8b6a7f6f197d","role":"ADMIN"},{"collectionId":"4da7dfd21a33","userId":"8b6a7f6f197d","role":"WRITER"},{"collectionId":"24d8f4fa8912","userId":"8b6a7f6f197d","role":"WRITER"}],"mode":"canEdit","references":{"User":{"c8676a6d3189":{"userId":"c8676a6d3189","name":"Lasse Reichstein Holst Nielsen","username":"lrhn","createdAt":1570439137063,"imageId":"0*vy0c2Frcvi17OShL","backgroundImageId":"","bio":"Lasse is a programming language designer and software engineer at Google, co-leading the Dart language design and platform library group. @lrhn on Github.","twitterScreenName":"","socialStats":{"userId":"c8676a6d3189","usersFollowedCount":1,"usersFollowedByCount":138,"type":"SocialStats"},"social":{"userId":"8b6a7f6f197d","targetUserId":"c8676a6d3189","type":"Social"},"allowNotes":1,"mediumMemberAt":0,"isWriterProgramEnrolled":true,"isSuspended":false,"isMembershipTrialEligible":true,"facebookDisplayName":"","optInToIceland":true,"hasCompletedProfile":false,"hasSeenIcelandOnboarding":false,"postSubscribeMembershipUpsellShownAt":0,"languageCode":"en-us","type":"User"}},"Collection":{"23738d481ce8":{"id":"23738d481ce8","name":"Dart","slug":"dartlang","tags":["MOBILE APP DEVELOPMENT","WEB DEVELOPMENT","DART","PROGRAMMING LANGUAGES","SOFTWARE DEVELOPMENT"],"creatorId":"a6d788faa5e5","description":"Dart is an approachable, portable, and productive language for high-quality apps on any platform. Learn more at https://dart.dev.","shortDescription":"Dart is an approachable, portable, and productive language…","image":{"imageId":"1*uWy1Ajpd0oTUQBO9WBHoQg@2x.png","filter":"","backgroundSize":"","originalWidth":1001,"originalHeight":1001,"strategy":"resample","height":0,"width":0},"metadata":{"followerCount":14031,"activeAt":1762974121956},"virtuals":{"permissions":{"canPublish":true,"canPublishAll":true,"canRepublish":true,"canRemove":true,"canManageAll":true,"canSubmit":true,"canEditPosts":true,"canAddWriters":true,"canViewStats":true,"canSendNewsletter":true,"canViewLockedPosts":true,"canViewCloaked":true,"canEditOwnPosts":true,"canBeAssignedAuthor":true,"canEnrollInHightower":false,"canLockPostsForMediumMembers":false,"canLockOwnPostsForMediumMembers":false,"canViewNewsletterV2Stats":true,"canCreateNewsletterV3":true},"isSubscribed":true,"isEnrolledInHightower":false,"isEligibleForHightower":false,"isSubscribedToCollectionEmails":false,"isMuted":false,"canToggleEmail":false,"isWriter":false},"logo":{"imageId":"1*NRb7RFVWJQFzY47j3v4U7Q.png","filter":"","backgroundSize":"","originalWidth":400,"originalHeight":154,"strategy":"resample","height":0,"width":0},"twitterUsername":"dart_lang","publicEmail":"medium@dartlang.org","domain":"blog.dart.dev","sections":[{"type":2,"collectionHeaderMetadata":{"title":"Dart","description":"An approachable, portable, and productive language for high-quality apps on any platform","backgroundImage":{},"logoImage":{"id":"1*knHF_qpxdtS8h0Z8EeqowA@2x.png","originalWidth":1080,"originalHeight":1080,"alt":"Dart"},"alignment":2,"layout":5}},{"type":1,"postListMetadata":{"source":1,"layout":4,"number":7,"postIds":[]}},{"type":1,"postListMetadata":{"source":1,"layout":5,"number":15,"postIds":[]}}],"tintColor":"#FF042B59","lightText":true,"favicon":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"colorPalette":{"defaultBackgroundSpectrum":{"colorPoints":[{"color":"#FF6588BA","point":0},{"color":"#FF607EAB","point":0.1},{"color":"#FF59759C","point":0.2},{"color":"#FF536B8E","point":0.3},{"color":"#FF4C617F","point":0.4},{"color":"#FF445670","point":0.5},{"color":"#FF3D4B61","point":0.6},{"color":"#FF344052","point":0.7},{"color":"#FF2B3442","point":0.8},{"color":"#FF212832","point":0.9},{"color":"#FF161A22","point":1}],"backgroundColor":"#FFFFFFFF"},"tintBackgroundSpectrum":{"colorPoints":[{"color":"#FF042B59","point":0},{"color":"#FF294871","point":0.1},{"color":"#FF456087","point":0.2},{"color":"#FF5F779B","point":0.3},{"color":"#FF788DAD","point":0.4},{"color":"#FF8FA2BF","point":0.5},{"color":"#FFA5B6CF","point":0.6},{"color":"#FFBBC9DF","point":0.7},{"color":"#FFD1DCEE","point":0.8},{"color":"#FFE6EEFC","point":0.9},{"color":"#FFFBFFFF","point":1}],"backgroundColor":"#FF042B59"},"highlightSpectrum":{"colorPoints":[{"color":"#FFECF3FF","point":0},{"color":"#FFE9F2FF","point":0.1},{"color":"#FFE5F0FF","point":0.2},{"color":"#FFE2EFFF","point":0.3},{"color":"#FFDEEDFF","point":0.4},{"color":"#FFDBEBFF","point":0.5},{"color":"#FFD7EAFF","point":0.6},{"color":"#FFD3E8FF","point":0.7},{"color":"#FFCFE6FF","point":0.8},{"color":"#FFCBE5FF","point":0.9},{"color":"#FFC8E3FF","point":1}],"backgroundColor":"#FFFFFFFF"},"darkBackgroundSpectrum":{"colorPoints":[{"color":"#FF7DA0D3","point":0},{"color":"#FF89A9D8","point":0.1},{"color":"#FF94B1DC","point":0.2},{"color":"#FFA0B9E0","point":0.3},{"color":"#FFABC1E3","point":0.4},{"color":"#FFB6C9E7","point":0.5},{"color":"#FFC0D1EB","point":0.6},{"color":"#FFCBD8EF","point":0.7},{"color":"#FFD5E0F2","point":0.8},{"color":"#FFE0E7F6","point":0.9},{"color":"#FFEAEFFA","point":1}],"backgroundColor":"#FF000000"}},"navItems":[{"type":1,"title":"Announcements","tagSlug":"announcements","url":"https://blog.dart.dev/tagged/announcements","source":"tagSlug"},{"type":5,"title":"Archive","url":"https://blog.dart.dev/archive"},{"type":3,"title":"dart.dev","url":"https://dart.dev"}],"colorBehavior":2,"collectionFeatures":[25],"ampLogo":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"header":{"title":"Dart","description":"An approachable, portable, and productive language for high-quality apps on any platform","backgroundImage":{},"logoImage":{"id":"1*knHF_qpxdtS8h0Z8EeqowA@2x.png","originalWidth":1080,"originalHeight":1080,"alt":"Dart"},"alignment":2,"layout":5},"subscriberCount":14031,"tagline":"Dart is a client-optimized language for fast apps on any platform.","isOptedIntoAurora":false,"isCurationAllowedByDefault":false,"polarisCoverImage":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"ptsQualifiedAt":1616092887098,"type":"Collection"}},"Social":{"c8676a6d3189":{"userId":"8b6a7f6f197d","targetUserId":"c8676a6d3189","type":"Social"}},"SocialStats":{"c8676a6d3189":{"userId":"c8676a6d3189","usersFollowedCount":1,"usersFollowedByCount":138,"type":"SocialStats"}}}},"v":3,"b":"20260130-1012-root"}