{"success":true,"payload":{"value":{"id":"1cb1829d11a9","versionId":"1ac875f348bc","creatorId":"6d41df764cd","homeCollectionId":"23738d481ce8","title":"Implementing structs by value in Dart FFI","detectedLanguage":"en","latestVersion":"1ac875f348bc","latestPublishedVersion":"1ac875f348bc","hasUnpublishedEdits":false,"latestRev":926,"createdAt":1622706304306,"updatedAt":1641478869553,"acceptedAt":0,"firstPublishedAt":1623179826970,"latestPublishedAt":1623179826970,"vote":false,"experimentalCss":"","displayAuthor":"","content":{"subtitle":"A deep dive into API design and native calling conventions.","bodyModel":{"paragraphs":[{"name":"15d2","type":3,"text":"Implementing structs by value in Dart FFI","markups":[]},{"name":"19fb","type":13,"text":"A deep dive into API design and native calling conventions","markups":[]},{"name":"085f","type":1,"text":"In the Dart 2.12 release, we extended our C-interop feature, Dart FFI, with the ability to pass structs by value. This article talks about what it took to add this feature to the Dart SDK. If you’re interested in low-level language implementation details or in platform conventions for passing structs by value, keep reading.","markups":[{"type":3,"start":7,"end":16,"href":"https://medium.com/dartlang/announcing-dart-2-12-499a6e689c87","title":"","rel":"","anchorType":0},{"type":3,"start":42,"end":70,"href":"https://dart.dev/guides/libraries/c-interop","title":"","rel":"","anchorType":0},{"type":3,"start":91,"end":112,"href":"https://github.com/dart-lang/sdk/issues/36730","title":"","rel":"","anchorType":0}]},{"name":"69de","type":1,"text":"This article talks about both developing the API and figuring out the ABI (Application Binary Interface) for the struct-by-value feature. During the two years we worked on this feature (and other Dart FFI features), we discovered many constraints that required changing the API. The ABI journey was equally interesting, illustrating that you can take multiple approaches to nailing down the details of a hard problem.","markups":[]},{"name":"7f18","type":3,"text":"Pass by value and pass by reference in C/C++","markups":[]},{"name":"c05c","type":1,"text":"Here’s a quick refresher if you don’t write code in C every day. Suppose that we have the following struct and functions in C:","markups":[]},{"name":"f284","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"6e68770c6067afbd626f33493c7c6cd9"}},{"name":"2e02","type":1,"text":"Then, we can use these functions in some simple C code. Let’s say we have a local variable c1:","markups":[{"type":10,"start":91,"end":93}]},{"name":"84be","type":8,"text":"Coord c1 = {10.0, 10.0, nullptr};","markups":[]},{"name":"a05e","type":1,"text":"If we pass c1 to TranslateByValue, then the argument is passed by value, which makes the callee effectively operate on a copy of the struct:","markups":[{"type":10,"start":11,"end":13},{"type":10,"start":17,"end":33}]},{"name":"e5a0","type":8,"text":"Coord c2 = TranslateByValue(c1);","markups":[]},{"name":"4df2","type":1,"text":"This means that c1 stays unchanged.","markups":[{"type":10,"start":16,"end":18}]},{"name":"ad71","type":1,"text":"However, if we pass c1 by reference with a pointer to the memory containing c1, then c1 gets mutated in place:","markups":[{"type":10,"start":20,"end":22},{"type":10,"start":76,"end":78},{"type":10,"start":85,"end":87}]},{"name":"1e6e","type":8,"text":"TranslateByPointer(&c1);","markups":[]},{"name":"fc42","type":1,"text":"c1.x now contains 20.0.","markups":[{"type":10,"start":0,"end":4},{"type":10,"start":18,"end":22}]},{"name":"910d","type":3,"text":"The API design journey","markups":[]},{"name":"1aa6","type":1,"text":"The original Dart FFI prototype already had support for passing pointers to structs. However, we redesigned the API multiple times to accommodate various use cases and constraints.","markups":[{"type":3,"start":22,"end":31,"href":"https://dart-review.googlesource.com/c/sdk/+/80124","title":"","rel":"","anchorType":0}]},{"name":"bca6","type":13,"text":"Initial design","markups":[]},{"name":"f7e1","type":1,"text":"Our initial design enabled allocating structs in memory, passing those pointers to C, and modifying the fields of the structs. With that approach, the Struct class extended the Pointer class:","markups":[{"type":10,"start":151,"end":157},{"type":10,"start":177,"end":184}]},{"name":"f9a6","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"34db590da63bf3819ca3c32d49ffeb78"}},{"name":"0788","type":1,"text":"Dart FFI users wrote the preceding snippet, and Dart FFI internals generated an implementation of sizeOf and getter and setter implementations for x, y, and next.","markups":[{"type":10,"start":98,"end":104},{"type":10,"start":147,"end":148},{"type":10,"start":150,"end":151},{"type":10,"start":157,"end":161}]},{"name":"1078","type":1,"text":"However, two years ago we realized that this design had an issue. By having the Coordinate extend Pointer, we could not distinguish between Coordinate and Coordinate*.","markups":[{"type":10,"start":80,"end":90},{"type":10,"start":98,"end":105},{"type":10,"start":140,"end":150},{"type":10,"start":155,"end":166},{"type":3,"start":40,"end":64,"href":"https://github.com/dart-lang/sdk/issues/35840","title":"","rel":"","anchorType":0}]},{"name":"de11","type":13,"text":"Distinguishing between Coordinate and Coordinate*","markups":[]},{"name":"3ee5","type":1,"text":"We introduced Struct to Dart FFI and made structs extend this class:","markups":[{"type":10,"start":14,"end":20},{"type":3,"start":3,"end":13,"href":"https://dart-review.googlesource.com/c/sdk/+/101291","title":"","rel":"","anchorType":0}]},{"name":"c65a","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"a77f2199817c8f0f7d56b5d70a64325d"}},{"name":"6d46","type":1,"text":"Now a Pointer<Coordinate> in Dart represents a Coordinate* in C, and a Coordinate in Dart represents a Coordinate in C.","markups":[{"type":10,"start":6,"end":25},{"type":10,"start":47,"end":58},{"type":10,"start":71,"end":81},{"type":10,"start":103,"end":113}]},{"name":"e949","type":1,"text":"This meant that the next field had the type Pointer<Coordinate>, which made the @Pointer annotation redundant. So, we got rid of Pointer annotations.","markups":[{"type":10,"start":20,"end":24},{"type":10,"start":44,"end":63},{"type":10,"start":80,"end":88},{"type":3,"start":118,"end":148,"href":"https://dart-review.googlesource.com/c/sdk/+/108415","title":"","rel":"","anchorType":0}]},{"name":"bf6b","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"69f4ff54d9634bd1ceae57af5c676779"}},{"name":"a302","type":1,"text":"Because we now represented pointers to structs as Pointer objects, we started using the allocate factory on Pointer:","markups":[{"type":10,"start":50,"end":57},{"type":10,"start":88,"end":96},{"type":10,"start":108,"end":115}]},{"name":"a9df","type":8,"text":"final c = Pointer<Coordinate>.allocate();","markups":[]},{"name":"fd90","type":1,"text":"To get access to the fields of a Pointer<Coordinate>, we need an object of type Coordinate, because that object has the fields x, y, and next. For this, we had the load method on Pointer already.","markups":[{"type":10,"start":33,"end":52},{"type":10,"start":80,"end":90},{"type":10,"start":127,"end":128},{"type":10,"start":130,"end":131},{"type":10,"start":137,"end":141},{"type":10,"start":164,"end":168},{"type":10,"start":179,"end":186}]},{"name":"379f","type":8,"text":"c.load<Coordinate>().x = 10.0;","markups":[]},{"name":"02dc","type":1,"text":"Of course, having to write <Coordinate> on calling load is verbose. (Having to write a type argument was the same for loading a Dart int out of a Pointer<Uint8>.) The reason we need this type argument on load is to specify to the Dart type system the return type of this method.","markups":[{"type":10,"start":27,"end":39},{"type":10,"start":51,"end":55},{"type":10,"start":133,"end":136},{"type":10,"start":146,"end":160},{"type":10,"start":204,"end":208}]},{"name":"aed9","type":13,"text":"Extension methods to the rescue","markups":[]},{"name":"9f67","type":1,"text":"Dart 2.7 introduced extension methods. With extension methods, we could pattern match on the type argument T in Pointer<T>:","markups":[{"type":10,"start":107,"end":108},{"type":10,"start":112,"end":122},{"type":3,"start":9,"end":19,"href":"https://medium.com/dartlang/dart-2-7-a3710ec54e97","title":"","rel":"","anchorType":0},{"type":3,"start":72,"end":85,"href":"https://dart-review.googlesource.com/c/sdk/+/118992/14/sdk/lib/ffi/ffi.dart","title":"","rel":"","anchorType":0}]},{"name":"3153","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"c9231b9bdecf725c61e3b405cf72785a"}},{"name":"91a0","type":1,"text":"Pattern matching on the type argument enabled us to get rid of the verbosity on call sites:","markups":[{"type":3,"start":52,"end":76,"href":"https://dart-review.googlesource.com/c/sdk/+/118993/16/tests/ffi/structs_test.dart","title":"","rel":"","anchorType":0}]},{"name":"b8b8","type":8,"text":"c.ref.y = 10.0; // ref is pattern matched to be of type Coordinate.","markups":[]},{"name":"7ce4","type":1,"text":"We could also use the extension method pattern matching to make the type argument of Struct<S> redundant, changing the definition of user structs to:","markups":[{"type":10,"start":85,"end":94}]},{"name":"e4e0","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"786de9cbf15369b19f828b793993ba84"}},{"name":"4012","type":1,"text":"Before, the type argument <S> constrained the Struct field Pointer<S> addressOf. Instead, we changed the field to an extension getter:","markups":[{"type":10,"start":26,"end":29},{"type":10,"start":46,"end":52},{"type":10,"start":59,"end":69},{"type":10,"start":70,"end":79}]},{"name":"1374","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"2f678cb89187929eca771c2738bca3ff"}},{"name":"b215","type":13,"text":"Stop leaking backing storage","markups":[]},{"name":"c8db","type":1,"text":"When returning a struct by value from C to Dart, we don’t want to malloc C memory to save the struct, because that would be slow and burden the user with freeing it. So, instead, the struct is copied to a TypedData, and the Coordinate can have either a Pointer or a TypedData as backing storage.","markups":[{"type":10,"start":66,"end":72},{"type":10,"start":205,"end":214},{"type":10,"start":224,"end":234},{"type":10,"start":253,"end":260},{"type":10,"start":266,"end":275},{"type":2,"start":129,"end":132}]},{"name":"a5a7","type":1,"text":"However, addressOf, which was introduced in the first redesign, had type Pointer. This type conveyed that it was always backed by C memory, but this was no longer true.","markups":[{"type":10,"start":9,"end":18},{"type":10,"start":73,"end":80}]},{"name":"94bc","type":1,"text":"So, we deprecated addressOf.","markups":[{"type":10,"start":18,"end":27},{"type":3,"start":7,"end":17,"href":"https://github.com/dart-lang/sdk/issues/40667","title":"","rel":"","anchorType":0}]},{"name":"16a3","type":13,"text":"For optimizations","markups":[]},{"name":"4b03","type":1,"text":"The last step is to require invocations of various Dart FFI methods, including the ones related to structs, to have compile-time constant type arguments:","markups":[{"type":3,"start":116,"end":152,"href":"https://github.com/dart-lang/sdk/issues/44621","title":"","rel":"","anchorType":0}]},{"name":"c0fe","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"31e20b6edc1a0ce31581e4b28c7cbd03"}},{"name":"e8e0","type":1,"text":"The invocation of methods allows us to better optimize the code and is more aligned with C semantics.","markups":[]},{"name":"697c","type":1,"text":"Note that this last change triggers deprecation notices in Dart 2.12, and the change is enforced in Dart 2.13.","markups":[]},{"name":"53f4","type":3,"text":"The ABI discovery journey","markups":[]},{"name":"baf3","type":1,"text":"Now that the API is in place, the next question is: Where does C expect these structs when passed or returned by value? This is known as the Application Binary Interface (ABI).","markups":[{"type":2,"start":52,"end":119}]},{"name":"48b9","type":13,"text":"Documentation","markups":[]},{"name":"42d7","type":1,"text":"The natural thing is to look for documentation. ARM provides Procedure Call Standard for the Arm Architecture — ABI 2019Q1 and Procedure Call Standard for the ARM 64-bit Architecture (AArch64). However, the x86 and x64 official documentation fell off the internet, resulting in people searching for this information and resorting to unofficial mirrors or reverse engineering.","markups":[{"type":3,"start":61,"end":123,"href":"https://developer.arm.com/documentation/ihi0042/h","title":"","rel":"","anchorType":0},{"type":3,"start":127,"end":192,"href":"https://developer.arm.com/documentation/ihi0055/c/","title":"","rel":"","anchorType":0},{"type":3,"start":242,"end":263,"href":"https://stackoverflow.com/questions/18133812/where-is-the-x86-64-system-v-abi-documented","title":"","rel":"","anchorType":0},{"type":3,"start":355,"end":374,"href":"https://www.agner.org/optimize/calling_conventions.pdf","title":"","rel":"","anchorType":0}]},{"name":"92b6","type":1,"text":"A quick glance at the documentation shows a variety of locations for passing structs by value:","markups":[]},{"name":"ca09","type":9,"text":"In multiple CPU and FPU registers.","markups":[]},{"name":"d50f","type":9,"text":"On the stack.","markups":[]},{"name":"8f09","type":9,"text":"A pointer to a copy. (The copy is on the caller’s stack frame.)","markups":[]},{"name":"c975","type":9,"text":"Partially in CPU registers and partially on the stack.","markups":[]},{"name":"7d23","type":1,"text":"When passed on the stack, there are some further questions about what the required alignment is and whether all unused CPU and FPU registers are blocked off or backfilled.","markups":[]},{"name":"8334","type":1,"text":"When returning a struct by value, the struct can be passed back in two locations:","markups":[]},{"name":"3b7d","type":9,"text":"In multiple CPU and FPU registers.","markups":[]},{"name":"6b85","type":9,"text":"Written to a memory location by the callee, in which case the caller passes in a pointer to that memory location. (This reserved memory is also on the caller’s stack frame.)","markups":[]},{"name":"1308","type":1,"text":"When a pointer to the result location is passed in, a further question is whether this conflicts with a normal CPU argument register.","markups":[]},{"name":"d69a","type":13,"text":"Refactor Dart FFI compilation","markups":[]},{"name":"a00c","type":1,"text":"This initial investigation was enough to realize that we had to reengineer a part of the Dart FFI compiler pipeline. We used to reuse the Location type, which was originally intended for compiling Dart code to assembly.","markups":[{"type":10,"start":138,"end":146}]},{"name":"f1c3","type":1,"text":"However, in the Dart ABI, we never use non-word-aligned stack locations or more than two registers at the same time. An experiment trying to extend the Location type to support these extra locations ended in a huge complicated diff because Location is used a lot in the Dart virtual machine.","markups":[{"type":10,"start":152,"end":160},{"type":10,"start":240,"end":248}]},{"name":"1732","type":1,"text":"So, instead, we replaced the compilation pipeline for Dart FFI.","markups":[{"type":3,"start":16,"end":49,"href":"https://dart-review.googlesource.com/c/sdk/+/129081","title":"","rel":"","anchorType":0}]},{"name":"66d3","type":13,"text":"Explore the native ABIs","markups":[]},{"name":"4b44","type":1,"text":"Let’s explore the ABIs a bit.","markups":[]},{"name":"7fff","type":1,"text":"Suppose that we have the following struct and C function signature:","markups":[]},{"name":"f312","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"df53df3fcf4e22d5c96604daf5c87219"}},{"name":"0197","type":1,"text":"How do various ABIs pass these structs in MyFunction?","markups":[{"type":10,"start":42,"end":52}]},{"name":"9196","type":1,"text":"In Linux on x64, there are 6 CPU argument registers. The struct is small enough to fit in a single register, so the first 6 arguments go into the 6 CPU argument registers, and the last 2 go on the stack. The stack arguments are aligned to 8 bytes. And, the return value also fits in a CPU register (larger example).","markups":[{"type":3,"start":299,"end":313,"href":"https://github.com/dart-lang/sdk/blob/9d5846b86eed777933b6c7a2a15e41f2b779c650/runtime/vm/compiler/ffi/unit_tests/struct3bytesx10/x64_linux.expect","title":"","rel":"","anchorType":0}]},{"name":"aee0","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"5d9f0d9653b66ab41f518a3582bf3b9c"}},{"name":"317a","type":1,"text":"So, what happens on Windows?","markups":[]},{"name":"faea","type":1,"text":"It’s completely different. Windows has only 4 argument registers. However, the first register is used to pass the pointer to the memory location to write the return value to. And, all arguments are passed by pointer to a copy, because the size of the struct is 3 bytes, which is not a power of 2.","markups":[{"type":3,"start":5,"end":25,"href":"https://github.com/dart-lang/sdk/blob/9d5846b86eed777933b6c7a2a15e41f2b779c650/runtime/vm/compiler/ffi/unit_tests/struct3bytesx10/x64_win.expect","title":"","rel":"","anchorType":0}]},{"name":"d96a","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"b318294f0d3eec6c8e6f8654c22d1a4d"}},{"name":"629c","type":1,"text":"Let’s look at another example: ARM32 on Linux and Android. Suppose that we have the following struct and C function signature:","markups":[]},{"name":"e6f7","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"70667e0168930a389ede2b6097b5e40e"}},{"name":"388a","type":1,"text":"These specific types of structs are called homogeneous composites, because they only contain identical elements. And, homogenous floats with up to 4 members are treated differently from normal structs. In this case, Linux uses floating point registers for the individual floating points in the struct.","markups":[{"type":3,"start":216,"end":251,"href":"https://github.com/dart-lang/sdk/blob/9d5846b86eed777933b6c7a2a15e41f2b779c650/runtime/vm/compiler/ffi/unit_tests/struct16bytesHomogenousx10/arm_linux.expect","title":"","rel":"","anchorType":0}]},{"name":"9d4d","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"0a64fc30a1ada933273690c2a1a78877"}},{"name":"e2b3","type":1,"text":"On Android, SoftFP is used instead of HardFP. This means that floats are passed in integer registers rather than floating point registers. Moreover, we’re passing in a Pointer for the result. This results in a curious situation in which the first argument is partially passed in integer registers and partially passed on the stack.","markups":[{"type":10,"start":168,"end":175},{"type":3,"start":210,"end":227,"href":"https://github.com/dart-lang/sdk/blob/9d5846b86eed777933b6c7a2a15e41f2b779c650/runtime/vm/compiler/ffi/unit_tests/struct16bytesHomogenousx10/arm_android.expect","title":"","rel":"","anchorType":0}]},{"name":"1723","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"4c1ef34fbf0cdae280ae8fb1ac195b5d"}},{"name":"6fbb","type":1,"text":"Getting any of this wrong will likely lead to segmentation faults at runtime. So, it’s paramount to get all the corner cases of the ABI on every hardware and OS combination correct.","markups":[]},{"name":"d5d6","type":13,"text":"Explore through godbolt.org","markups":[]},{"name":"ddbd","type":1,"text":"Because the documentation is very terse, we figured out many corner cases through the compiler explorer godbolt.org. The compiler explorer shows C code and compiled assembly side by side:","markups":[{"type":3,"start":104,"end":115,"href":"https://godbolt.org","title":"","rel":"","anchorType":0},{"type":3,"start":174,"end":186,"href":"https://godbolt.org/z/17jzjv","title":"","rel":"","anchorType":0}]},{"name":"eeb6","type":4,"text":"","markups":[],"layout":1,"metadata":{"id":"0*SfIpbC1E-Ysaewzs","originalWidth":1400,"originalHeight":553,"isFeatured":true,"focusPercentX":22,"focusPercentY":88,"alt":"A screenshot of godbolt.com showing that the assembly code for sizeof(Struct3Bytes) is returning 3 in the return register."}},{"name":"621e","type":1,"text":"The preceding screenshot shows that on Windows x86 sizeof(Struct3Bytes) is 3 bytes, because 3 is moved into the return register eax.","markups":[{"type":10,"start":51,"end":71},{"type":10,"start":128,"end":131}]},{"name":"0be6","type":1,"text":"When we change the struct slightly, we can inspect whether the size is still 3:","markups":[{"type":3,"start":8,"end":14,"href":"https://godbolt.org/z/r1rG6s","title":"","rel":"","anchorType":0}]},{"name":"f504","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"ab004f78cef497468e14e6cfbbd15037"}},{"name":"32c1","type":1,"text":"The size is not 3: mov eax, 4. Because the int16 must be 2-byte aligned, the struct must be 2-byte aligned. That means that when allocating an array of these structs there is a 1-byte padding after every struct to ensure that the next struct is 2-byte aligned. Hence, this struct is 4 bytes in the native ABI.","markups":[{"type":10,"start":19,"end":29},{"type":10,"start":43,"end":48}]},{"name":"422d","type":13,"text":"Explore through generated tests","markups":[]},{"name":"a8fc","type":1,"text":"Unfortunately, the compiler explorer doesn’t support MacOS and iOS. So, to make exploring manually more efficient (and to have a nice and huge test suite for this feature), we wrote a test generator.","markups":[]},{"name":"70ed","type":1,"text":"The main idea is to generate tests in such a way that if they crash it’s possible to use GDB to see what’s wrong.","markups":[{"type":3,"start":89,"end":92,"href":"https://www.gnu.org/software/gdb/","title":"","rel":"","anchorType":0}]},{"name":"fcd6","type":1,"text":"One way to make it easier to see what is going wrong when hitting a segmentation fault is to make all arguments have predictable and easy-to-recognize values. For example, the following test uses consecutive integers, so that these integer values can be easily spotted in registers and on the stack:","markups":[]},{"name":"2e13","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"a78213b01fe8cfc31ce5ab46836fcfaa"}},{"name":"08a5","type":1,"text":"Another way to make finding problems easier is to add prints everywhere. For example, if we don’t hit a segmentation fault during the transition from Dart to C, but we manage to garble all the arguments, then printing the arguments helps:","markups":[]},{"name":"f97d","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"022a59c653ab804970eac4476179232d"}},{"name":"c07a","type":1,"text":"Adding a test is as easy as adding a function type in the configuration file. The ability to add tests quickly has resulted in a huge test suite.","markups":[{"type":3,"start":58,"end":76,"href":"https://dart-review.googlesource.com/c/sdk/+/168829/6/tests/ffi/generator/structs_by_value_tests_confguration.dart","title":"","rel":"","anchorType":0},{"type":3,"start":129,"end":144,"href":"https://dart-review.googlesource.com/c/sdk/+/168829","title":"","rel":"","anchorType":0}]},{"name":"5983","type":1,"text":"Sure enough, this test suite caught another curious case in a native ABI — this time on iOS-ARM64. Non-struct arguments on the stack on iOS on ARM64 aren’t aligned to word size but to their own size. Structs are aligned to word size, except that if the struct is a homogeneous struct with only floats, then it is aligned to the size of the float.","markups":[{"type":3,"start":307,"end":345,"href":"https://github.com/dart-lang/sdk/blob/b6b82dd3ac756b39e7fe9cab21f060fae74e358d/runtime/vm/compiler/ffi/native_type.cc#L180-L182","title":"","rel":"","anchorType":0}]},{"name":"0063","type":3,"text":"Summary","markups":[]},{"name":"ce5b","type":1,"text":"This concludes our journey through the API design and ABI discovery. With a good test suite and thorough code reviews, we landed support for passing structs by value in Dart FFI in December 2020 on the master branch, and it is available in Dart 2.12! If you’re interested in using Dart FFI, you can get started with the C interop documentation on dart.dev. If you have any questions or comments on the API design and ABI discovery, feel free to leave a comment below. We’d love to hear from you!","markups":[{"type":3,"start":122,"end":136,"href":"https://dart-review.googlesource.com/c/sdk/+/140290","title":"","rel":"","anchorType":0},{"type":3,"start":320,"end":355,"href":"https://dart.dev/guides/libraries/c-interop","title":"","rel":"","anchorType":0}]},{"name":"b04c","type":1,"text":"Thanks to the Dart language team and the (rest of the) Dart virtual machine team for their contributions to this Dart FFI feature, and thanks to Kathy Walrath and Michael Thomsen for shaping this blog post!","markups":[{"type":2,"start":0,"end":206}]}],"sections":[{"name":"aa13","startIndex":0}]},"postDisplay":{"coverless":true}},"virtuals":{"statusForCollection":"APPROVED","allowNotes":true,"previewImage":{"imageId":"0*SfIpbC1E-Ysaewzs","filter":"","backgroundSize":"","originalWidth":1400,"originalHeight":553,"strategy":"resample","height":0,"width":0,"focusPercentX":22,"focusPercentY":88},"wordCount":1959,"imageCount":1,"readingTime":7.592452830188679,"subtitle":"A deep dive into API design and native calling conventions.","userPostRelation":{"userId":"8b6a7f6f197d","postId":"1cb1829d11a9","readAt":0,"readLaterAddedAt":0,"votedAt":0,"collaboratorAddedAt":0,"notesAddedAt":0,"subscribedAt":0,"lastReadSectionName":"","lastReadVersionId":"","lastReadAt":0,"lastReadParagraphName":"","lastReadPercentage":0,"viewedAt":0,"presentedCountInResponseManagement":0,"clapCount":0,"seriesUpdateNotifsOptedInAt":0,"queuedAt":0,"seriesFirstViewedAt":0,"presentedCountInStream":8,"seriesLastViewedAt":0,"audioProgressSec":0},"publishedInCount":1,"usersBySocialRecommends":[],"noIndex":false,"recommends":37,"isBookmarked":false,"tags":[{"slug":"dart","name":"Dart","postCount":13858,"metadata":{"postCount":13858,"coverImage":{"id":"1*rQugDrmwFFsEDL_CqSBJNw.png","originalWidth":1536,"originalHeight":1024,"isFeatured":true}},"type":"Tag"},{"slug":"compilers","name":"Compilers","postCount":2042,"metadata":{"postCount":2042,"coverImage":{"id":"0*zQAuCpWfBbQ5UIvy","originalWidth":1536,"originalHeight":1024,"isFeatured":true}},"type":"Tag"},{"slug":"programming","name":"Programming","postCount":400575,"metadata":{"postCount":400575,"coverImage":{"id":"0*7x-LQAg1xBmi-L1p","originalWidth":1800,"originalHeight":1169,"alt":"Screenshot of a desktop with the Cursor application open"}},"type":"Tag"},{"slug":"ffi","name":"Ffi","postCount":79,"metadata":{"postCount":79,"coverImage":{"id":"1*vEhub_j0kG4o0sSpZ2_yug.png","originalWidth":1920,"originalHeight":1080,"isFeatured":true}},"type":"Tag"}],"socialRecommendsCount":0,"responsesCreatedCount":1,"links":{"entries":[{"url":"https://stackoverflow.com/questions/18133812/where-is-the-x86-64-system-v-abi-documented","alts":[],"httpStatus":200},{"url":"https://godbolt.org","alts":[],"httpStatus":200},{"url":"https://dart.dev/guides/libraries/c-interop","alts":[],"httpStatus":200},{"url":"https://medium.com/dartlang/announcing-dart-2-12-499a6e689c87","alts":[{"type":3,"url":"medium://p/499a6e689c87"},{"type":2,"url":"medium://p/499a6e689c87"}],"httpStatus":200},{"url":"https://www.gnu.org/software/gdb/","alts":[],"httpStatus":200},{"url":"https://medium.com/dartlang/dart-2-7-a3710ec54e97","alts":[{"type":3,"url":"medium://p/a3710ec54e97"},{"type":2,"url":"medium://p/a3710ec54e97"}],"httpStatus":200},{"url":"https://godbolt.org/z/r1rG6s","alts":[],"httpStatus":200},{"url":"https://godbolt.org/z/17jzjv","alts":[],"httpStatus":200},{"url":"https://dart-review.googlesource.com/c/sdk/+/129081","alts":[],"httpStatus":200},{"url":"https://dart-review.googlesource.com/c/sdk/+/168829","alts":[],"httpStatus":200},{"url":"https://dart-review.googlesource.com/c/sdk/+/108415","alts":[],"httpStatus":200},{"url":"https://dart-review.googlesource.com/c/sdk/+/168829/6/tests/ffi/generator/structs_by_value_tests_confguration.dart","alts":[],"httpStatus":200},{"url":"https://dart-review.googlesource.com/c/sdk/+/118993/16/tests/ffi/structs_test.dart","alts":[],"httpStatus":200},{"url":"https://dart-review.googlesource.com/c/sdk/+/140290","alts":[],"httpStatus":200},{"url":"https://dart-review.googlesource.com/c/sdk/+/118992/14/sdk/lib/ffi/ffi.dart","alts":[],"httpStatus":200},{"url":"https://dart-review.googlesource.com/c/sdk/+/80124","alts":[],"httpStatus":200},{"url":"https://dart-review.googlesource.com/c/sdk/+/101291","alts":[],"httpStatus":200},{"url":"https://github.com/dart-lang/sdk/blob/9d5846b86eed777933b6c7a2a15e41f2b779c650/runtime/vm/compiler/ffi/unit_tests/struct16bytesHomogenousx10/arm_linux.expect","alts":[],"httpStatus":200},{"url":"https://github.com/dart-lang/sdk/blob/9d5846b86eed777933b6c7a2a15e41f2b779c650/runtime/vm/compiler/ffi/unit_tests/struct16bytesHomogenousx10/arm_android.expect","alts":[],"httpStatus":200},{"url":"https://github.com/dart-lang/sdk/blob/9d5846b86eed777933b6c7a2a15e41f2b779c650/runtime/vm/compiler/ffi/unit_tests/struct3bytesx10/x64_win.expect","alts":[],"httpStatus":200},{"url":"https://github.com/dart-lang/sdk/blob/9d5846b86eed777933b6c7a2a15e41f2b779c650/runtime/vm/compiler/ffi/unit_tests/struct3bytesx10/x64_linux.expect","alts":[],"httpStatus":200},{"url":"https://github.com/dart-lang/sdk/blob/b6b82dd3ac756b39e7fe9cab21f060fae74e358d/runtime/vm/compiler/ffi/native_type.cc#L180-L182","alts":[],"httpStatus":200},{"url":"https://developer.arm.com/documentation/ihi0055/c/","alts":[],"httpStatus":200},{"url":"https://developer.arm.com/documentation/ihi0042/h","alts":[],"httpStatus":200},{"url":"https://github.com/dart-lang/sdk/issues/35840","alts":[],"httpStatus":200},{"url":"https://www.agner.org/optimize/calling_conventions.pdf","alts":[],"httpStatus":200},{"url":"https://github.com/dart-lang/sdk/issues/40667","alts":[],"httpStatus":200},{"url":"https://github.com/dart-lang/sdk/issues/44621","alts":[],"httpStatus":200},{"url":"https://github.com/dart-lang/sdk/issues/36730","alts":[],"httpStatus":200}],"version":"0.3","generatedAt":1623179828911},"isLockedPreviewOnly":false,"metaDescription":"","totalClapCount":193,"sectionCount":1,"readingList":0,"topics":[{"topicId":"decb52b64abf","slug":"programming","createdAt":1493934116328,"deletedAt":0,"image":{"id":"1*iPa136b1cGEO7lvoXg6uHQ@2x.jpeg","originalWidth":6016,"originalHeight":4016},"name":"Programming","description":"The good, the bad, the buggy.","relatedTopics":[],"visibility":1,"relatedTags":[],"relatedTopicIds":[],"seoTitle":"Programming News and Articles — Medium","type":"Topic"}]},"coverless":true,"slug":"implementing-structs-by-value-in-dart-ffi","translationSourcePostId":"","translationSourceCreatorId":"","isApprovedTranslation":false,"inResponseToPostId":"","inResponseToRemovedAt":0,"isTitleSynthesized":false,"allowResponses":true,"importedUrl":"","importedPublishedAt":0,"visibility":0,"uniqueSlug":"implementing-structs-by-value-in-dart-ffi-1cb1829d11a9","previewContent":{"bodyModel":{"paragraphs":[{"name":"previewImage","type":4,"text":"","layout":10,"metadata":{"id":"0*SfIpbC1E-Ysaewzs","originalWidth":1400,"originalHeight":553,"isFeatured":true,"focusPercentX":22,"focusPercentY":88,"alt":"A screenshot of godbolt.com showing that the assembly code for sizeof(Struct3Bytes) is returning 3 in the return register."}},{"name":"15d2","type":3,"text":"Implementing structs by value in Dart FFI","markups":[],"alignment":1},{"name":"19fb","type":13,"text":"A deep dive into API design and native calling conventions","markups":[],"alignment":1}],"sections":[{"startIndex":0}]},"isFullContent":false,"subtitle":"A deep dive into API design and native calling conventions."},"license":0,"inResponseToMediaResourceId":"","canonicalUrl":"https://blog.dart.dev/implementing-structs-by-value-in-dart-ffi-1cb1829d11a9","approvedHomeCollectionId":"23738d481ce8","isNewsletter":false,"newsletterId":"","webCanonicalUrl":"https://blog.dart.dev/implementing-structs-by-value-in-dart-ffi-1cb1829d11a9","mediumUrl":"https://blog.dart.dev/implementing-structs-by-value-in-dart-ffi-1cb1829d11a9","migrationId":"","notifyFollowers":true,"notifyTwitter":false,"notifyFacebook":false,"responseHiddenOnParentPostAt":0,"isSeries":false,"isSubscriptionLocked":false,"seriesLastAppendedAt":0,"audioVersionDurationSec":0,"sequenceId":"","isEligibleForRevenue":false,"isBlockedFromHightower":false,"deletedAt":0,"lockedPostSource":0,"hightowerMinimumGuaranteeStartsAt":0,"hightowerMinimumGuaranteeEndsAt":0,"featureLockRequestAcceptedAt":0,"mongerRequestType":1,"layerCake":3,"socialTitle":"","socialDek":"","editorialPreviewTitle":"","editorialPreviewDek":"","curationEligibleAt":0,"primaryTopic":{"topicId":"decb52b64abf","slug":"programming","createdAt":1493934116328,"deletedAt":0,"image":{"id":"1*iPa136b1cGEO7lvoXg6uHQ@2x.jpeg","originalWidth":6016,"originalHeight":4016},"name":"Programming","description":"The good, the bad, the buggy.","relatedTopics":[],"visibility":1,"relatedTags":[],"relatedTopicIds":[],"seoTitle":"Programming News and Articles — Medium","type":"Topic"},"primaryTopicId":"decb52b64abf","isProxyPost":false,"proxyPostFaviconUrl":"","proxyPostProviderName":"","proxyPostType":0,"isSuspended":false,"isLimitedState":false,"seoTitle":"","previewContent2":{"bodyModel":{"paragraphs":[{"name":"15d2","type":3,"text":"Implementing structs by value in Dart FFI","markups":[]},{"name":"19fb","type":13,"text":"A deep dive into API design and native calling conventions","markups":[]},{"name":"085f","type":1,"text":"In the Dart 2.12 release, we extended our C-interop feature, Dart FFI, with the ability to pass structs by value. This article talks about what it took to add this feature to the Dart SDK. If you’re interested in low-level language implementation details or in platform conventions for passing structs…","markups":[{"type":3,"start":7,"end":16,"href":"https://medium.com/dartlang/announcing-dart-2-12-499a6e689c87","title":"","rel":"","anchorType":0},{"type":3,"start":42,"end":70,"href":"https://dart.dev/guides/libraries/c-interop","title":"","rel":"","anchorType":0},{"type":3,"start":91,"end":112,"href":"https://github.com/dart-lang/sdk/issues/36730","title":"","rel":"","anchorType":0}]}],"sections":[{"name":"aa13","startIndex":0}]},"isFullContent":false,"subtitle":"A deep dive into API design and native calling conventions."},"cardType":0,"isDistributionAlertDismissed":false,"isShortform":false,"shortformType":0,"responsesLocked":false,"isLockedResponse":false,"isPublishToEmail":false,"responseDistribution":0,"isMarkedPaywallOnly":false,"type":"Post"},"mentionedUsers":[],"collaborators":[],"hideMeter":false,"shareKey":"cc92a05fd06d1d5acc720f84a16cf9dd","collectionUserRelations":[{"collectionId":"23738d481ce8","userId":"8b6a7f6f197d","role":"ADMIN"},{"collectionId":"4da7dfd21a33","userId":"8b6a7f6f197d","role":"WRITER"},{"collectionId":"24d8f4fa8912","userId":"8b6a7f6f197d","role":"WRITER"}],"mode":"canEdit","references":{"User":{"6d41df764cd":{"userId":"6d41df764cd","name":"Daco Harkes","username":"dacoharkes","createdAt":1600761741678,"imageId":"0*l4aOEMeI6r-AZJ2O","backgroundImageId":"","bio":"Software Engineer at Google on the Dart compiler and virtual machine team.","twitterScreenName":"","socialStats":{"userId":"6d41df764cd","usersFollowedCount":1,"usersFollowedByCount":33,"type":"SocialStats"},"social":{"userId":"8b6a7f6f197d","targetUserId":"6d41df764cd","type":"Social"},"allowNotes":1,"mediumMemberAt":0,"isWriterProgramEnrolled":true,"isSuspended":false,"isMembershipTrialEligible":true,"facebookDisplayName":"","optInToIceland":true,"hasCompletedProfile":false,"userDismissableFlags":[1,2,5,12,58,59],"hasSeenIcelandOnboarding":false,"postSubscribeMembershipUpsellShownAt":0,"languageCode":"en-us","type":"User"}},"Collection":{"23738d481ce8":{"id":"23738d481ce8","name":"Dart","slug":"dartlang","tags":["MOBILE APP DEVELOPMENT","WEB DEVELOPMENT","DART","PROGRAMMING LANGUAGES","SOFTWARE DEVELOPMENT"],"creatorId":"a6d788faa5e5","description":"Dart is an approachable, portable, and productive language for high-quality apps on any platform. Learn more at https://dart.dev.","shortDescription":"Dart is an approachable, portable, and productive language…","image":{"imageId":"1*uWy1Ajpd0oTUQBO9WBHoQg@2x.png","filter":"","backgroundSize":"","originalWidth":1001,"originalHeight":1001,"strategy":"resample","height":0,"width":0},"metadata":{"followerCount":14031,"activeAt":1762974121956},"virtuals":{"permissions":{"canPublish":true,"canPublishAll":true,"canRepublish":true,"canRemove":true,"canManageAll":true,"canSubmit":true,"canEditPosts":true,"canAddWriters":true,"canViewStats":true,"canSendNewsletter":true,"canViewLockedPosts":true,"canViewCloaked":true,"canEditOwnPosts":true,"canBeAssignedAuthor":true,"canEnrollInHightower":false,"canLockPostsForMediumMembers":false,"canLockOwnPostsForMediumMembers":false,"canViewNewsletterV2Stats":true,"canCreateNewsletterV3":true},"isSubscribed":true,"isEnrolledInHightower":false,"isEligibleForHightower":false,"isSubscribedToCollectionEmails":false,"isMuted":false,"canToggleEmail":false,"isWriter":false},"logo":{"imageId":"1*NRb7RFVWJQFzY47j3v4U7Q.png","filter":"","backgroundSize":"","originalWidth":400,"originalHeight":154,"strategy":"resample","height":0,"width":0},"twitterUsername":"dart_lang","publicEmail":"medium@dartlang.org","domain":"blog.dart.dev","sections":[{"type":2,"collectionHeaderMetadata":{"title":"Dart","description":"An approachable, portable, and productive language for high-quality apps on any platform","backgroundImage":{},"logoImage":{"id":"1*knHF_qpxdtS8h0Z8EeqowA@2x.png","originalWidth":1080,"originalHeight":1080,"alt":"Dart"},"alignment":2,"layout":5}},{"type":1,"postListMetadata":{"source":1,"layout":4,"number":7,"postIds":[]}},{"type":1,"postListMetadata":{"source":1,"layout":5,"number":15,"postIds":[]}}],"tintColor":"#FF042B59","lightText":true,"favicon":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"colorPalette":{"defaultBackgroundSpectrum":{"colorPoints":[{"color":"#FF6588BA","point":0},{"color":"#FF607EAB","point":0.1},{"color":"#FF59759C","point":0.2},{"color":"#FF536B8E","point":0.3},{"color":"#FF4C617F","point":0.4},{"color":"#FF445670","point":0.5},{"color":"#FF3D4B61","point":0.6},{"color":"#FF344052","point":0.7},{"color":"#FF2B3442","point":0.8},{"color":"#FF212832","point":0.9},{"color":"#FF161A22","point":1}],"backgroundColor":"#FFFFFFFF"},"tintBackgroundSpectrum":{"colorPoints":[{"color":"#FF042B59","point":0},{"color":"#FF294871","point":0.1},{"color":"#FF456087","point":0.2},{"color":"#FF5F779B","point":0.3},{"color":"#FF788DAD","point":0.4},{"color":"#FF8FA2BF","point":0.5},{"color":"#FFA5B6CF","point":0.6},{"color":"#FFBBC9DF","point":0.7},{"color":"#FFD1DCEE","point":0.8},{"color":"#FFE6EEFC","point":0.9},{"color":"#FFFBFFFF","point":1}],"backgroundColor":"#FF042B59"},"highlightSpectrum":{"colorPoints":[{"color":"#FFECF3FF","point":0},{"color":"#FFE9F2FF","point":0.1},{"color":"#FFE5F0FF","point":0.2},{"color":"#FFE2EFFF","point":0.3},{"color":"#FFDEEDFF","point":0.4},{"color":"#FFDBEBFF","point":0.5},{"color":"#FFD7EAFF","point":0.6},{"color":"#FFD3E8FF","point":0.7},{"color":"#FFCFE6FF","point":0.8},{"color":"#FFCBE5FF","point":0.9},{"color":"#FFC8E3FF","point":1}],"backgroundColor":"#FFFFFFFF"},"darkBackgroundSpectrum":{"colorPoints":[{"color":"#FF7DA0D3","point":0},{"color":"#FF89A9D8","point":0.1},{"color":"#FF94B1DC","point":0.2},{"color":"#FFA0B9E0","point":0.3},{"color":"#FFABC1E3","point":0.4},{"color":"#FFB6C9E7","point":0.5},{"color":"#FFC0D1EB","point":0.6},{"color":"#FFCBD8EF","point":0.7},{"color":"#FFD5E0F2","point":0.8},{"color":"#FFE0E7F6","point":0.9},{"color":"#FFEAEFFA","point":1}],"backgroundColor":"#FF000000"}},"navItems":[{"type":1,"title":"Announcements","tagSlug":"announcements","url":"https://blog.dart.dev/tagged/announcements","source":"tagSlug"},{"type":5,"title":"Archive","url":"https://blog.dart.dev/archive"},{"type":3,"title":"dart.dev","url":"https://dart.dev"}],"colorBehavior":2,"collectionFeatures":[25],"ampLogo":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"header":{"title":"Dart","description":"An approachable, portable, and productive language for high-quality apps on any platform","backgroundImage":{},"logoImage":{"id":"1*knHF_qpxdtS8h0Z8EeqowA@2x.png","originalWidth":1080,"originalHeight":1080,"alt":"Dart"},"alignment":2,"layout":5},"subscriberCount":14031,"tagline":"Dart is a client-optimized language for fast apps on any platform.","isOptedIntoAurora":false,"isCurationAllowedByDefault":false,"polarisCoverImage":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"ptsQualifiedAt":1616092887098,"type":"Collection"}},"Social":{"6d41df764cd":{"userId":"8b6a7f6f197d","targetUserId":"6d41df764cd","type":"Social"}},"SocialStats":{"6d41df764cd":{"userId":"6d41df764cd","usersFollowedCount":1,"usersFollowedByCount":33,"type":"SocialStats"}}}},"v":3,"b":"20260130-1012-root"}