{"success":true,"payload":{"value":{"id":"7dd93c28c87a","versionId":"d7287a2500f3","creatorId":"9e0692285f8b","homeCollectionId":"23738d481ce8","title":"Why nullable types?","detectedLanguage":"en","latestVersion":"d7287a2500f3","latestPublishedVersion":"d7287a2500f3","hasUnpublishedEdits":false,"latestRev":753,"createdAt":1607129857082,"updatedAt":1640233745264,"acceptedAt":0,"firstPublishedAt":1607360577383,"latestPublishedAt":1607360577383,"vote":false,"experimentalCss":"","displayAuthor":"","content":{"subtitle":"Null in Dart code indicates that a variable has no value, but some languages don’t allow null. Learn why both approaches work.","bodyModel":{"paragraphs":[{"name":"f7d2","type":3,"text":"Why nullable types?","markups":[]},{"name":"f773","type":1,"text":"A few weeks ago, we announced Dart null safety beta, a major productivity feature intended to help you avoid null errors. Speaking of null values, in the /r/dart_lang subreddit a user recently asked:","markups":[{"type":3,"start":177,"end":198,"href":"https://www.reddit.com/r/dartlang/comments/jruhji/why_does_nnbd_dart_still_have_null/gbwi364/","title":"","rel":"","anchorType":0}]},{"name":"65b5","type":6,"text":"But why do we even still have/want null values? Why not get rid of it completely? I’m currently also playing around with Rust and it doesn’t have null at all. So it seems to be possible to live without it.","markups":[]},{"name":"89bb","type":1,"text":"I love this question. Why not get rid of null completely? This article is an expanded version of what I answered on that thread.","markups":[{"type":10,"start":41,"end":45},{"type":2,"start":26,"end":29}]},{"name":"bf24","type":1,"text":"The short answer is that, yes, it is entirely possible to live without null, and languages like Rust do. But programmers do use null, so before we can take it away, we need to understand why it’s used. What is null usually doing when we use it in languages that do have it?","markups":[{"type":10,"start":71,"end":75},{"type":10,"start":128,"end":132},{"type":10,"start":210,"end":214},{"type":2,"start":121,"end":123},{"type":2,"start":223,"end":228}]},{"name":"fdd7","type":1,"text":"It turns out that null is typically used to represent the absence of a value, which is eminently useful. Some people don’t have middle names. Some mailing addresses don’t have apartment numbers. Some monsters don’t have any treasure to drop when you slay them.","markups":[{"type":10,"start":18,"end":22},{"type":2,"start":58,"end":65}]},{"name":"59a9","type":1,"text":"In cases like that, we want a way to express, “This variable could have a value of type X, or it may have no value at all.” The question then is how do we model that?","markups":[]},{"name":"2bb7","type":1,"text":"One option is to say that a variable can contain a value of the expected type, or it can contain the magic value null. If we try to use the value when it’s null, we get a runtime failure. This is what Dart did before null safety, what SQL does, what Java does for non-primitive types, and what C# does for class types.","markups":[{"type":10,"start":113,"end":117},{"type":10,"start":156,"end":160}]},{"name":"dae8","type":1,"text":"But failing at runtime sucks. It means our users experience the bug. We programmers would rather find those failures before they do. In fact, we’d be happy if we could find the bugs even before we ran our program. So how do we model the absence of a value in a way that the type system understands? In other words, how do we give “potentially absent” values and “definitely present” values different static types?","markups":[{"type":2,"start":194,"end":196}]},{"name":"2ac1","type":1,"text":"There are two main solutions:","markups":[]},{"name":"ed20","type":10,"text":"Use an option or maybe type","markups":[]},{"name":"0cce","type":10,"text":"Use a nullable type","markups":[]},{"name":"c835","type":3,"text":"Solution 1: Option types","markups":[]},{"name":"2bd6","type":1,"text":"This is what ML and most functional languages derived from ML (including Rust, Scala, and Swift) do. When we know we will definitely have a value, we just use the underlying type. If we write int it means, “There is definitely an integer here.”","markups":[{"type":10,"start":192,"end":195},{"type":3,"start":13,"end":15,"href":"https://en.wikipedia.org/wiki/ML_(programming_language)","title":"","rel":"","anchorType":0}]},{"name":"f2fb","type":1,"text":"To express a potentially absent value, we wrap the underlying type in an option type. So Option<int> represents a value that might be an integer or might be nothing at all. It’s like a collection type that can contain zero or one item.","markups":[{"type":10,"start":89,"end":100},{"type":3,"start":73,"end":84,"href":"https://en.wikipedia.org/wiki/Option_type","title":"","rel":"","anchorType":0},{"type":2,"start":42,"end":46}]},{"name":"a9cf","type":1,"text":"From the type system’s perspective, there is no direction relationship between int and Option<int>. Treating these as distinct types means we can’t accidentally pass a potentially-absent Option<int> to something expecting a real int. We also can’t accidentally try to use an Option<int> as if it were an integer since it doesn’t support any of those operations. We can’t perform arithmetic on an Option<int> any more than we could on a List<int>.","markups":[{"type":10,"start":79,"end":82},{"type":10,"start":87,"end":98},{"type":10,"start":187,"end":198},{"type":10,"start":229,"end":232},{"type":10,"start":275,"end":286},{"type":10,"start":396,"end":407},{"type":10,"start":436,"end":445}]},{"name":"828d","type":1,"text":"To create a value of an option type from a present value of the underlying type (say 3), you construct the option like Some(3). To create an option type when the value is absent, you write something like None().","markups":[{"type":10,"start":85,"end":86},{"type":10,"start":119,"end":126},{"type":10,"start":204,"end":210}]},{"name":"4e4c","type":1,"text":"In order to use a potentially absent integer stored in an Option<int>, we have to first check and see if the value is there. If so, we can extract the integer from the option and use it, just like reading a value out of a collection. Languages that have option types usually also have nice pattern matching syntax, which gives us an elegant way to check if the value is there and use it if so.","markups":[{"type":10,"start":58,"end":69},{"type":3,"start":290,"end":306,"href":"https://en.wikipedia.org/wiki/Pattern_matching","title":"","rel":"","anchorType":0}]},{"name":"2ba9","type":3,"text":"Solution 2: Nullable types","markups":[]},{"name":"8830","type":1,"text":"The other option (heh), is what Kotlin, TypeScript, and now Dart do. Nullable types are a special case of union types.","markups":[{"type":3,"start":69,"end":83,"href":"https://en.wikipedia.org/wiki/Nullable_type","title":"","rel":"","anchorType":0},{"type":3,"start":106,"end":117,"href":"https://en.wikipedia.org/wiki/Union_type","title":"","rel":"","anchorType":0}]},{"name":"4388","type":1,"text":"(Tangent: The naming gets really confusing here. Option types — what ML and friends do above — are a special case of algebraic datatypes. Another name for algebraic datatypes is “discriminated unions”. But, despite “union” being in the name, “discriminated unions” are quite different from “union types”. As Phil Karlton said, there are only two hard problems in computer science: cache invalidation and naming things.)","markups":[{"type":3,"start":117,"end":136,"href":"https://en.wikipedia.org/wiki/Algebraic_data_type","title":"","rel":"","anchorType":0}]},{"name":"0b28","type":1,"text":"Similar to the option type approach, we use the underlying type to represent a definitely present value. So int again means we absolutely have an integer. If we want a potentially absent integer, we instead use the int? nullable type. The little question mark is syntactic sugar for writing what is essentially a union type like int | Null.","markups":[{"type":10,"start":108,"end":111},{"type":10,"start":215,"end":219},{"type":10,"start":329,"end":339}]},{"name":"7101","type":1,"text":"Just like with option types, a nullable type does not support the same operations as the underlying type. The type system won’t let us try to perform arithmetic on a nullable int because that isn’t safe. Likewise, we can’t pass a nullable integer to something that requires an actual integer.","markups":[{"type":10,"start":175,"end":178}]},{"name":"e69e","type":1,"text":"However, the type system is a little more flexible than with option types. The type system understands that a union type is a supertype of its branches. In other words, int is a subtype of int?. That means we can pass a definitely-present-integer to something that expects a maybe-present-integer since that’s safe to do. It’s an upcast, just like we can pass a String to a function that takes Object. Dart only prohibits us from going the other way—from nullable to non-nullable—because that would be a downcast and those could fail.","markups":[{"type":10,"start":169,"end":172},{"type":10,"start":189,"end":193},{"type":10,"start":362,"end":368},{"type":10,"start":394,"end":400},{"type":2,"start":209,"end":212}]},{"name":"63e8","type":1,"text":"When we have a value of a nullable type and we want to see if there is an actual value or null there, we check the value imperatively just like we would naturally do in C or Java:","markups":[{"type":10,"start":90,"end":94}]},{"name":"b40c","type":8,"text":"foo(int? i) {\n  if (i != null) {\n    print(i + 1);\n  }\n}","markups":[{"type":10,"start":0,"end":56}]},{"name":"faf8","type":1,"text":"The language then uses flow analysis to determine which parts of the program are guarded behind those checks. The analysis determines that code can only be reached if the variable is not null, so inside those regions, the type system tightens the variable’s type to be non-nullable. So, here, it treats i as having type int inside the if statement.","markups":[{"type":10,"start":187,"end":191},{"type":10,"start":303,"end":304},{"type":10,"start":320,"end":323},{"type":10,"start":335,"end":337},{"type":3,"start":23,"end":36,"href":"https://en.wikipedia.org/wiki/Control-flow_graph","title":"","rel":"","anchorType":0}]},{"name":"5612","type":3,"text":"Which solution should a language take?","markups":[]},{"name":"a45a","type":1,"text":"So when we on the Dart team decide to make the language handle null in a safer way, how should we go about choosing solution 1 or 2? We can start by observing our users. How do they want to write code that checks for absent values? In functional languages, pattern matching is one of the primary control flow structures, and users there are very comfortable with it. Using option types and pattern matching is natural in that style.","markups":[]},{"name":"28dd","type":1,"text":"In imperative languages derived from C, code like my previous example is the idiomatic way to check for null. Using flow analysis and nullable types makes that familiar code work correctly and safely. In fact, with Dart, we’ve found that most existing code is already statically null safe with the new type system because the new flow analysis correctly analyzes the already written code.","markups":[{"type":10,"start":104,"end":108},{"type":2,"start":238,"end":313}]},{"name":"5931","type":1,"text":"(This is in some ways not a surprise. Most code is already dynamically correct with regards to handling null. If it wasn’t, it would be crashing all the time. Much of the job is simply making the type system smart enough to see that that code is already correct, so that the user’s attention is drawn to the few bits that are not.)","markups":[{"type":10,"start":104,"end":108},{"type":2,"start":38,"end":42},{"type":2,"start":59,"end":70},{"type":2,"start":326,"end":329}]},{"name":"92ff","type":1,"text":"So if our goal is to maximize familiarity and user comfort (which are important criteria in language design), we should just follow the path that our language’s control flow structures lay out for us.","markups":[{"type":2,"start":66,"end":69}]},{"name":"05d7","type":3,"text":"Representing absence and presence","markups":[]},{"name":"fcf1","type":1,"text":"There is a deeper way to approach this question based on differences between how option types and nullable types are represented. That representation difference forces a few key trade-offs on us, and those might lean us in one direction or the other.","markups":[]},{"name":"3e1a","type":1,"text":"With the first approach, a value of option type has a runtime representation distinct from the underlying value. Say we chose option types in Dart, and you created one and then upcast it to Object:","markups":[{"type":10,"start":190,"end":196}]},{"name":"beb2","type":8,"text":"var optionalInt = Some(3);\nObject obj = optionalInt;\nprint(obj is int); // false","markups":[{"type":10,"start":0,"end":80}]},{"name":"954c","type":1,"text":"Note the last line. An Option<int> value, even when present, is not the same kind of thing as a value of the underlying type. Some(3) and 3 are distinct, distinguishable values.","markups":[{"type":10,"start":23,"end":34},{"type":10,"start":126,"end":133},{"type":10,"start":138,"end":139},{"type":2,"start":64,"end":67}]},{"name":"f7e0","type":1,"text":"That’s not how nullable types work:","markups":[]},{"name":"6760","type":8,"text":"var nullableInt = 3 as int?;\nObject obj = nullableInt;\nprint(obj is int); // true","markups":[{"type":10,"start":0,"end":81}]},{"name":"a695","type":1,"text":"Nullable types exist in the static type system, but the runtime representation of values uses the underlying type. If you have a “nullable 3”, at runtime it’s just the number 3. If you have an absent value of some nullable type, at runtime you just have the solitary magic value null.","markups":[{"type":10,"start":175,"end":176},{"type":10,"start":279,"end":283},{"type":2,"start":28,"end":46}]},{"name":"f243","type":1,"text":"You can ask if a value is of a nullable type:","markups":[]},{"name":"9364","type":8,"text":"print(obj is int?);","markups":[{"type":10,"start":0,"end":19}]},{"name":"0506","type":1,"text":"But the is int? expression is equivalent to:","markups":[{"type":10,"start":8,"end":15}]},{"name":"2fad","type":8,"text":"print(obj is int || obj is Null);","markups":[{"type":10,"start":0,"end":33}]},{"name":"6337","type":3,"text":"Nested optionals","markups":[]},{"name":"1f12","type":1,"text":"Since values of option types are different from the underlying type, this gives us an important capability: Option types can nest.","markups":[]},{"name":"48b9","type":1,"text":"Let’s say we have some network service that gives out resource strings when given a request with some integer ID. Some resources are not present and the server will respond with no data for that ID. Since hitting the network is slow, we want to locally cache the results of requests we’ve already performed.","markups":[]},{"name":"7fd2","type":1,"text":"In Dart before null safety, we might use a map like so:","markups":[]},{"name":"4df6","type":8,"text":"Map<int, String> cache;","markups":[{"type":10,"start":0,"end":23}]},{"name":"300f","type":1,"text":"So before making a network request for some ID, we use the subscript operator on the cache map to look up the resource’s ID. That operator is defined on Map to return null if the key is not present. But the key could also be present and associated with a null value. If we do a lookup and get back null, it could mean either:","markups":[{"type":10,"start":153,"end":156},{"type":10,"start":167,"end":171},{"type":10,"start":255,"end":259},{"type":10,"start":298,"end":302}]},{"name":"8637","type":9,"text":"The key was not present in the map. This means we haven’t done the request yet, so we should ask the server to look up the resource.","markups":[]},{"name":"9828","type":9,"text":"The key was present and associated with null. This means we already did ask the server, found that the resource wasn’t present, and stored that in the cache. We should use that result and not query the server again.","markups":[{"type":10,"start":40,"end":44}]},{"name":"39c0","type":1,"text":"Because there’s only a single null value in the entire system, we don’t have a runtime representation that can distinguish these two cases. This is why the Map class has a separate containsKey() method. That API provides a way to distinguish these two cases.","markups":[{"type":10,"start":30,"end":34},{"type":10,"start":156,"end":159},{"type":10,"start":181,"end":194}]},{"name":"fcaa","type":1,"text":"Now, if Dart were built around option types, the cache would look like:","markups":[]},{"name":"17e2","type":8,"text":"Map<int, Option<String>> cache;","markups":[{"type":10,"start":0,"end":31}]},{"name":"1a95","type":1,"text":"And the subscript operator would return an optional value:","markups":[]},{"name":"5048","type":8,"text":"class Map<K, V> {\n  Option<V> operator [](K key) => ...\n  ...\n}","markups":[{"type":10,"start":0,"end":63}]},{"name":"6219","type":1,"text":"In the case of our Map<int, Option<String>>, that means the return type is Option<Option<String>>. Note the nesting! Now, when we look up a key in the cache, we can get a few different results:","markups":[{"type":10,"start":19,"end":43},{"type":10,"start":75,"end":97}]},{"name":"009a","type":9,"text":"A Some(Some(string)) means the resource did exist on the server, and we have it in the cache now.","markups":[{"type":10,"start":2,"end":20}]},{"name":"52bd","type":9,"text":"A Some(None()) means we did ask the server and the resource was not there, so we have cached the fact that the resource doesn’t exist.","markups":[{"type":10,"start":2,"end":14}]},{"name":"0270","type":9,"text":"A None() means the cache does not contain this ID at all.","markups":[{"type":10,"start":2,"end":8}]},{"name":"b552","type":1,"text":"We can distinguish the last two cases because options always wrap their underlying value in some extra state. At runtime, we can determine how many layers there are and peel them off individually.","markups":[]},{"name":"37b8","type":1,"text":"Nullable types, since they have no explicit runtime representation, are implicitly flattened. So int? and int?? are equivalent types to the type system and have equivalent sets of values at runtime. This is why fans of option types describe them as “more expressive”: because optional types give you a way to represent more kinds of values than nullable types do.","markups":[{"type":10,"start":97,"end":101},{"type":10,"start":106,"end":111}]},{"name":"e4bf","type":3,"text":"Nullable substitution","markups":[]},{"name":"81d8","type":1,"text":"Another way of thinking about “expressiveness” is how much effort it takes for the user to express what they actually want to express. A language is more expressive if the user can reach their goal while jumping through fewer hoops.","markups":[{"type":2,"start":59,"end":65}]},{"name":"c401","type":1,"text":"An advantage of having no distinct representation for nullable types is that values can flow from non-nullable to nullable contexts much more easily. Let’s say you have a function that accepts an optional integer parameter. With option types, the signature would look something like:","markups":[]},{"name":"47af","type":8,"text":"takesMaybeInt(Option<int> optionalInt) {}","markups":[{"type":10,"start":0,"end":41}]},{"name":"3bb0","type":1,"text":"To call this function with a known integer, it must be wrapped in an option first:","markups":[]},{"name":"e45e","type":8,"text":"takesMaybeInt(Some(3));","markups":[{"type":10,"start":0,"end":23}]},{"name":"3ad5","type":1,"text":"With nullable types, since there is no representation difference, you can pass a value of the underlying type directly:","markups":[]},{"name":"efce","type":8,"text":"takesMaybeInt(3);","markups":[{"type":10,"start":0,"end":17}]},{"name":"db54","type":1,"text":"You get this flexibility everywhere in the type system. You can override a method that returns a nullable type to return a non-nullable type. You can pass a List<int> to a function that wants a List<int?>.","markups":[{"type":10,"start":157,"end":166},{"type":10,"start":194,"end":204}]},{"name":"1ed0","type":1,"text":"So while nullable types lose the ability to nest and represent multiple distinct kinds of “absence”, in return they make it much easier to work with the one blessed notion of null.","markups":[{"type":10,"start":175,"end":179},{"type":2,"start":81,"end":86}]},{"name":"5b50","type":3,"text":"Nullability for Dart","markups":[]},{"name":"7320","type":1,"text":"Dart is an imperative language where people already use if statements to check for absent values at runtime. It’s also an object-oriented language where we already have a special null value with its own runtime representation. So solution 2, nullable types, was the natural answer for us. It lets our users write the kind of code they are familiar with, and takes advantage of how the runtime already represents values.","markups":[{"type":10,"start":56,"end":58},{"type":10,"start":179,"end":183}]},{"name":"25ae","type":1,"text":"For more information about nullability in Dart, check out the Where to learn more section of the Dart null safety docs.","markups":[{"type":3,"start":62,"end":81,"href":"https://dart.dev/null-safety#where-to-learn-more","title":"","rel":"","anchorType":0},{"type":3,"start":97,"end":118,"href":"https://dart.dev/null-safety","title":"","rel":"","anchorType":0}]},{"name":"784e","type":4,"text":"One of these puzzle pieces is null.","markups":[],"layout":1,"metadata":{"id":"1*ihpy1Ngzg7SczCKkuh_WhQ.jpeg","originalWidth":3000,"originalHeight":2250,"isFeatured":true,"alt":"A photo of an all-white jigsaw puzzle with one piece missing, revealing a black background."}}],"sections":[{"name":"2eb5","startIndex":0}]},"postDisplay":{"coverless":true}},"virtuals":{"statusForCollection":"APPROVED","allowNotes":true,"previewImage":{"imageId":"1*ihpy1Ngzg7SczCKkuh_WhQ.jpeg","filter":"","backgroundSize":"","originalWidth":3000,"originalHeight":2250,"strategy":"resample","height":0,"width":0},"wordCount":2321,"imageCount":1,"readingTime":8.958490566037735,"subtitle":"Null in Dart code indicates that a variable has no value, but some languages don’t allow null. Learn why both approaches work.","userPostRelation":{"userId":"8b6a7f6f197d","postId":"7dd93c28c87a","readAt":0,"readLaterAddedAt":0,"votedAt":0,"collaboratorAddedAt":0,"notesAddedAt":0,"subscribedAt":0,"lastReadSectionName":"","lastReadVersionId":"","lastReadAt":0,"lastReadParagraphName":"","lastReadPercentage":0,"viewedAt":0,"presentedCountInResponseManagement":0,"clapCount":0,"seriesUpdateNotifsOptedInAt":0,"queuedAt":0,"seriesFirstViewedAt":0,"presentedCountInStream":4,"seriesLastViewedAt":0,"audioProgressSec":0},"publishedInCount":1,"usersBySocialRecommends":[],"noIndex":false,"recommends":170,"isBookmarked":false,"tags":[{"slug":"dart","name":"Dart","postCount":13858,"metadata":{"postCount":13858,"coverImage":{"id":"1*rQugDrmwFFsEDL_CqSBJNw.png","originalWidth":1536,"originalHeight":1024,"isFeatured":true}},"type":"Tag"},{"slug":"programming-languages","name":"Programming Languages","postCount":14860,"metadata":{"postCount":14860,"coverImage":{"id":"1*sD09-ccQCGBvaNKvzpbTbw.png","originalWidth":1690,"originalHeight":964,"isFeatured":true}},"type":"Tag"},{"slug":"developer-experience","name":"Developer Experience","postCount":1753,"metadata":{"postCount":1753,"coverImage":{"id":"1*i2_U-fhYaucmNUCb5NRTnQ.jpeg","originalWidth":1536,"originalHeight":1024,"isFeatured":true}},"type":"Tag"}],"socialRecommendsCount":0,"responsesCreatedCount":4,"links":{"entries":[{"url":"https://en.wikipedia.org/wiki/Union_type","alts":[],"httpStatus":200},{"url":"https://en.wikipedia.org/wiki/Control-flow_graph","alts":[],"httpStatus":200},{"url":"https://en.wikipedia.org/wiki/ML_(programming_language)","alts":[],"httpStatus":200},{"url":"https://en.wikipedia.org/wiki/Nullable_type","alts":[],"httpStatus":200},{"url":"https://en.wikipedia.org/wiki/Pattern_matching","alts":[],"httpStatus":200},{"url":"https://en.wikipedia.org/wiki/Algebraic_data_type","alts":[],"httpStatus":200},{"url":"https://en.wikipedia.org/wiki/Option_type","alts":[],"httpStatus":200},{"url":"https://www.reddit.com/r/dartlang/comments/jruhji/why_does_nnbd_dart_still_have_null/gbwi364/","alts":[{"type":2,"url":"reddit://www.reddit.com/r/dartlang/comments/jruhji/why_does_nnbd_dart_still_have_null/gbwi364/"},{"type":1,"url":"https://cdn.ampproject.org/c/s/amp.reddit.com/r/dartlang/comments/jruhji/why_does_nnbd_dart_still_have_null/"}],"httpStatus":200},{"url":"https://dart.dev/null-safety","alts":[],"httpStatus":200},{"url":"https://dart.dev/null-safety#where-to-learn-more","alts":[],"httpStatus":200}],"version":"0.3","generatedAt":1607360579039},"isLockedPreviewOnly":false,"metaDescription":"","totalClapCount":1682,"sectionCount":1,"readingList":0,"topics":[{"topicId":"decb52b64abf","slug":"programming","createdAt":1493934116328,"deletedAt":0,"image":{"id":"1*iPa136b1cGEO7lvoXg6uHQ@2x.jpeg","originalWidth":6016,"originalHeight":4016},"name":"Programming","description":"The good, the bad, the buggy.","relatedTopics":[],"visibility":1,"relatedTags":[],"relatedTopicIds":[],"seoTitle":"Programming News and Articles — Medium","type":"Topic"}]},"coverless":true,"slug":"why-nullable-types","translationSourcePostId":"","translationSourceCreatorId":"","isApprovedTranslation":false,"inResponseToPostId":"","inResponseToRemovedAt":0,"isTitleSynthesized":false,"allowResponses":true,"importedUrl":"","importedPublishedAt":0,"visibility":0,"uniqueSlug":"why-nullable-types-7dd93c28c87a","previewContent":{"bodyModel":{"paragraphs":[{"name":"previewImage","type":4,"text":"","layout":10,"metadata":{"id":"1*ihpy1Ngzg7SczCKkuh_WhQ.jpeg","originalWidth":3000,"originalHeight":2250,"isFeatured":true,"alt":"A photo of an all-white jigsaw puzzle with one piece missing, revealing a black background."}},{"name":"previewTitle","type":3,"text":"Why nullable types?","alignment":1},{"name":"previewSubtitle","type":13,"text":"Null in Dart code indicates that a variable has no value, but some languages don’t…","alignment":1}],"sections":[{"startIndex":0}]},"isFullContent":false,"subtitle":"Null in Dart code indicates that a variable has no value, but some languages don’t allow null. Learn why both approaches work."},"license":0,"inResponseToMediaResourceId":"","canonicalUrl":"https://blog.dart.dev/why-nullable-types-7dd93c28c87a","approvedHomeCollectionId":"23738d481ce8","isNewsletter":false,"newsletterId":"","webCanonicalUrl":"https://blog.dart.dev/why-nullable-types-7dd93c28c87a","mediumUrl":"https://blog.dart.dev/why-nullable-types-7dd93c28c87a","migrationId":"","notifyFollowers":true,"notifyTwitter":false,"notifyFacebook":false,"responseHiddenOnParentPostAt":0,"isSeries":false,"isSubscriptionLocked":false,"seriesLastAppendedAt":0,"audioVersionDurationSec":0,"sequenceId":"","isEligibleForRevenue":false,"isBlockedFromHightower":false,"deletedAt":0,"lockedPostSource":0,"hightowerMinimumGuaranteeStartsAt":0,"hightowerMinimumGuaranteeEndsAt":0,"featureLockRequestAcceptedAt":0,"mongerRequestType":1,"layerCake":3,"socialTitle":"","socialDek":"","editorialPreviewTitle":"","editorialPreviewDek":"","curationEligibleAt":0,"primaryTopic":{"topicId":"decb52b64abf","slug":"programming","createdAt":1493934116328,"deletedAt":0,"image":{"id":"1*iPa136b1cGEO7lvoXg6uHQ@2x.jpeg","originalWidth":6016,"originalHeight":4016},"name":"Programming","description":"The good, the bad, the buggy.","relatedTopics":[],"visibility":1,"relatedTags":[],"relatedTopicIds":[],"seoTitle":"Programming News and Articles — Medium","type":"Topic"},"primaryTopicId":"decb52b64abf","isProxyPost":false,"proxyPostFaviconUrl":"","proxyPostProviderName":"","proxyPostType":0,"isSuspended":false,"isLimitedState":false,"seoTitle":"","previewContent2":{"bodyModel":{"paragraphs":[{"name":"f7d2","type":3,"text":"Why nullable types?","markups":[]},{"name":"f773","type":1,"text":"A few weeks ago, we announced Dart null safety beta, a major productivity feature intended to help you avoid null errors. Speaking of null values, in the /r/dart_lang subreddit a user recently asked:","markups":[{"type":3,"start":177,"end":198,"href":"https://www.reddit.com/r/dartlang/comments/jruhji/why_does_nnbd_dart_still_have_null/gbwi364/","title":"","rel":"","anchorType":0}]},{"name":"65b5","type":6,"text":"But why do we even still have/want null values? Why not get rid of it completely? I’m…","markups":[]}],"sections":[{"name":"2eb5","startIndex":0}]},"isFullContent":false,"subtitle":"Null in Dart code indicates that a variable has no value, but some languages don’t allow null. Learn why both approaches work."},"cardType":0,"isDistributionAlertDismissed":false,"isShortform":false,"shortformType":0,"responsesLocked":false,"isLockedResponse":false,"isPublishToEmail":false,"responseDistribution":0,"isMarkedPaywallOnly":false,"type":"Post"},"mentionedUsers":[],"collaborators":[],"hideMeter":false,"shareKey":"60d47dc94b97ea941662971ceef991ad","collectionUserRelations":[{"collectionId":"23738d481ce8","userId":"8b6a7f6f197d","role":"ADMIN"},{"collectionId":"4da7dfd21a33","userId":"8b6a7f6f197d","role":"WRITER"},{"collectionId":"24d8f4fa8912","userId":"8b6a7f6f197d","role":"WRITER"}],"mode":"canEdit","references":{"User":{"9e0692285f8b":{"userId":"9e0692285f8b","name":"Bob Nystrom","username":"munificentbob","createdAt":1470154715067,"imageId":"0*F3n6Gi_e0RL-D9dg.","backgroundImageId":"","bio":"","twitterScreenName":"","socialStats":{"userId":"9e0692285f8b","usersFollowedCount":11,"usersFollowedByCount":382,"type":"SocialStats"},"social":{"userId":"8b6a7f6f197d","targetUserId":"9e0692285f8b","isFollowing":true,"isTwitterFollowing":false,"isFacebookFollowing":false,"isMediumFollowing":true,"type":"Social"},"allowNotes":1,"mediumMemberAt":0,"isWriterProgramEnrolled":true,"isSuspended":false,"isMembershipTrialEligible":true,"facebookDisplayName":"","optInToIceland":true,"hasCompletedProfile":false,"userDismissableFlags":[2,53,56,58],"hasSeenIcelandOnboarding":false,"postSubscribeMembershipUpsellShownAt":0,"languageCode":"en-us","type":"User"}},"Collection":{"23738d481ce8":{"id":"23738d481ce8","name":"Dart","slug":"dartlang","tags":["MOBILE APP DEVELOPMENT","WEB DEVELOPMENT","DART","PROGRAMMING LANGUAGES","SOFTWARE DEVELOPMENT"],"creatorId":"a6d788faa5e5","description":"Dart is an approachable, portable, and productive language for high-quality apps on any platform. Learn more at https://dart.dev.","shortDescription":"Dart is an approachable, portable, and productive language…","image":{"imageId":"1*uWy1Ajpd0oTUQBO9WBHoQg@2x.png","filter":"","backgroundSize":"","originalWidth":1001,"originalHeight":1001,"strategy":"resample","height":0,"width":0},"metadata":{"followerCount":14031,"activeAt":1762974121956},"virtuals":{"permissions":{"canPublish":true,"canPublishAll":true,"canRepublish":true,"canRemove":true,"canManageAll":true,"canSubmit":true,"canEditPosts":true,"canAddWriters":true,"canViewStats":true,"canSendNewsletter":true,"canViewLockedPosts":true,"canViewCloaked":true,"canEditOwnPosts":true,"canBeAssignedAuthor":true,"canEnrollInHightower":false,"canLockPostsForMediumMembers":false,"canLockOwnPostsForMediumMembers":false,"canViewNewsletterV2Stats":true,"canCreateNewsletterV3":true},"isSubscribed":true,"isEnrolledInHightower":false,"isEligibleForHightower":false,"isSubscribedToCollectionEmails":false,"isMuted":false,"canToggleEmail":false,"isWriter":false},"logo":{"imageId":"1*NRb7RFVWJQFzY47j3v4U7Q.png","filter":"","backgroundSize":"","originalWidth":400,"originalHeight":154,"strategy":"resample","height":0,"width":0},"twitterUsername":"dart_lang","publicEmail":"medium@dartlang.org","domain":"blog.dart.dev","sections":[{"type":2,"collectionHeaderMetadata":{"title":"Dart","description":"An approachable, portable, and productive language for high-quality apps on any platform","backgroundImage":{},"logoImage":{"id":"1*knHF_qpxdtS8h0Z8EeqowA@2x.png","originalWidth":1080,"originalHeight":1080,"alt":"Dart"},"alignment":2,"layout":5}},{"type":1,"postListMetadata":{"source":1,"layout":4,"number":7,"postIds":[]}},{"type":1,"postListMetadata":{"source":1,"layout":5,"number":15,"postIds":[]}}],"tintColor":"#FF042B59","lightText":true,"favicon":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"colorPalette":{"defaultBackgroundSpectrum":{"colorPoints":[{"color":"#FF6588BA","point":0},{"color":"#FF607EAB","point":0.1},{"color":"#FF59759C","point":0.2},{"color":"#FF536B8E","point":0.3},{"color":"#FF4C617F","point":0.4},{"color":"#FF445670","point":0.5},{"color":"#FF3D4B61","point":0.6},{"color":"#FF344052","point":0.7},{"color":"#FF2B3442","point":0.8},{"color":"#FF212832","point":0.9},{"color":"#FF161A22","point":1}],"backgroundColor":"#FFFFFFFF"},"tintBackgroundSpectrum":{"colorPoints":[{"color":"#FF042B59","point":0},{"color":"#FF294871","point":0.1},{"color":"#FF456087","point":0.2},{"color":"#FF5F779B","point":0.3},{"color":"#FF788DAD","point":0.4},{"color":"#FF8FA2BF","point":0.5},{"color":"#FFA5B6CF","point":0.6},{"color":"#FFBBC9DF","point":0.7},{"color":"#FFD1DCEE","point":0.8},{"color":"#FFE6EEFC","point":0.9},{"color":"#FFFBFFFF","point":1}],"backgroundColor":"#FF042B59"},"highlightSpectrum":{"colorPoints":[{"color":"#FFECF3FF","point":0},{"color":"#FFE9F2FF","point":0.1},{"color":"#FFE5F0FF","point":0.2},{"color":"#FFE2EFFF","point":0.3},{"color":"#FFDEEDFF","point":0.4},{"color":"#FFDBEBFF","point":0.5},{"color":"#FFD7EAFF","point":0.6},{"color":"#FFD3E8FF","point":0.7},{"color":"#FFCFE6FF","point":0.8},{"color":"#FFCBE5FF","point":0.9},{"color":"#FFC8E3FF","point":1}],"backgroundColor":"#FFFFFFFF"},"darkBackgroundSpectrum":{"colorPoints":[{"color":"#FF7DA0D3","point":0},{"color":"#FF89A9D8","point":0.1},{"color":"#FF94B1DC","point":0.2},{"color":"#FFA0B9E0","point":0.3},{"color":"#FFABC1E3","point":0.4},{"color":"#FFB6C9E7","point":0.5},{"color":"#FFC0D1EB","point":0.6},{"color":"#FFCBD8EF","point":0.7},{"color":"#FFD5E0F2","point":0.8},{"color":"#FFE0E7F6","point":0.9},{"color":"#FFEAEFFA","point":1}],"backgroundColor":"#FF000000"}},"navItems":[{"type":1,"title":"Announcements","tagSlug":"announcements","url":"https://blog.dart.dev/tagged/announcements","source":"tagSlug"},{"type":5,"title":"Archive","url":"https://blog.dart.dev/archive"},{"type":3,"title":"dart.dev","url":"https://dart.dev"}],"colorBehavior":2,"collectionFeatures":[25],"ampLogo":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"header":{"title":"Dart","description":"An approachable, portable, and productive language for high-quality apps on any platform","backgroundImage":{},"logoImage":{"id":"1*knHF_qpxdtS8h0Z8EeqowA@2x.png","originalWidth":1080,"originalHeight":1080,"alt":"Dart"},"alignment":2,"layout":5},"subscriberCount":14031,"tagline":"Dart is a client-optimized language for fast apps on any platform.","isOptedIntoAurora":false,"isCurationAllowedByDefault":false,"polarisCoverImage":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"ptsQualifiedAt":1616092887098,"type":"Collection"}},"Social":{"9e0692285f8b":{"userId":"8b6a7f6f197d","targetUserId":"9e0692285f8b","isFollowing":true,"isTwitterFollowing":false,"isFacebookFollowing":false,"isMediumFollowing":true,"type":"Social"}},"SocialStats":{"9e0692285f8b":{"userId":"9e0692285f8b","usersFollowedCount":11,"usersFollowedByCount":382,"type":"SocialStats"}}}},"v":3,"b":"20260130-1012-root"}