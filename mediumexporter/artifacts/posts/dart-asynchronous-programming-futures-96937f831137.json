{"success":true,"payload":{"value":{"id":"96937f831137","versionId":"d75bde2a2096","creatorId":"fe67f3a27347","homeCollectionId":"23738d481ce8","title":"Dart asynchronous programming: Futures","detectedLanguage":"en","latestVersion":"d75bde2a2096","latestPublishedVersion":"d75bde2a2096","hasUnpublishedEdits":false,"latestRev":2311,"createdAt":1566507369936,"updatedAt":1639255469922,"acceptedAt":0,"firstPublishedAt":1568815263753,"latestPublishedAt":1568815263753,"vote":false,"experimentalCss":"","displayAuthor":"","content":{"subtitle":"One of the most basic APIs that Dart has for asynchronous programming is futures — objects of type Future. For the most part, Dart’s…","bodyModel":{"paragraphs":[{"name":"6334","type":3,"text":"Dart asynchronous programming: Futures","markups":[]},{"name":"66da","type":4,"text":"Many asynchronous Dart APIs return futures.","markups":[],"layout":1,"metadata":{"id":"1*G4044qvxp8yBjmGVHVLEyw.png","originalWidth":394,"originalHeight":55}},{"name":"fd52","type":1,"text":"One of the most basic APIs that Dart has for asynchronous programming is futures — objects of type Future. For the most part, Dart’s futures are very similar to the future or promise APIs found in other languages.","markups":[{"type":10,"start":99,"end":105},{"type":3,"start":99,"end":105,"href":"https://api.dartlang.org/stable/dart-async/Future-class.html","title":"","rel":"noopener","anchorType":0},{"type":2,"start":73,"end":83},{"type":2,"start":165,"end":171},{"type":2,"start":175,"end":182}]},{"name":"ef7e","type":1,"text":"This article discusses the concepts behind Dart futures and tells you how to use the Future API. It also discusses the Flutter FutureBuilder widget, which helps you update a Flutter UI asynchronously, based on the state of a future.","markups":[{"type":10,"start":85,"end":91},{"type":10,"start":127,"end":140}]},{"name":"ccc5","type":1,"text":"Thanks to Dart language features like async-await, you might never need to use the Future API directly. But you’re almost certain to encounter futures in your Dart code. And you might want to create futures or read code that uses the Future API.","markups":[{"type":10,"start":83,"end":89},{"type":10,"start":234,"end":240},{"type":3,"start":38,"end":49,"href":"https://dart.dev/codelabs/async-await","title":"","rel":"noopener","anchorType":0},{"type":2,"start":192,"end":198},{"type":2,"start":210,"end":214}]},{"name":"1b4d","type":6,"text":"This article is the second one based on the Flutter in Focus video series Asynchronous Programming in Dart. The first article, Isolates and event loops, covered the foundations of Dart’s support for background work.","markups":[{"type":3,"start":127,"end":151,"href":"https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a","title":"","rel":"","anchorType":0},{"type":2,"start":44,"end":60},{"type":2,"start":74,"end":106}]},{"name":"7c66","type":6,"text":"If you prefer to learn by watching or listening, everything in this article is covered in the following video.","markups":[{"type":2,"start":109,"end":110}]},{"name":"f5f6","type":11,"text":"Andrew Brogdon’s video is the inspiration for this article.","markups":[],"layout":1,"iframe":{"mediaResourceId":"8b6cf4ee42282247c713fd0c0da5298c","iframeWidth":854,"iframeHeight":480,"thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fi.ytimg.com%2Fvi%2FOTS-ap9_aXc%2Fhqdefault.jpg&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"4097","type":1,"text":"You can think of futures as little gift boxes for data. Somebody hands you one of these gift boxes, which starts off closed. A little while later the box pops open, and inside there’s either a value or an error.","markups":[]},{"name":"537b","type":1,"text":"So a future can be in one of 3 states:","markups":[]},{"name":"1902","type":10,"text":"Uncompleted: The gift box is closed.","markups":[{"type":1,"start":0,"end":12},{"type":2,"start":35,"end":36}]},{"name":"614a","type":10,"text":"Completed with a value: The box is open, and your gift (data) is ready.","markups":[{"type":1,"start":0,"end":23}]},{"name":"127d","type":10,"text":"Completed with an error: The box is open, but something went wrong.","markups":[{"type":1,"start":0,"end":24}]},{"name":"a29f","type":1,"text":"Most of the code you’re about to see revolves around dealing with these three states. You receive a future, and you need to decide what to do until the box opens, what to do when it opens with a value, and what to do if there’s an error. You’ll see that 1–2–3 pattern a lot.","markups":[]},{"name":"ad41","type":4,"text":"The 3 states of a future","markups":[],"layout":1,"metadata":{"id":"1*UD63BMoIBmzoA6jo3LjCCg.png","originalWidth":584,"originalHeight":414,"isFeatured":true}},{"name":"8c3a","type":1,"text":"You might remember the event loop (pictured below) from our article about the Dart event loop. A good thing to know about futures is that they’re really just an API built to make using the event loop easier.","markups":[{"type":3,"start":60,"end":93,"href":"https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a","title":"","rel":"","anchorType":0}]},{"name":"deda","type":4,"text":"The Dart event loop processes one event at a time.","markups":[],"layout":1,"metadata":{"id":"0*xlxALlxjazVifRep.png","originalWidth":624,"originalHeight":332}},{"name":"586b","type":1,"text":"The Dart code you write is executed by a single thread. The whole time your app is running, that one little thread just keeps going around and around, picking up events from the event queue and processing them.","markups":[]},{"name":"bfe1","type":1,"text":"Say you have some code for a download button (implemented below as a RaisedButton). The user taps, and your button starts downloading a picture.","markups":[{"type":10,"start":69,"end":81}]},{"name":"60fc","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"d117128d4388430b3f161a8970cc27a0"}},{"name":"c88f","type":1,"text":"First the tap event occurs. The event loop gets the event, and it calls your tap handler (which you set using the onPressed parameter to the RaisedButton constructor). Your handler uses the http library to make a request (http.get()), and it gets a future in return (myFuture).","markups":[{"type":10,"start":114,"end":123},{"type":10,"start":141,"end":153},{"type":10,"start":222,"end":232},{"type":10,"start":267,"end":275}]},{"name":"59cb","type":1,"text":"So now you’ve got your little box, myFuture. It starts off closed. To register a callback for when it opens, you use then().","markups":[{"type":10,"start":35,"end":43},{"type":10,"start":117,"end":123}]},{"name":"d8c4","type":1,"text":"Once you have your gift box, you wait. Maybe some other events come in, the user does some stuff, and your little box just sits there while the event loop keeps going around.","markups":[]},{"name":"f7ab","type":1,"text":"Eventually, data for the image is downloaded, and the http library says, “Great! I’ve got this future right here.” It puts the data in the box and pops it open, which triggers your callback.","markups":[]},{"name":"95f5","type":1,"text":"Now that little piece of code you handed to then() executes, and it displays the image.","markups":[{"type":10,"start":44,"end":50}]},{"name":"9df8","type":1,"text":"Throughout that process, your code never had to touch the event loop directly. It didn’t matter what else was going on, or what other events came in. All you needed to do was get the future from the http library, and then say what to do when the future completed.","markups":[]},{"name":"1f0c","type":1,"text":"In real code, you’d also take care of errors. We’ll show you how to do that a little later.","markups":[]},{"name":"814a","type":1,"text":"Let’s take a closer look at the Future API, some of which you just saw in use.","markups":[{"type":10,"start":32,"end":38}]},{"name":"8004","type":1,"text":"OK, first question: how do you get an instance of a Future? Most of the time, you don’t create futures directly. That’s because many of the common asynchronous programming tasks already have libraries that generate futures for you.","markups":[{"type":10,"start":52,"end":58}]},{"name":"878f","type":1,"text":"For example, network communication returns a future:","markups":[]},{"name":"656d","type":8,"text":"final myFuture = http.get('http://example.com');","markups":[]},{"name":"89d9","type":1,"text":"Getting access to shared preferences also returns a future:","markups":[]},{"name":"45ef","type":8,"text":"final myFuture = SharedPreferences.getInstance();","markups":[]},{"name":"1b4f","type":1,"text":"But you can also use Future constructors to create futures.","markups":[{"type":10,"start":21,"end":27}]},{"name":"2ad0","type":3,"text":"Future constructors","markups":[]},{"name":"edb2","type":1,"text":"The simplest constructor is Future(), which takes a function and returns a future that matches the function’s return type. Later the function runs asynchronously, and the future completes with the function’s return value. Here’s an example of using Future():","markups":[{"type":10,"start":28,"end":36},{"type":10,"start":249,"end":257},{"type":3,"start":28,"end":36,"href":"https://api.dartlang.org/stable/dart-async/Future/Future.html","title":"","rel":"","anchorType":0}]},{"name":"009c","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"e27a259c2540f79cd29b55eb1f790e92","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"b444","type":1,"text":"Let’s add a couple of print statements to make the asynchronous part clear:","markups":[]},{"name":"2b9e","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"9f21b9217f909011fb1789ff165ae78a","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"a1dc","type":1,"text":"If you run that code in DartPad (dartpad.dev), the entire main function finishes before the function given to the Future() constructor. That’s because the Future() constructor just returns an uncompleted future at first. It says, “Here’s this box. You hold onto that for now, and later I’ll go run your function and put some data in there for you.” Here’s the output of the preceding code:","markups":[{"type":10,"start":114,"end":122},{"type":10,"start":155,"end":163},{"type":3,"start":33,"end":44,"href":"https://dartpad.dev","title":"","rel":"noopener","anchorType":0}]},{"name":"85c8","type":8,"text":"Done with main().\nCreating the future.","markups":[]},{"name":"fbe6","type":1,"text":"Another constructor, Future.value(), is handy when you already know the value for the future. This constructor is useful when you’re building services that use caching. Sometimes you already have the value you need, so you can pop it right in there:","markups":[{"type":10,"start":21,"end":35},{"type":3,"start":21,"end":35,"href":"https://api.dartlang.org/stable/dart-async/Future/Future.value.html","title":"","rel":"","anchorType":0}]},{"name":"f762","type":8,"text":"final myFuture = Future.value(12);","markups":[]},{"name":"9ecb","type":1,"text":"The Future.value() constructor has a counterpart for completing with an error. It’s called Future.error(), and it works essentially the same way, but takes an error object and an optional stacktrace:","markups":[{"type":10,"start":4,"end":18},{"type":10,"start":91,"end":105},{"type":3,"start":91,"end":105,"href":"https://api.dartlang.org/stable/dart-async/Future/Future.error.html","title":"","rel":"","anchorType":0}]},{"name":"f00b","type":8,"text":"final myFuture = Future.error(ArgumentError.notNull('input'));","markups":[]},{"name":"27ab","type":1,"text":"The handiest future constructor is probably Future.delayed(). It works just like Future(), except that it waits for a specified length of time before running the function and completing the future.","markups":[{"type":10,"start":44,"end":60},{"type":10,"start":81,"end":89},{"type":3,"start":44,"end":60,"href":"https://api.dartlang.org/stable/dart-async/Future/Future.delayed.html","title":"","rel":"","anchorType":0}]},{"name":"8827","type":1,"text":"One way to use Future.delayed() is when you’re creating mock network services for testing. If you need to make sure your loading spinner displays correctly, a delayed future is your friend.","markups":[{"type":10,"start":15,"end":31}]},{"name":"bb07","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"5b436044f5e815fb6fae7547737bdefa","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"bf0c","type":3,"text":"Using futures","markups":[]},{"name":"9c55","type":1,"text":"Now that you know where futures come from, let’s talk about how to use them. As we mentioned earlier, using a future is mostly about accounting for the three states it can be in: uncompleted, completed with a value, or completed with an error.","markups":[]},{"name":"e0c0","type":1,"text":"The following code uses Future.delayed() to create a future that completes after 3 seconds with a value of 100.","markups":[{"type":10,"start":24,"end":40}]},{"name":"25fe","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"ab4bcdad8dbe7a1b5424537f1ae494c8","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"0a55","type":1,"text":"When this code executes, main() runs from top to bottom, creating the future and printing “Waiting for a value…” That whole time, the future is uncompleted. It doesn’t complete for another 3 seconds.","markups":[{"type":10,"start":25,"end":31}]},{"name":"9be0","type":1,"text":"To use the completed value, you can use then(). That’s an instance method on each future that you can use to register a callback for when the future completes with a value. You give it a function that takes a single parameter matching the type of the future. Once the future completes with a value, your function is called with that value.","markups":[{"type":10,"start":40,"end":46},{"type":3,"start":40,"end":46,"href":"https://api.dartlang.org/stable/dart-async/Future/then.html","title":"","rel":"","anchorType":0},{"type":2,"start":3,"end":6}]},{"name":"802a","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"f988acb78c06b4f422eb91fc8a37698c","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"0a8b","type":1,"text":"Here’s the output of the preceding code:","markups":[]},{"name":"4ea6","type":8,"text":"Waiting for a value... (3 seconds pass until callback executes)\nThe value is 100.","markups":[{"type":2,"start":23,"end":63}]},{"name":"dcf9","type":1,"text":"In addition to executing your code, then() returns a future of its own, matching the return value of whatever function you give it. So if you need to make a couple of asynchronous calls, you can chain them together even if they have different return types.","markups":[{"type":10,"start":36,"end":42}]},{"name":"2bf9","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"5a6e0a91c6b445d288a0000afcca55b3","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"7c6e","type":1,"text":"Back to our first example, what happens if that initial future doesn’t complete with a value — what if it completes with an error? The then() method expects a value. You need a way to register another callback in case of an error.","markups":[{"type":10,"start":135,"end":141}]},{"name":"df70","type":1,"text":"The answer is to use catchError(). It works just like then(), except that it takes an error instead of a value, and it executes if the future completes with an error. Just like then(), the catchError() method returns a future of its own, so you can build a whole chain of then() and catchError()methods that wait on one another.","markups":[{"type":10,"start":21,"end":33},{"type":10,"start":54,"end":60},{"type":10,"start":177,"end":183},{"type":10,"start":189,"end":201},{"type":10,"start":272,"end":278},{"type":10,"start":283,"end":295},{"type":3,"start":21,"end":33,"href":"https://api.dartlang.org/stable/dart-async/Future/catchError.html","title":"","rel":"","anchorType":0}]},{"name":"62ab","type":6,"text":"Note: You don’t need to call then() or catchError() if you use the async-await language feature. Instead, you await the completed value, and you use try-catch-finally to handle errors. For details, see the Dart language tour’s asynchrony support section.","markups":[{"type":10,"start":29,"end":35},{"type":10,"start":39,"end":51},{"type":3,"start":227,"end":253,"href":"https://dart.dev/guides/language/language-tour#asynchrony-support","title":"","rel":"","anchorType":0},{"type":1,"start":0,"end":6}]},{"name":"4f1a","type":1,"text":"Here’s an example of using catchError() to handle the case where a future completes with an error:","markups":[{"type":10,"start":27,"end":39}]},{"name":"3e85","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"db525189bde74549870e219535581770","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"2828","type":1,"text":"You can even give catchError() a test function to check the error before invoking the callback. You can have multiple catchError() functions this way, each one checking for a different kind of error. Here’s an example of specifying a test function, using the optional test parameter to catchError():","markups":[{"type":10,"start":18,"end":30},{"type":10,"start":118,"end":130},{"type":10,"start":268,"end":272},{"type":10,"start":286,"end":298}]},{"name":"08db","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"fe5017c41b1935118b8bac05a0e78bb0","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"5c68","type":1,"text":"Now that you’ve gotten this far, hopefully you can see how the three states of a future are often reflected by the structure of the code. There are three blocks in the preceding example:","markups":[]},{"name":"8d33","type":10,"text":"The first block creates an uncompleted future.","markups":[]},{"name":"0608","type":10,"text":"Then there’s a function to call if the future completes with a value.","markups":[]},{"name":"106d","type":10,"text":"Then there’s another function to call if the future completes with an error.","markups":[]},{"name":"db93","type":1,"text":"There’s one more method you might want to use: whenComplete(). You can use it to execute a function when the future is completed, no matter whether it’s with a value or an error.","markups":[{"type":10,"start":47,"end":61},{"type":3,"start":47,"end":61,"href":"https://api.dartlang.org/stable/dart-async/Future/whenComplete.html","title":"","rel":"","anchorType":0}]},{"name":"4a79","type":1,"text":"It’s kind of like the finally block in a try-catch-finally. There’s code executed if everything goes right, code for an error, and code that runs no matter what.","markups":[{"type":2,"start":22,"end":29}]},{"name":"8190","type":3,"text":"Using futures in Flutter","markups":[]},{"name":"493f","type":1,"text":"So that’s how you create futures, and a bit about how you can use their values. Now let’s talk putting them to work in Flutter.","markups":[]},{"name":"a0d5","type":1,"text":"Say you have a network service that’s going to return some JSON data, and you want to display that data. You could create a StatefulWidget that creates the future, checks for completion or error, calls setState(), and generally handles all the wiring manually.","markups":[{"type":10,"start":124,"end":138},{"type":10,"start":202,"end":212},{"type":3,"start":124,"end":138,"href":"https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html","title":"","rel":"","anchorType":0}]},{"name":"b281","type":1,"text":"Or you can use FutureBuilder. It’s a widget that comes with the Flutter SDK. You give it a future and a builder function, and it automatically rebuilds its children when the future completes.","markups":[{"type":10,"start":15,"end":28},{"type":3,"start":15,"end":28,"href":"https://api.flutter.dev/flutter/widgets/FutureBuilder-class.html","title":"","rel":"","anchorType":0}]},{"name":"26a0","type":1,"text":"The FutureBuilder widget works by calling its builder function, which takes a context and a snapshot of the current state of the future.","markups":[{"type":10,"start":4,"end":17}]},{"name":"0434","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"d4d061e92c50ac8668b523456fd22ca3","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"08ac","type":1,"text":"You can check the snapshot to see whether the future completed with an error:","markups":[]},{"name":"ef58","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"ec30bac06a737610df8007c8a790080b","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"4fdd","type":1,"text":"Otherwise you can check the hasData property to see if it completed with a value:","markups":[{"type":10,"start":28,"end":35}]},{"name":"f3c6","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"822acd24d8ce82d850f9478bfc202de2","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"7445","type":1,"text":"If neither hasError nor hasData is true, then you know you’re still waiting, and you can output something for that as well.","markups":[{"type":10,"start":11,"end":19},{"type":10,"start":24,"end":31}]},{"name":"7c90","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"2dcbbe30464eec59149d857caf678ea8","thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fgithub.githubassets.com%2Fimages%2Fmodules%2Fgists%2Fgist-og-image.png&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"eade","type":1,"text":"Even in Flutter code, you can see how those three states keep popping up: uncompleted, completed with value, and completed with error.","markups":[]},{"name":"13a7","type":3,"text":"Summary","markups":[]},{"name":"2ecc","type":1,"text":"This article talked about what futures represent and how you can use the Future and FutureBuilder APIs to create futures and use their completed values.","markups":[{"type":10,"start":73,"end":79},{"type":10,"start":84,"end":97}]},{"name":"c281","type":1,"text":"If you’d like to learn more about using futures—with the option of using runnable examples and interactive exercises to test your understanding—check out the asynchronous codelab on futures, async, and await.","markups":[{"type":3,"start":182,"end":207,"href":"https://dart.dev/codelabs/async-await","title":"","rel":"","anchorType":0}]},{"name":"d78d","type":1,"text":"Or go on to the next video in the Asynchronous Programming in Dart series. It talks about streams, which are a lot like futures in that they can provide either values or errors. But where futures just give you one result and stop, streams just keep right on going.","markups":[{"type":2,"start":34,"end":67},{"type":2,"start":90,"end":97}]},{"name":"0e3d","type":11,"text":"","markups":[],"layout":1,"iframe":{"mediaResourceId":"19f7572c0ed7e65b2b45fc00703972c6","iframeWidth":854,"iframeHeight":480,"thumbnailUrl":"https://i.embed.ly/1/image?url=https%3A%2F%2Fi.ytimg.com%2Fvi%2FnQBpOIHE4eE%2Fhqdefault.jpg&key=a19fcc184b9711e1b4764040d3dc5c07"}},{"name":"1d0e","type":1,"text":"Big thanks to Andrew Brogdon, who created the video that this article is based on.","markups":[{"type":2,"start":0,"end":82}]}],"sections":[{"name":"5c18","startIndex":0},{"name":"bd72","startIndex":8},{"name":"457e","startIndex":27}]},"postDisplay":{"coverless":true}},"virtuals":{"statusForCollection":"APPROVED","allowNotes":true,"previewImage":{"imageId":"1*UD63BMoIBmzoA6jo3LjCCg.png","filter":"","backgroundSize":"","originalWidth":584,"originalHeight":414,"strategy":"resample","height":0,"width":0},"wordCount":1880,"imageCount":3,"readingTime":7.6443396226415095,"subtitle":"One of the most basic APIs that Dart has for asynchronous programming is futures — objects of type Future. For the most part, Dart’s…","userPostRelation":{"userId":"8b6a7f6f197d","postId":"96937f831137","readAt":0,"readLaterAddedAt":0,"votedAt":0,"collaboratorAddedAt":0,"notesAddedAt":0,"subscribedAt":0,"lastReadSectionName":"","lastReadVersionId":"","lastReadAt":0,"lastReadParagraphName":"","lastReadPercentage":0,"viewedAt":0,"presentedCountInResponseManagement":0,"clapCount":0,"seriesUpdateNotifsOptedInAt":0,"queuedAt":0,"seriesFirstViewedAt":0,"presentedCountInStream":2,"seriesLastViewedAt":0,"audioProgressSec":0},"publishedInCount":1,"usersBySocialRecommends":[],"noIndex":false,"recommends":143,"isBookmarked":false,"tags":[{"slug":"programming","name":"Programming","postCount":400575,"metadata":{"postCount":400575,"coverImage":{"id":"0*7x-LQAg1xBmi-L1p","originalWidth":1800,"originalHeight":1169,"alt":"Screenshot of a desktop with the Cursor application open"}},"type":"Tag"},{"slug":"programming-languages","name":"Programming Languages","postCount":14860,"metadata":{"postCount":14860,"coverImage":{"id":"1*sD09-ccQCGBvaNKvzpbTbw.png","originalWidth":1690,"originalHeight":964,"isFeatured":true}},"type":"Tag"},{"slug":"dartlang","name":"Dartlang","postCount":921,"metadata":{"postCount":921,"coverImage":{"id":"1*HNqQFQ2hdhAgjew1pIMqXA.png","originalWidth":2752,"originalHeight":1536,"isFeatured":true}},"type":"Tag"},{"slug":"asynchronous-programming","name":"Asynchronous Programming","postCount":2129,"metadata":{"postCount":2129,"coverImage":{"id":"1*x4eT5WcXZINAKinGVXySuw.png","originalWidth":1280,"originalHeight":720,"isFeatured":true}},"type":"Tag"},{"slug":"flutter","name":"Flutter","postCount":43303,"metadata":{"postCount":43303,"coverImage":{"id":"1*8zlpgRA1agpvWp-OiFKlJw.png","originalWidth":1536,"originalHeight":1024,"isFeatured":true}},"type":"Tag"}],"socialRecommendsCount":0,"responsesCreatedCount":3,"links":{"entries":[{"url":"https://dart.dev/codelabs/async-await","alts":[],"httpStatus":200},{"url":"https://dart.dev/guides/language/language-tour#asynchrony-support","alts":[],"httpStatus":200},{"url":"https://api.flutter.dev/flutter/widgets/FutureBuilder-class.html","alts":[],"httpStatus":200},{"url":"https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html","alts":[],"httpStatus":200},{"url":"https://api.dartlang.org/stable/dart-async/Future/Future.value.html","alts":[],"httpStatus":200},{"url":"https://api.dartlang.org/stable/dart-async/Future/then.html","alts":[],"httpStatus":200},{"url":"https://api.dartlang.org/stable/dart-async/Future-class.html","alts":[],"httpStatus":200},{"url":"https://api.dartlang.org/stable/dart-async/Future/catchError.html","alts":[],"httpStatus":200},{"url":"https://api.dartlang.org/stable/dart-async/Future/Future.delayed.html","alts":[],"httpStatus":200},{"url":"https://api.dartlang.org/stable/dart-async/Future/whenComplete.html","alts":[],"httpStatus":200},{"url":"https://api.dartlang.org/stable/dart-async/Future/Future.html","alts":[],"httpStatus":200},{"url":"https://dartpad.dev","alts":[],"httpStatus":200},{"url":"https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a","alts":[{"type":2,"url":"medium://p/bffc3e296a6a"},{"type":3,"url":"medium://p/bffc3e296a6a"}],"httpStatus":200},{"url":"https://api.dartlang.org/stable/dart-async/Future/Future.error.html","alts":[],"httpStatus":200}],"version":"0.3","generatedAt":1568815264923},"isLockedPreviewOnly":false,"metaDescription":"","totalClapCount":710,"sectionCount":3,"readingList":0,"topics":[{"topicId":"decb52b64abf","slug":"programming","createdAt":1493934116328,"deletedAt":0,"image":{"id":"1*iPa136b1cGEO7lvoXg6uHQ@2x.jpeg","originalWidth":6016,"originalHeight":4016},"name":"Programming","description":"The good, the bad, the buggy.","relatedTopics":[],"visibility":1,"relatedTags":[],"relatedTopicIds":[],"seoTitle":"Programming News and Articles — Medium","type":"Topic"}]},"coverless":true,"slug":"dart-asynchronous-programming-futures","translationSourcePostId":"","translationSourceCreatorId":"","isApprovedTranslation":false,"inResponseToPostId":"","inResponseToRemovedAt":0,"isTitleSynthesized":false,"allowResponses":true,"importedUrl":"","importedPublishedAt":0,"visibility":0,"uniqueSlug":"dart-asynchronous-programming-futures-96937f831137","previewContent":{"bodyModel":{"paragraphs":[{"name":"previewImage","type":4,"text":"","layout":10,"metadata":{"id":"1*UD63BMoIBmzoA6jo3LjCCg.png","originalWidth":584,"originalHeight":414,"isFeatured":true}},{"name":"6334","type":3,"text":"Dart asynchronous programming: Futures","markups":[],"alignment":1},{"name":"fd52","type":1,"text":"One of the most basic APIs that Dart has for asynchronous programming is futures — objects…","markups":[{"type":2,"start":73,"end":83}],"alignment":1}],"sections":[{"startIndex":0}]},"isFullContent":false,"subtitle":"One of the most basic APIs that Dart has for asynchronous programming is futures — objects of type Future. For the most part, Dart’s…"},"license":0,"inResponseToMediaResourceId":"","canonicalUrl":"https://blog.dart.dev/dart-asynchronous-programming-futures-96937f831137","approvedHomeCollectionId":"23738d481ce8","isNewsletter":false,"newsletterId":"","webCanonicalUrl":"https://blog.dart.dev/dart-asynchronous-programming-futures-96937f831137","mediumUrl":"https://blog.dart.dev/dart-asynchronous-programming-futures-96937f831137","migrationId":"","notifyFollowers":true,"notifyTwitter":false,"notifyFacebook":false,"responseHiddenOnParentPostAt":0,"isSeries":false,"isSubscriptionLocked":false,"seriesLastAppendedAt":0,"audioVersionDurationSec":0,"sequenceId":"","isEligibleForRevenue":false,"isBlockedFromHightower":false,"deletedAt":0,"lockedPostSource":0,"hightowerMinimumGuaranteeStartsAt":0,"hightowerMinimumGuaranteeEndsAt":0,"featureLockRequestAcceptedAt":0,"mongerRequestType":1,"layerCake":0,"socialTitle":"","socialDek":"","editorialPreviewTitle":"","editorialPreviewDek":"","curationEligibleAt":0,"isProxyPost":false,"proxyPostFaviconUrl":"","proxyPostProviderName":"","proxyPostType":0,"isSuspended":false,"isLimitedState":false,"seoTitle":"","previewContent2":{"bodyModel":{"paragraphs":[{"name":"6334","type":3,"text":"Dart asynchronous programming: Futures","markups":[]},{"name":"66da","type":4,"text":"Many asynchronous Dart APIs return futures.","markups":[],"layout":1,"metadata":{"id":"1*G4044qvxp8yBjmGVHVLEyw.png","originalWidth":394,"originalHeight":55}},{"name":"fd52","type":1,"text":"One of the most basic APIs that Dart has for asynchronous programming is futures — objects of type Future. For the most part, Dart’s futures are very similar to the future or promise APIs found in other languages.","markups":[{"type":10,"start":99,"end":105},{"type":3,"start":99,"end":105,"href":"https://api.dartlang.org/stable/dart-async/Future-class.html","title":"","rel":"noopener","anchorType":0},{"type":2,"start":73,"end":83},{"type":2,"start":165,"end":171},{"type":2,"start":175,"end":182}]},{"name":"ef7e","type":1,"text":"This article discusses the concepts behind…","markups":[{"type":10,"start":85,"end":91},{"type":10,"start":127,"end":140}]}],"sections":[{"name":"5c18","startIndex":0}]},"isFullContent":false,"subtitle":"One of the most basic APIs that Dart has for asynchronous programming is futures — objects of type Future. For the most part, Dart’s…"},"cardType":0,"isDistributionAlertDismissed":false,"isShortform":false,"shortformType":0,"responsesLocked":false,"isLockedResponse":false,"isPublishToEmail":false,"responseDistribution":0,"isMarkedPaywallOnly":false,"type":"Post"},"mentionedUsers":[],"collaborators":[{"user":{"userId":"26a19a14addb","name":"Andrew Brogdon","username":"redbrogdon","createdAt":1515443572046,"imageId":"0*UfXdwppirgDYRNaj.","backgroundImageId":"","bio":"Engineer at Google, currently cranking out code for the Flutter developer relations team.","twitterScreenName":"","allowNotes":1,"mediumMemberAt":0,"isWriterProgramEnrolled":true,"isSuspended":false,"isMembershipTrialEligible":true,"facebookDisplayName":"","optInToIceland":true,"hasCompletedProfile":false,"userDismissableFlags":[2,8,10,12,46,53,58,59,61],"hasSeenIcelandOnboarding":false,"postSubscribeMembershipUpsellShownAt":0,"languageCode":"en-us","type":"User"},"state":"visible"}],"hideMeter":false,"shareKey":"3722c567cdf9e95bbd06b2127e89350a","collectionUserRelations":[{"collectionId":"23738d481ce8","userId":"8b6a7f6f197d","role":"ADMIN"},{"collectionId":"4da7dfd21a33","userId":"8b6a7f6f197d","role":"WRITER"},{"collectionId":"24d8f4fa8912","userId":"8b6a7f6f197d","role":"WRITER"}],"mode":"canEdit","references":{"User":{"fe67f3a27347":{"userId":"fe67f3a27347","name":"Kathy Walrath","username":"kathyw_39223","createdAt":1479149074481,"imageId":"0*OWxJ0V46ratF_z-r.","backgroundImageId":"","bio":"I write Dart docs! https://dart.dev","twitterScreenName":"","socialStats":{"userId":"fe67f3a27347","usersFollowedCount":19,"usersFollowedByCount":560,"type":"SocialStats"},"social":{"userId":"8b6a7f6f197d","targetUserId":"fe67f3a27347","type":"Social"},"allowNotes":1,"mediumMemberAt":0,"isWriterProgramEnrolled":true,"isSuspended":false,"isMembershipTrialEligible":true,"facebookDisplayName":"","optInToIceland":true,"userFlags":[2],"hasCompletedProfile":false,"userDismissableFlags":[1,2,5,8,12],"hasSeenIcelandOnboarding":false,"postSubscribeMembershipUpsellShownAt":0,"languageCode":"en-us","type":"User"}},"Collection":{"23738d481ce8":{"id":"23738d481ce8","name":"Dart","slug":"dartlang","tags":["MOBILE APP DEVELOPMENT","WEB DEVELOPMENT","DART","PROGRAMMING LANGUAGES","SOFTWARE DEVELOPMENT"],"creatorId":"a6d788faa5e5","description":"Dart is an approachable, portable, and productive language for high-quality apps on any platform. Learn more at https://dart.dev.","shortDescription":"Dart is an approachable, portable, and productive language…","image":{"imageId":"1*uWy1Ajpd0oTUQBO9WBHoQg@2x.png","filter":"","backgroundSize":"","originalWidth":1001,"originalHeight":1001,"strategy":"resample","height":0,"width":0},"metadata":{"followerCount":14031,"activeAt":1762974121956},"virtuals":{"permissions":{"canPublish":true,"canPublishAll":true,"canRepublish":true,"canRemove":true,"canManageAll":true,"canSubmit":true,"canEditPosts":true,"canAddWriters":true,"canViewStats":true,"canSendNewsletter":true,"canViewLockedPosts":true,"canViewCloaked":true,"canEditOwnPosts":true,"canBeAssignedAuthor":true,"canEnrollInHightower":false,"canLockPostsForMediumMembers":false,"canLockOwnPostsForMediumMembers":false,"canViewNewsletterV2Stats":true,"canCreateNewsletterV3":true},"isSubscribed":true,"isEnrolledInHightower":false,"isEligibleForHightower":false,"isSubscribedToCollectionEmails":false,"isMuted":false,"canToggleEmail":false,"isWriter":false},"logo":{"imageId":"1*NRb7RFVWJQFzY47j3v4U7Q.png","filter":"","backgroundSize":"","originalWidth":400,"originalHeight":154,"strategy":"resample","height":0,"width":0},"twitterUsername":"dart_lang","publicEmail":"medium@dartlang.org","domain":"blog.dart.dev","sections":[{"type":2,"collectionHeaderMetadata":{"title":"Dart","description":"An approachable, portable, and productive language for high-quality apps on any platform","backgroundImage":{},"logoImage":{"id":"1*knHF_qpxdtS8h0Z8EeqowA@2x.png","originalWidth":1080,"originalHeight":1080,"alt":"Dart"},"alignment":2,"layout":5}},{"type":1,"postListMetadata":{"source":1,"layout":4,"number":7,"postIds":[]}},{"type":1,"postListMetadata":{"source":1,"layout":5,"number":15,"postIds":[]}}],"tintColor":"#FF042B59","lightText":true,"favicon":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"colorPalette":{"defaultBackgroundSpectrum":{"colorPoints":[{"color":"#FF6588BA","point":0},{"color":"#FF607EAB","point":0.1},{"color":"#FF59759C","point":0.2},{"color":"#FF536B8E","point":0.3},{"color":"#FF4C617F","point":0.4},{"color":"#FF445670","point":0.5},{"color":"#FF3D4B61","point":0.6},{"color":"#FF344052","point":0.7},{"color":"#FF2B3442","point":0.8},{"color":"#FF212832","point":0.9},{"color":"#FF161A22","point":1}],"backgroundColor":"#FFFFFFFF"},"tintBackgroundSpectrum":{"colorPoints":[{"color":"#FF042B59","point":0},{"color":"#FF294871","point":0.1},{"color":"#FF456087","point":0.2},{"color":"#FF5F779B","point":0.3},{"color":"#FF788DAD","point":0.4},{"color":"#FF8FA2BF","point":0.5},{"color":"#FFA5B6CF","point":0.6},{"color":"#FFBBC9DF","point":0.7},{"color":"#FFD1DCEE","point":0.8},{"color":"#FFE6EEFC","point":0.9},{"color":"#FFFBFFFF","point":1}],"backgroundColor":"#FF042B59"},"highlightSpectrum":{"colorPoints":[{"color":"#FFECF3FF","point":0},{"color":"#FFE9F2FF","point":0.1},{"color":"#FFE5F0FF","point":0.2},{"color":"#FFE2EFFF","point":0.3},{"color":"#FFDEEDFF","point":0.4},{"color":"#FFDBEBFF","point":0.5},{"color":"#FFD7EAFF","point":0.6},{"color":"#FFD3E8FF","point":0.7},{"color":"#FFCFE6FF","point":0.8},{"color":"#FFCBE5FF","point":0.9},{"color":"#FFC8E3FF","point":1}],"backgroundColor":"#FFFFFFFF"},"darkBackgroundSpectrum":{"colorPoints":[{"color":"#FF7DA0D3","point":0},{"color":"#FF89A9D8","point":0.1},{"color":"#FF94B1DC","point":0.2},{"color":"#FFA0B9E0","point":0.3},{"color":"#FFABC1E3","point":0.4},{"color":"#FFB6C9E7","point":0.5},{"color":"#FFC0D1EB","point":0.6},{"color":"#FFCBD8EF","point":0.7},{"color":"#FFD5E0F2","point":0.8},{"color":"#FFE0E7F6","point":0.9},{"color":"#FFEAEFFA","point":1}],"backgroundColor":"#FF000000"}},"navItems":[{"type":1,"title":"Announcements","tagSlug":"announcements","url":"https://blog.dart.dev/tagged/announcements","source":"tagSlug"},{"type":5,"title":"Archive","url":"https://blog.dart.dev/archive"},{"type":3,"title":"dart.dev","url":"https://dart.dev"}],"colorBehavior":2,"collectionFeatures":[25],"ampLogo":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"header":{"title":"Dart","description":"An approachable, portable, and productive language for high-quality apps on any platform","backgroundImage":{},"logoImage":{"id":"1*knHF_qpxdtS8h0Z8EeqowA@2x.png","originalWidth":1080,"originalHeight":1080,"alt":"Dart"},"alignment":2,"layout":5},"subscriberCount":14031,"tagline":"Dart is a client-optimized language for fast apps on any platform.","isOptedIntoAurora":false,"isCurationAllowedByDefault":false,"polarisCoverImage":{"imageId":"","filter":"","backgroundSize":"","originalWidth":0,"originalHeight":0,"strategy":"resample","height":0,"width":0},"ptsQualifiedAt":1616092887098,"type":"Collection"}},"Social":{"fe67f3a27347":{"userId":"8b6a7f6f197d","targetUserId":"fe67f3a27347","type":"Social"}},"SocialStats":{"fe67f3a27347":{"userId":"fe67f3a27347","usersFollowedCount":19,"usersFollowedByCount":560,"type":"SocialStats"}}}},"v":3,"b":"20260130-1012-root"}