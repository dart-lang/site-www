[
  {
    "id": "abi_specific_integer_invalid",
    "description": "_Classes extending 'AbiSpecificInteger' must have exactly one const constructor, no other members, and no type parameters._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class that extends\n`AbiSpecificInteger` doesn't meet all of the following requirements:\n- there must be exactly one constructor\n- the constructor must be marked `const`\n- there must not be any members of other than the one constructor\n- there must not be any type parameters\n\n## Examples\n\nThe following code produces this diagnostic because the class `C` doesn't\ndefine a const constructor:\n\n```dart\nimport 'dart:ffi';\n\n@AbiSpecificIntegerMapping({Abi.macosX64 : Int8()})\nfinal class [!C!] extends AbiSpecificInteger {\n}\n```\n\nThe following code produces this diagnostic because the constructor isn't\na `const` constructor:\n\n```dart\nimport 'dart:ffi';\n\n@AbiSpecificIntegerMapping({Abi.macosX64 : Int8()})\nfinal class [!C!] extends AbiSpecificInteger {\n  C();\n}\n```\n\nThe following code produces this diagnostic because the class `C` defines\nmultiple constructors:\n\n```dart\nimport 'dart:ffi';\n\n@AbiSpecificIntegerMapping({Abi.macosX64 : Int8()})\nfinal class [!C!] extends AbiSpecificInteger {\n  const C.zero();\n  const C.one();\n}\n```\n\nThe following code produces this diagnostic because the class `C` defines\na field:\n\n```dart\nimport 'dart:ffi';\n\n@AbiSpecificIntegerMapping({Abi.macosX64 : Int8()})\nfinal class [!C!] extends AbiSpecificInteger {\n  final int i;\n\n  const C(this.i);\n}\n```\n\nThe following code produces this diagnostic because the class `C` has a\ntype parameter:\n\n```dart\nimport 'dart:ffi';\n\n@AbiSpecificIntegerMapping({Abi.macosX64 : Int8()})\nfinal class [!C!]<T> extends AbiSpecificInteger { // type parameters\n  const C();\n}\n```\n\n## Common fixes\n\nChange the class so that it meets the requirements of having no type\nparameters and a single member that is a `const` constructor:\n\n```dart\nimport 'dart:ffi';\n\n@AbiSpecificIntegerMapping({Abi.macosX64 : Int8()})\nfinal class C extends AbiSpecificInteger {\n  const C();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "abi_specific_integer_mapping_extra",
    "description": "_Classes extending 'AbiSpecificInteger' must have exactly one 'AbiSpecificIntegerMapping' annotation specifying the mapping from ABI to a 'NativeType' integer with a fixed size._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class that extends\n`AbiSpecificInteger` has more than one `AbiSpecificIntegerMapping`\nannotation.\n\n## Example\n\nThe following code produces this diagnostic because there are two\n`AbiSpecificIntegerMapping` annotations on the class `C`:\n\n```dart\nimport 'dart:ffi';\n\n@AbiSpecificIntegerMapping({Abi.macosX64 : Int8()})\n@[!AbiSpecificIntegerMapping!]({Abi.linuxX64 : Uint16()})\nfinal class C extends AbiSpecificInteger {\n  const C();\n}\n```\n\n## Common fixes\n\nRemove all but one of the annotations, merging the arguments as\nappropriate:\n\n```dart\nimport 'dart:ffi';\n\n@AbiSpecificIntegerMapping({Abi.macosX64 : Int8(), Abi.linuxX64 : Uint16()})\nfinal class C extends AbiSpecificInteger {\n  const C();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "abi_specific_integer_mapping_missing",
    "description": "_Classes extending 'AbiSpecificInteger' must have exactly one 'AbiSpecificIntegerMapping' annotation specifying the mapping from ABI to a 'NativeType' integer with a fixed size._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class that extends\n`AbiSpecificInteger` doesn't have an `AbiSpecificIntegerMapping`\nannotation.\n\n## Example\n\nThe following code produces this diagnostic because there's no\n`AbiSpecificIntegerMapping` annotation on the class `C`:\n\n```dart\nimport 'dart:ffi';\n\nfinal class [!C!] extends AbiSpecificInteger {\n  const C();\n}\n```\n\n## Common fixes\n\nAdd an `AbiSpecificIntegerMapping` annotation to the class:\n\n```dart\nimport 'dart:ffi';\n\n@AbiSpecificIntegerMapping({Abi.macosX64 : Int8()})\nfinal class C extends AbiSpecificInteger {\n  const C();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "abi_specific_integer_mapping_unsupported",
    "description": "_Invalid mapping to '{0}'; only mappings to 'Int8', 'Int16', 'Int32', 'Int64', 'Uint8', 'Uint16', 'UInt32', and 'Uint64' are supported._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a value in the map argument of\nan `AbiSpecificIntegerMapping` annotation is anything other than one of\nthe following integer types:\n- `Int8`\n- `Int16`\n- `Int32`\n- `Int64`\n- `Uint8`\n- `Uint16`\n- `UInt32`\n- `Uint64`\n\n## Example\n\nThe following code produces this diagnostic because the value of the map\nentry is `Array<Uint8>`, which isn't a valid integer type:\n\n```dart\nimport 'dart:ffi';\n\n@AbiSpecificIntegerMapping({Abi.macosX64 : [!Array<Uint8>(4)!]})\nfinal class C extends AbiSpecificInteger {\n  const C();\n}\n```\n\n## Common fixes\n\nUse one of the valid types as a value in the map:\n\n```dart\nimport 'dart:ffi';\n\n@AbiSpecificIntegerMapping({Abi.macosX64 : Int8()})\nfinal class C extends AbiSpecificInteger {\n  const C();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "abstract_class_member",
    "description": "_Members of classes can't be declared to be 'abstract'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "abstract_external_field",
    "description": "_Fields can't be declared both 'abstract' and 'external'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "abstract_field_initializer",
    "description": "_Abstract fields can't have initializers._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a field that has the `abstract`\nmodifier also has an initializer.\n\n## Examples\n\nThe following code produces this diagnostic because `f` is marked as\n`abstract` and has an initializer:\n\n```dart\nabstract class C {\n  abstract int [!f!] = 0;\n}\n```\n\nThe following code produces this diagnostic because `f` is marked as\n`abstract` and there's an initializer in the constructor:\n\n```dart\nabstract class C {\n  abstract int f;\n\n  C() : [!f!] = 0;\n}\n```\n\n## Common fixes\n\nIf the field must be abstract, then remove the initializer:\n\n```dart\nabstract class C {\n  abstract int f;\n}\n```\n\nIf the field isn't required to be abstract, then remove the keyword:\n\n```dart\nabstract class C {\n  int f = 0;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "abstract_final_base_class",
    "description": "_An 'abstract' class can't be declared as both 'final' and 'base'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "abstract_final_interface_class",
    "description": "_An 'abstract' class can't be declared as both 'final' and 'interface'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "abstract_late_field",
    "description": "_Abstract fields cannot be late._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "abstract_sealed_class",
    "description": "_A 'sealed' class can't be marked 'abstract' because it's already implicitly abstract._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class is declared using both\nthe modifier `abstract` and the modifier `sealed`. Sealed classes are\nimplicitly abstract, so explicitly using both modifiers is not allowed.\n\n## Example\n\nThe following code produces this diagnostic because the class `C` is\ndeclared using both `abstract` and `sealed`:\n\n```dart\nabstract [!sealed!] class C {}\n```\n\n## Common fixes\n\nIf the class should be abstract but not sealed, then remove the `sealed`\nmodifier:\n\n```dart\nabstract class C {}\n```\n\nIf the class should be both abstract and sealed, then remove the\n`abstract` modifier:\n\n```dart\nsealed class C {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "abstract_static_field",
    "description": "_Static fields can't be declared 'abstract'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "abstract_static_method",
    "description": "_Static methods can't be declared to be 'abstract'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "abstract_super_member_reference",
    "description": "_The {0} '{1}' is always abstract in the supertype._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an inherited member is\nreferenced using `super`, but there is no concrete implementation of the\nmember in the superclass chain. Abstract members can't be invoked.\n\n## Example\n\nThe following code produces this diagnostic because `B` doesn't inherit a\nconcrete implementation of `a`:\n\n```dart\nabstract class A {\n  int get a;\n}\nclass B extends A {\n  int get a => super.[!a!];\n}\n```\n\n## Common fixes\n\nRemove the invocation of the abstract member, possibly replacing it with an\ninvocation of a concrete member.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "address_position",
    "description": "_The '.address' expression can only be used as argument to a leaf native external call._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the `.address` getter is used\nin a context other than as an argument to a native external call that is\nmarked as a leaf call (`isLeaf: true`).\n\n## Example\n\nThe following code produces this diagnostic because `.address` is used\nincorrectly:\n\n```dart\nimport 'dart:ffi';\nimport 'dart:typed_data';\n\n@Native<Void Function(Pointer<Uint8>)>()\nexternal void nonLeafCall(Pointer<Uint8> ptr);\n\nvoid main() {\n  final data = Uint8List(10);\n\n  // Incorrect: Using '.address' as an argument to a non-leaf call.\n  nonLeafCall(data.[!address!]);\n}\n```\n\n## Common fixes\n\nEnsure that the `.address` expression is used directly as an argument to a\nnative external call that is annotated with `@Native(...)` and has\n`isLeaf: true` set in its annotation.\n\n```dart\nimport 'dart:ffi';\nimport 'dart:typed_data';\n\n@Native<Void Function(Pointer<Uint8>)>(isLeaf: true)\nexternal void leafCall(Pointer<Uint8> ptr);\n\nvoid main() {\n  final data = Uint8List(10);\n\n  // Correct: Using .address directly as an argument to a leaf call.\n  leafCall(data.address);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "address_receiver",
    "description": "_The receiver of '.address' must be a concrete 'TypedData', a concrete 'TypedData' '[]', an 'Array', an 'Array' '[]', a Struct field, or a Union field._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the `.address` getter is used\non a receiver whose static type isn't one of the allowed FFI types. The\n`.address` getter is used to obtain a `Pointer` to the underlying memory\nof an FFI data structure.\n\nThe receiver of `.address` must be one of the following:\n- A concrete `TypedData` instance (e.g., `Uint8List`).\n- An element of a concrete `TypedData` instance accessed via `[]`.\n- An `Array<T>` instance (from `dart:ffi`).\n- An element of an `Array<T>` instance accessed via `[]`.\n- A field of a `Struct` or `Union` subclass, if that field's type is `Array<T>`, a nested `Struct`, or a nested `Union`.\n- A `Struct` or `Union` instance.\n\n## Example\n\nThe following code produces this diagnostic for various incorrect receivers:\n\n```dart\nimport 'dart:ffi';\n\nfinal class MyStruct extends Struct {\n  @Uint8()\n  external int x;\n\n  @Uint8()\n  external int y;\n}\n\n@Native<Void Function(Pointer)>(isLeaf: true)\nexternal void nativeLeafCall(Pointer ptr);\n\nvoid main() {\n  final struct = Struct.create<MyStruct>();\n  final y = struct.y;\n  // Incorrect: The receiver is not a struct field, but some integer.\n  nativeLeafCall(y.[!address!]);\n}\n```\n\n## Common fixes\n\nEnsure that the receiver of the `.address` getter is one of the allowed\ntypes.  The `.address` getter is for obtaining a `Pointer` to the memory\nof `TypedData`, `Array`, `Struct`, or `Union` instances, or certain\nfields/elements thereof.\n\n```dart\nimport 'dart:ffi';\n\n@Native<Void Function(Pointer)>(isLeaf: true)\nexternal void nativeLeafCall(Pointer ptr);\n\nfinal class MyStruct extends Struct {\n  @Uint8()\n  external int x;\n\n  @Uint8()\n  external int y;\n}\n\nvoid main() {\n  final struct = Struct.create<MyStruct>();\n  // Correct: The receiver is a struct field.\n  nativeLeafCall(struct.y.address);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "ambiguous_export",
    "description": "_The name '{0}' is defined in the libraries '{1}' and '{2}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when two or more export directives\ncause the same name to be exported from multiple libraries.\n\n## Example\n\nGiven a file `a.dart` containing\n\n```dart\nclass C {}\n```\n\nAnd a file `b.dart` containing\n\n```dart\nclass C {}\n```\n\nThe following code produces this diagnostic because the name `C` is being\nexported from both `a.dart` and `b.dart`:\n\n```dart\nexport 'a.dart';\nexport [!'b.dart'!];\n```\n\n## Common fixes\n\nIf none of the names in one of the libraries needs to be exported, then\nremove the unnecessary export directives:\n\n```dart\nexport 'a.dart';\n```\n\nIf all of the export directives are needed, then hide the name in all\nexcept one of the directives:\n\n```dart\nexport 'a.dart';\nexport 'b.dart' hide C;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "ambiguous_extension_member_access",
    "description": "_A member named '{0}' is defined in '{1}' and '{2}', and neither is more specific._\n\n_A member named '{0}' is defined in {1}, and none are more specific._",
    "documentation": "## Description\n\nWhen code refers to a member of an object (for example, `o.m()` or `o.m` or\n`o[i]`) where the static type of `o` doesn't declare the member (`m` or\n`[]`, for example), then the analyzer tries to find the member in an\nextension. For example, if the member is `m`, then the analyzer looks for\nextensions that declare a member named `m` and have an extended type that\nthe static type of `o` can be assigned to. When there's more than one such\nextension in scope, the extension whose extended type is most specific is\nselected.\n\nThe analyzer produces this diagnostic when none of the extensions has an\nextended type that's more specific than the extended types of all of the\nother extensions, making the reference to the member ambiguous.\n\n## Example\n\nThe following code produces this diagnostic because there's no way to\nchoose between the member in `E1` and the member in `E2`:\n\n```dart\nextension E1 on String {\n  int get charCount => 1;\n}\n\nextension E2 on String {\n  int get charCount => 2;\n}\n\nvoid f(String s) {\n  print(s.[!charCount!]);\n}\n```\n\n## Common fixes\n\nIf you don't need both extensions, then you can delete or hide one of them.\n\nIf you need both, then explicitly select the one you want to use by using\nan extension override:\n\n```dart\nextension E1 on String {\n  int get charCount => length;\n}\n\nextension E2 on String {\n  int get charCount => length;\n}\n\nvoid f(String s) {\n  print(E2(s).charCount);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "ambiguous_import",
    "description": "_The name '{0}' is defined in the libraries {1}._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a name is referenced that is\ndeclared in two or more imported libraries.\n\n## Example\n\nGiven a library (`a.dart`) that defines a class (`C` in this example):\n\n```dart\nclass A {}\nclass C {}\n```\n\nAnd a library (`b.dart`) that defines a different class with the same name:\n\n```dart\nclass B {}\nclass C {}\n```\n\nThe following code produces this diagnostic:\n\n```dart\nimport 'a.dart';\nimport 'b.dart';\n\nvoid f([!C!] c1, [!C!] c2) {}\n```\n\n## Common fixes\n\nIf any of the libraries aren't needed, then remove the import directives\nfor them:\n\n```dart\nimport 'a.dart';\n\nvoid f(C c1, C c2) {}\n```\n\nIf the name is still defined by more than one library, then add a `hide`\nclause to the import directives for all except one library:\n\n```dart\nimport 'a.dart' hide C;\nimport 'b.dart';\n\nvoid f(C c1, C c2) {}\n```\n\nIf you must be able to reference more than one of these types, then add a\nprefix to each of the import directives, and qualify the references with\nthe appropriate prefix:\n\n```dart\nimport 'a.dart' as a;\nimport 'b.dart' as b;\n\nvoid f(a.C c1, b.C c2) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "ambiguous_set_or_map_literal_both",
    "description": "_The literal can't be either a map or a set because it contains at least one literal map entry or a spread operator spreading a 'Map', and at least one element which is neither of these._",
    "documentation": "## Description\n\nBecause map and set literals use the same delimiters (`{` and `}`), the\nanalyzer looks at the type arguments and the elements to determine which\nkind of literal you meant. When there are no type arguments, then the\nanalyzer uses the types of the elements. If all of the elements are literal\nmap entries and all of the spread operators are spreading a `Map` then it's\na `Map`. If none of the elements are literal map entries and all of the\nspread operators are spreading an `Iterable`, then it's a `Set`. If neither\nof those is true then it's ambiguous.\n\nThe analyzer produces this diagnostic when at least one element is a\nliteral map entry or a spread operator spreading a `Map`, and at least one\nelement is neither of these, making it impossible for the analyzer to\ndetermine whether you are writing a map literal or a set literal.\n\n## Example\n\nThe following code produces this diagnostic:\n\n```dart\nunion(Map<String, String> a, List<String> b, Map<String, String> c) =>\n    [!{...a, ...b, ...c}!];\n```\n\nThe list `b` can only be spread into a set, and the maps `a` and `c` can\nonly be spread into a map, and the literal can't be both.\n\n## Common fixes\n\nThere are two common ways to fix this problem. The first is to remove all\nof the spread elements of one kind or another, so that the elements are\nconsistent. In this case, that likely means removing the list and deciding\nwhat to do about the now unused parameter:\n\n```dart\nunion(Map<String, String> a, List<String> b, Map<String, String> c) =>\n    {...a, ...c};\n```\n\nThe second fix is to change the elements of one kind into elements that are\nconsistent with the other elements. For example, you can add the elements\nof the list as keys that map to themselves:\n\n```dart\nunion(Map<String, String> a, List<String> b, Map<String, String> c) =>\n    {...a, for (String s in b) s: s, ...c};\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "ambiguous_set_or_map_literal_either",
    "description": "_This literal must be either a map or a set, but the elements don't have enough information for type inference to work._",
    "documentation": "## Description\n\nBecause map and set literals use the same delimiters (`{` and `}`), the\nanalyzer looks at the type arguments and the elements to determine which\nkind of literal you meant. When there are no type arguments and all of the\nelements are spread elements (which are allowed in both kinds of literals)\nthen the analyzer uses the types of the expressions that are being spread.\nIf all of the expressions have the type `Iterable`, then it's a set\nliteral; if they all have the type `Map`, then it's a map literal.\n\nThis diagnostic is produced when none of the expressions being spread have\na type that allows the analyzer to decide whether you were writing a map\nliteral or a set literal.\n\n## Example\n\nThe following code produces this diagnostic:\n\n```dart\nunion(a, b) => [!{...a, ...b}!];\n```\n\nThe problem occurs because there are no type arguments, and there is no\ninformation about the type of either `a` or `b`.\n\n## Common fixes\n\nThere are three common ways to fix this problem. The first is to add type\narguments to the literal. For example, if the literal is intended to be a\nmap literal, you might write something like this:\n\n```dart\nunion(a, b) => <String, String>{...a, ...b};\n```\n\nThe second fix is to add type information so that the expressions have\neither the type `Iterable` or the type `Map`. You can add an explicit cast\nor, in this case, add types to the declarations of the two parameters:\n\n```dart\nunion(List<int> a, List<int> b) => {...a, ...b};\n```\n\nThe third fix is to add context information. In this case, that means\nadding a return type to the function:\n\n```dart\nSet<String> union(a, b) => {...a, ...b};\n```\n\nIn other cases, you might add a type somewhere else. For example, say the\noriginal code looks like this:\n\n```dart\nunion(a, b) {\n  var x = [!{...a, ...b}!];\n  return x;\n}\n```\n\nYou might add a type annotation on `x`, like this:\n\n```dart\nunion(a, b) {\n  Map<String, String> x = {...a, ...b};\n  return x;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "analysis_option_deprecated",
    "description": "_The option '{0}' is no longer supported._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an option in an analysis\noptions file is deprecated.\n\n## Example\n\nThe following code produces this diagnostic because the top-level key\n`errors` is deprecated:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\n[!errors!]:\n  dead_code: ignore\n```\n\n## Common fixes\n\nIf a replacement option or format exists, update the file to use it:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nanalyzer:\n  errors:\n    dead_code: ignore\n```\n\nIf no replacement is available, remove the deprecated option.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "annotation_on_pointer_field",
    "description": "_Fields in a struct class whose type is 'Pointer' shouldn't have any annotations._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a field that's declared in a\nsubclass of `Struct` and has the type `Pointer` also has an annotation\nassociated with it.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the field `p`, which\nhas the type `Pointer` and is declared in a subclass of `Struct`, has the\nannotation `@Double()`:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  [!@Double()!]\n  external Pointer<Int8> p;\n}\n```\n\n## Common fixes\n\nRemove the annotations from the field:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  external Pointer<Int8> p;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "annotation_on_type_argument",
    "description": "_Type arguments can't have annotations because they aren't declarations._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "annotation_space_before_parenthesis",
    "description": "_Annotations can't have spaces or comments before the parenthesis._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "annotation_with_type_arguments",
    "description": "_An annotation can't use type arguments._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "annotation_with_type_arguments_uninstantiated",
    "description": "_An annotation with type arguments must be followed by an argument list._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "argument_must_be_a_constant",
    "description": "_Argument '{0}' must be a constant._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an invocation of either\n`Pointer.asFunction` or `DynamicLibrary.lookupFunction` has an `isLeaf`\nargument whose value isn't a constant expression.\n\nThe analyzer also produces this diagnostic when an invocation of either\n`Pointer.fromFunction` or `NativeCallable.isolateLocal` has an\n`exceptionalReturn` argument whose value isn't a constant expression.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the value of the\n`isLeaf` argument is a parameter, and hence isn't a constant:\n\n```dart\nimport 'dart:ffi';\n\nint Function(int) fromPointer(\n    Pointer<NativeFunction<Int8 Function(Int8)>> p, bool isLeaf) {\n  return p.asFunction(isLeaf: [!isLeaf!]);\n}\n```\n\n## Common fixes\n\nIf there's a suitable constant that can be used, then replace the argument\nwith a constant:\n\n```dart\nimport 'dart:ffi';\n\nconst isLeaf = false;\n\nint Function(int) fromPointer(Pointer<NativeFunction<Int8 Function(Int8)>> p) {\n  return p.asFunction(isLeaf: isLeaf);\n}\n```\n\nIf there isn't a suitable constant, then replace the argument with a\nboolean literal:\n\n```dart\nimport 'dart:ffi';\n\nint Function(int) fromPointer(Pointer<NativeFunction<Int8 Function(Int8)>> p) {\n  return p.asFunction(isLeaf: true);\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "argument_must_be_native",
    "description": "_Argument to 'Native.addressOf' must be annotated with @Native_",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the argument passed to\n`Native.addressOf` isn't annotated with the `Native` annotation.\n\n## Examples\n\nThe following code produces this diagnostic because the argument to\n`addressOf` is a string, not a field, and strings can't be annotated:\n\n```dart\nimport 'dart:ffi';\n\n@Native<Void Function()>()\nexternal void f();\n\nvoid g() {\n  print(Native.addressOf([!'f'!]));\n}\n```\n\nThe following code produces this diagnostic because the function `f` is\nbeing passed to `addressOf` but isn't annotated as being `Native`:\n\n```dart\nimport 'dart:ffi';\n\nexternal void f();\n\nvoid g() {\n  print(Native.addressOf<NativeFunction<Void Function()>>([!f!]));\n}\n```\n\n## Common fixes\n\nIf the argument isn't either a field or a function, then replace the\nargument with a field or function that's annotated with `Native`:\n\n```dart\nimport 'dart:ffi';\n\n@Native<Void Function()>()\nexternal void f();\n\nvoid g() {\n  print(Native.addressOf<NativeFunction<Void Function()>>(f));\n}\n```\n\nIf the argument is either a field or a function, then annotate the field\nof function with `Native`:\n\n```dart\nimport 'dart:ffi';\n\n@Native<Void Function()>()\nexternal void f();\n\nvoid g() {\n  print(Native.addressOf<NativeFunction<Void Function()>>(f));\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "argument_type_not_assignable",
    "description": "_The argument type '{0}' can't be assigned to the parameter type '{1}'. {2}_",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the static type of an argument\ncan't be assigned to the static type of the corresponding parameter.\n\n## Example\n\nThe following code produces this diagnostic because a `num` can't be\nassigned to a `String`:\n\n```dart\nString f(String x) => x;\nString g(num y) => f([!y!]);\n```\n\n## Common fixes\n\nIf possible, rewrite the code so that the static type is assignable. In the\nexample above you might be able to change the type of the parameter `y`:\n\n```dart\nString f(String x) => x;\nString g(String y) => f(y);\n```\n\nIf that fix isn't possible, then add code to handle the case where the\nargument value isn't the required type. One approach is to coerce other\ntypes to the required type:\n\n```dart\nString f(String x) => x;\nString g(num y) => f(y.toString());\n```\n\nAnother approach is to add explicit type tests and fallback code:\n\n```dart\nString f(String x) => x;\nString g(Object y) => f(y is String ? y : '');\n```\n\nIf you believe that the runtime type of the argument will always be the\nsame as the static type of the parameter, and you're willing to risk having\nan exception thrown at runtime if you're wrong, then add an explicit cast:\n\n```dart\nString f(String x) => x;\nString g(num y) => f(y as String);\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "argument_type_not_assignable_to_error_handler",
    "description": "_The argument type '{0}' can't be assigned to the parameter type '{1} Function(Object)' or '{1} Function(Object, StackTrace)'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an invocation of\n`Future.catchError` has an argument that is a function whose parameters\naren't compatible with the arguments that will be passed to the function\nwhen it's invoked. The static type of the first argument to `catchError`\nis just `Function`, even though the function that is passed in is expected\nto have either a single parameter of type `Object` or two parameters of\ntype `Object` and `StackTrace`.\n\n## Examples\n\nThe following code produces this diagnostic because the closure being\npassed to `catchError` doesn't take any parameters, but the function is\nrequired to take at least one parameter:\n\n```dart\nvoid f(Future<int> f) {\n  f.catchError([!() => 0!]);\n}\n```\n\nThe following code produces this diagnostic because the closure being\npassed to `catchError` takes three parameters, but it can't have more than\ntwo required parameters:\n\n```dart\nvoid f(Future<int> f) {\n  f.catchError([!(one, two, three) => 0!]);\n}\n```\n\nThe following code produces this diagnostic because even though the closure\nbeing passed to `catchError` takes one parameter, the closure doesn't have\na type that is compatible with `Object`:\n\n```dart\nvoid f(Future<int> f) {\n  f.catchError([!(String error) => 0!]);\n}\n```\n\n## Common fixes\n\nChange the function being passed to `catchError` so that it has either one\nor two required parameters, and the parameters have the required types:\n\n```dart\nvoid f(Future<int> f) {\n  f.catchError((Object error) => 0);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "assert_in_redirecting_constructor",
    "description": "_A redirecting constructor can't have an 'assert' initializer._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a redirecting constructor (a\nconstructor that redirects to another constructor in the same class) has an\nassert in the initializer list.\n\n## Example\n\nThe following code produces this diagnostic because the unnamed constructor\nis a redirecting constructor and also has an assert in the initializer\nlist:\n\n```dart\nclass C {\n  C(int x) : [!assert(x > 0)!], this.name();\n  C.name() {}\n}\n```\n\n## Common fixes\n\nIf the assert isn't needed, then remove it:\n\n```dart\nclass C {\n  C(int x) : this.name();\n  C.name() {}\n}\n```\n\nIf the assert is needed, then convert the constructor into a factory\nconstructor:\n\n```dart\nclass C {\n  factory C(int x) {\n    assert(x > 0);\n    return C.name();\n  }\n  C.name() {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "asset_directory_does_not_exist",
    "description": "_The asset directory '{0}' doesn't exist._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an asset list contains a value\nreferencing a directory that doesn't exist.\n\n## Example\n\nAssuming that the directory `assets` doesn't exist, the following code\nproduces this diagnostic because it's listed as a directory containing\nassets:\n\n```yaml\nname: example\nflutter:\n  assets:\n    - [!assets/!]\n```\n\n## Common fixes\n\nIf the path is correct, then create a directory at that path.\n\nIf the path isn't correct, then change the path to match the path of the\ndirectory containing the assets.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "asset_does_not_exist",
    "description": "_The asset file '{0}' doesn't exist._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an asset list contains a value\nreferencing a file that doesn't exist.\n\n## Example\n\nAssuming that the file `doesNotExist.gif` doesn't exist, the following code\nproduces this diagnostic because it's listed as an asset:\n\n```yaml\nname: example\nflutter:\n  assets:\n    - [!doesNotExist.gif!]\n```\n\n## Common fixes\n\nIf the path is correct, then create a file at that path.\n\nIf the path isn't correct, then change the path to match the path of the\nfile containing the asset.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "asset_field_not_list",
    "description": "_The value of the 'assets' field is expected to be a list of relative file paths._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the value of the `assets` key\nisn't a list.\n\n## Example\n\nThe following code produces this diagnostic because the value of the\n`assets` key is a string when a list is expected:\n\n```yaml\nname: example\nflutter:\n  assets: [!assets/!]\n```\n\n## Common fixes\n\nChange the value of the asset list so that it's a list:\n\n```yaml\nname: example\nflutter:\n  assets:\n    - assets/\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "asset_missing_path",
    "description": "_Asset map entry must contain a 'path' field._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an asset map is missing a\n`path` value.\n\n## Example\n\nThe following code produces this diagnostic because the asset map\nis missing a `path` value:\n\n```yaml\nname: example\nflutter:\n  assets:\n    - flavors:\n      - premium\n```\n\n## Common fixes\n\nChange the asset map so that it contains a `path` field with a string\nvalue (a valid POSIX-style file path):\n\n```yaml\nname: example\nflutter:\n  assets:\n    - path: assets/image.gif\n      flavors:\n      - premium\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "asset_not_string",
    "description": "_Assets are required to be file paths (strings)._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an `assets` list contains a\nvalue that isn't a string.\n\n## Example\n\nThe following code produces this diagnostic because the `assets` list\ncontains a map:\n\n```yaml\nname: example\nflutter:\n  assets:\n    - [!image.gif: true!]\n```\n\n## Common fixes\n\nChange the `assets` list so that it only contains valid POSIX-style file\npaths:\n\n```yaml\nname: example\nflutter:\n  assets:\n    - assets/image.gif\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "asset_not_string_or_map",
    "description": "_An asset value is required to be a file path (string) or map._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an asset value isn't a string\nor a map.\n\n## Example\n\nThe following code produces this diagnostic because the asset value\nis a list:\n\n```yaml\nname: example\nflutter:\n  assets:\n    - [![one, two, three]!]\n```\n\n## Common fixes\n\nIf you need to specify more than just the path to the asset, then replace\nthe value with a map with a `path` key (a valid POSIX-style file path):\n\n```yaml\nname: example\nflutter:\n  assets:\n    - path: assets/image.gif\n      flavors:\n      - premium\n```\n\nIf you only need to specify the path, then replace the value with the path\nto the asset (a valid POSIX-style file path):\n\n```yaml\nname: example\nflutter:\n  assets:\n    - assets/image.gif\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "asset_path_not_string",
    "description": "_Asset paths are required to be file paths (strings)._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an asset map contains a\n`path` value that isn't a string.\n\n## Example\n\nThe following code produces this diagnostic because the asset map\ncontains a `path` value which is a list:\n\n```yaml\nname: example\nflutter:\n  assets:\n    - path: [![one, two, three]!]\n      flavors:\n      - premium\n```\n\n## Common fixes\n\nChange the `asset` map so that it contains a `path` value which is a\nstring (a valid POSIX-style file path):\n\n```yaml\nname: example\nflutter:\n  assets:\n    - path: image.gif\n      flavors:\n      - premium\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "assignment_of_do_not_store",
    "description": "_'{0}' is marked 'doNotStore' and shouldn't be assigned to a field or top-level variable._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the value of a function\n(including methods and getters) that is explicitly or implicitly marked by\nthe [`doNotStore`][meta-doNotStore] annotation is stored in either a field\nor top-level variable.\n\n## Example\n\nThe following code produces this diagnostic because the value of the\nfunction `f` is being stored in the top-level variable `x`:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@doNotStore\nint f() => 1;\n\nvar x = [!f()!];\n```\n\n## Common fixes\n\nReplace references to the field or variable with invocations of the\nfunction producing the value.\n\n[meta-doNotStore]: https://pub.dev/documentation/meta/latest/meta/doNotStore-constant.html\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "assignment_to_const",
    "description": "_Constant variables can't be assigned a value after initialization._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it finds an assignment to a\ntop-level variable, a static field, or a local variable that has the\n`const` modifier. The value of a compile-time constant can't be changed at\nruntime.\n\n## Example\n\nThe following code produces this diagnostic because `c` is being assigned a\nvalue even though it has the `const` modifier:\n\n```dart\nconst c = 0;\n\nvoid f() {\n  [!c!] = 1;\n  print(c);\n}\n```\n\n## Common fixes\n\nIf the variable must be assignable, then remove the `const` modifier:\n\n```dart\nvar c = 0;\n\nvoid f() {\n  c = 1;\n  print(c);\n}\n```\n\nIf the constant shouldn't be changed, then either remove the assignment or\nuse a local variable in place of references to the constant:\n\n```dart\nconst c = 0;\n\nvoid f() {\n  var v = 1;\n  print(v);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "assignment_to_final",
    "description": "_'{0}' can't be used as a setter because it's final._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it finds an invocation of a\nsetter, but there's no setter because the field with the same name was\ndeclared to be `final` or `const`.\n\n## Example\n\nThe following code produces this diagnostic because `v` is final:\n\n```dart\nclass C {\n  final v = 0;\n}\n\nf(C c) {\n  c.[!v!] = 1;\n}\n```\n\n## Common fixes\n\nIf you need to be able to set the value of the field, then remove the\nmodifier `final` from the field:\n\n```dart\nclass C {\n  int v = 0;\n}\n\nf(C c) {\n  c.v = 1;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "assignment_to_final_local",
    "description": "_The final variable '{0}' can only be set once._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a local variable that was\ndeclared to be final is assigned after it was initialized.\n\n## Example\n\nThe following code produces this diagnostic because `x` is final, so it\ncan't have a value assigned to it after it was initialized:\n\n```dart\nvoid f() {\n  final x = 0;\n  [!x!] = 3;\n  print(x);\n}\n```\n\n## Common fixes\n\nRemove the keyword `final`, and replace it with `var` if there's no type\nannotation:\n\n```dart\nvoid f() {\n  var x = 0;\n  x = 3;\n  print(x);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "assignment_to_final_no_setter",
    "description": "_There isn't a setter named '{0}' in class '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a reference to a setter is\nfound; there is no setter defined for the type; but there is a getter\ndefined with the same name.\n\n## Example\n\nThe following code produces this diagnostic because there is no setter\nnamed `x` in `C`, but there is a getter named `x`:\n\n```dart\nclass C {\n  int get x => 0;\n  set y(int p) {}\n}\n\nvoid f(C c) {\n  c.[!x!] = 1;\n}\n```\n\n## Common fixes\n\nIf you want to invoke an existing setter, then correct the name:\n\n```dart\nclass C {\n  int get x => 0;\n  set y(int p) {}\n}\n\nvoid f(C c) {\n  c.y = 1;\n}\n```\n\nIf you want to invoke the setter but it just doesn't exist yet, then\ndeclare it:\n\n```dart\nclass C {\n  int get x => 0;\n  set x(int p) {}\n  set y(int p) {}\n}\n\nvoid f(C c) {\n  c.x = 1;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "assignment_to_function",
    "description": "_Functions can't be assigned a value._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the name of a function appears\non the left-hand side of an assignment expression.\n\n## Example\n\nThe following code produces this diagnostic because the assignment to the\nfunction `f` is invalid:\n\n```dart\nvoid f() {}\n\nvoid g() {\n  [!f!] = () {};\n}\n```\n\n## Common fixes\n\nIf the right-hand side should be assigned to something else, such as a\nlocal variable, then change the left-hand side:\n\n```dart\nvoid f() {}\n\nvoid g() {\n  var x = () {};\n  print(x);\n}\n```\n\nIf the intent is to change the implementation of the function, then define\na function-valued variable instead of a function:\n\n```dart\nvoid Function() f = () {};\n\nvoid g() {\n  f = () {};\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "assignment_to_method",
    "description": "_Methods can't be assigned a value._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the target of an assignment is a\nmethod.\n\n## Example\n\nThe following code produces this diagnostic because `f` can't be assigned a\nvalue because it's a method:\n\n```dart\nclass C {\n  void f() {}\n\n  void g() {\n    [!f!] = null;\n  }\n}\n```\n\n## Common fixes\n\nRewrite the code so that there isn't an assignment to a method.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "assignment_to_type",
    "description": "_Types can't be assigned a value._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the name of a type name appears\non the left-hand side of an assignment expression.\n\n## Example\n\nThe following code produces this diagnostic because the assignment to the\nclass `C` is invalid:\n\n```dart\nclass C {}\n\nvoid f() {\n  [!C!] = null;\n}\n```\n\n## Common fixes\n\nIf the right-hand side should be assigned to something else, such as a\nlocal variable, then change the left-hand side:\n\n```dart\nvoid f() {}\n\nvoid g() {\n  var c = null;\n  print(c);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "async_for_in_wrong_context",
    "description": "_The async for-in loop can only be used in an async function._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an async for-in loop is found in\na function or method whose body isn't marked as being either `async` or\n`async*`.\n\n## Example\n\nThe following code produces this diagnostic because the body of `f` isn't\nmarked as being either `async` or `async*`, but `f` contains an async\nfor-in loop:\n\n```dart\nvoid f(list) {\n  [!await!] for (var e in list) {\n    print(e);\n  }\n}\n```\n\n## Common fixes\n\nIf the function should return a `Future`, then mark the body with `async`:\n\n```dart\nFuture<void> f(list) async {\n  await for (var e in list) {\n    print(e);\n  }\n}\n```\n\nIf the function should return a `Stream` of values, then mark the body with\n`async*`:\n\n```dart\nStream<void> f(list) async* {\n  await for (var e in list) {\n    print(e);\n  }\n}\n```\n\nIf the function should be synchronous, then remove the `await` before the\nloop:\n\n```dart\nvoid f(list) {\n  for (var e in list) {\n    print(e);\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "async_keyword_used_as_identifier",
    "description": "_The keywords 'await' and 'yield' can't be used as identifiers in an asynchronous or generator function._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "augmentation_extends_clause_already_present",
    "description": "_The augmentation has an 'extends' clause, but an augmentation target already includes an 'extends' clause and it isn't allowed to be repeated or changed._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "augmentation_modifier_extra",
    "description": "_The augmentation has the '{0}' modifier that the declaration doesn't have._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "augmentation_modifier_missing",
    "description": "_The augmentation is missing the '{0}' modifier that the declaration has._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "augmentation_of_different_declaration_kind",
    "description": "_Can't augment a {0} with a {1}._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "augmentation_type_parameter_bound",
    "description": "_The augmentation type parameter must have the same bound as the corresponding type parameter of the declaration._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "augmentation_type_parameter_count",
    "description": "_The augmentation must have the same number of type parameters as the declaration._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "augmentation_type_parameter_name",
    "description": "_The augmentation type parameter must have the same name as the corresponding type parameter of the declaration._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "augmentation_without_declaration",
    "description": "_The declaration being augmented doesn't exist._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "augmented_expression_is_not_setter",
    "description": "_The augmented declaration is not a setter, it can't be used to write a value._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "augmented_expression_is_setter",
    "description": "_The augmented declaration is a setter, it can't be used to read a value._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "augmented_expression_not_operator",
    "description": "_The enclosing augmentation doesn't augment the operator '{0}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "await_in_late_local_variable_initializer",
    "description": "_The 'await' expression can't be used in a 'late' local variable's initializer._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a local variable that has the\n`late` modifier uses an `await` expression in the initializer.\n\n## Example\n\nThe following code produces this diagnostic because an `await` expression\nis used in the initializer for `v`, a local variable that is marked `late`:\n\n```dart\nFuture<int> f() async {\n  late var v = [!await!] 42;\n  return v;\n}\n```\n\n## Common fixes\n\nIf the initializer can be rewritten to not use `await`, then rewrite it:\n\n```dart\nFuture<int> f() async {\n  late var v = 42;\n  return v;\n}\n```\n\nIf the initializer can't be rewritten, then remove the `late` modifier:\n\n```dart\nFuture<int> f() async {\n  var v = await 42;\n  return v;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "await_in_wrong_context",
    "description": "_The await expression can only be used in an async function._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "await_of_incompatible_type",
    "description": "_The 'await' expression can't be used for an expression with an extension type that is not a subtype of 'Future'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the type of the expression in\nan `await` expression is an extension type, and the extension type isn't a\nsubclass of `Future`.\n\n## Example\n\nThe following code produces this diagnostic because the extension type `E`\nisn't a subclass of `Future`:\n\n```dart\nextension type E(int i) {}\n\nvoid f(E e) async {\n  [!await!] e;\n}\n```\n\n## Common fixes\n\nIf the extension type is correctly defined, then remove the `await`:\n\n```dart\nextension type E(int i) {}\n\nvoid f(E e) {\n  e;\n}\n```\n\nIf the extension type is intended to be awaitable, then add `Future` (or a\nsubtype of `Future`) to the `implements` clause (adding an `implements`\nclause if there isn't one already), and make the representation type\nmatch:\n\n```dart\nextension type E(Future<int> i) implements Future<int> {}\n\nvoid f(E e) async {\n  await e;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "base_enum",
    "description": "_Enums can't be declared to be 'base'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "binary_operator_written_out",
    "description": "_Binary operator '{0}' is written as '{1}' instead of the written out word._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "body_might_complete_normally",
    "description": "_The body might complete normally, causing 'null' to be returned, but the return type, '{0}', is a potentially non-nullable type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a method or function has a\nreturn type that's [potentially non-nullable][] but would implicitly return\n`null` if control reached the end of the function.\n\n## Examples\n\nThe following code produces this diagnostic because the method `m` has an\nimplicit return of `null` inserted at the end of the method, but the method\nis declared to not return `null`:\n\n```dart\nclass C {\n  int [!m!](int t) {\n    print(t);\n  }\n}\n```\n\nThe following code produces this diagnostic because the method `m` has an\nimplicit return of `null` inserted at the end of the method, but because\nthe class `C` can be instantiated with a non-nullable type argument, the\nmethod is effectively declared to not return `null`:\n\n```dart\nclass C<T> {\n  T [!m!](T t) {\n    print(t);\n  }\n}\n```\n\n## Common fixes\n\nIf there's a reasonable value that can be returned, then add a `return`\nstatement at the end of the method:\n\n```dart\nclass C<T> {\n  T m(T t) {\n    print(t);\n    return t;\n  }\n}\n```\n\nIf the method won't reach the implicit return, then add a `throw` at the\nend of the method:\n\n```dart\nclass C<T> {\n  T m(T t) {\n    print(t);\n    throw '';\n  }\n}\n```\n\nIf the method intentionally returns `null` at the end, then add an\nexplicit return of `null` at the end of the method and change the\nreturn type so that it's valid to return `null`:\n\n```dart\nclass C<T> {\n  T? m(T t) {\n    print(t);\n    return null;\n  }\n}\n```\n\n[potentially non-nullable]: /resources/glossary#potentially-non-nullable\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "body_might_complete_normally_catch_error",
    "description": "_This 'onError' handler must return a value assignable to '{0}', but ends without returning a value._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the closure passed to the\n`onError` parameter of the `Future.catchError` method is required to\nreturn a non-`null` value (because of the `Future`s type argument) but can\nimplicitly return `null`.\n\n## Example\n\nThe following code produces this diagnostic because the closure passed to\nthe `catchError` method is required to return an `int` but doesn't end\nwith an explicit `return`, causing it to implicitly return `null`:\n\n```dart\nvoid g(Future<int> f) {\n  f.catchError((e, st) [!{!]});\n}\n```\n\n## Common fixes\n\nIf the closure should sometimes return a non-`null` value, then add an\nexplicit return to the closure:\n\n```dart\nvoid g(Future<int> f) {\n  f.catchError((e, st) {\n    return -1;\n  });\n}\n```\n\nIf the closure should always return `null`, then change the type argument\nof the `Future` to be either `void` or `Null`:\n\n```dart\nvoid g(Future<void> f) {\n  f.catchError((e, st) {});\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "body_might_complete_normally_nullable",
    "description": "_This function has a nullable return type of '{0}', but ends without returning a value._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a method or function can\nimplicitly return `null` by falling off the end. While this is valid Dart\ncode, it's better for the return of `null` to be explicit.\n\n## Example\n\nThe following code produces this diagnostic because the function `f`\nimplicitly returns `null`:\n\n```dart\nString? [!f!]() {}\n```\n\n## Common fixes\n\nIf the return of `null` is intentional, then make it explicit:\n\n```dart\nString? f() {\n  return null;\n}\n```\n\nIf the function should return a non-null value along that path, then add\nthe missing return statement:\n\n```dart\nString? f() {\n  return '';\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "break_label_on_switch_member",
    "description": "_A break label resolves to the 'case' or 'default' statement._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a break in a case clause inside\na switch statement has a label that is associated with another case clause.\n\n## Example\n\nThe following code produces this diagnostic because the label `l` is\nassociated with the case clause for `0`:\n\n```dart\nvoid f(int i) {\n  switch (i) {\n    l: case 0:\n      break;\n    case 1:\n      break [!l!];\n  }\n}\n```\n\n## Common fixes\n\nIf the intent is to transfer control to the statement after the switch,\nthen remove the label from the break statement:\n\n```dart\nvoid f(int i) {\n  switch (i) {\n    case 0:\n      break;\n    case 1:\n      break;\n  }\n}\n```\n\nIf the intent is to transfer control to a different case block, then use\n`continue` rather than `break`:\n\n```dart\nvoid f(int i) {\n  switch (i) {\n    l: case 0:\n      break;\n    case 1:\n      continue l;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "break_outside_of_loop",
    "description": "_A break statement can't be used outside of a loop or switch statement._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "built_in_identifier_as_type",
    "description": "_The built-in identifier '{0}' can't be used as a type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a built-in identifier is used\nwhere a type name is expected.\n\n## Example\n\nThe following code produces this diagnostic because `import` can't be used\nas a type because it's a built-in identifier:\n\n```dart\n[!import!]<int> x;\n```\n\n## Common fixes\n\nReplace the built-in identifier with the name of a valid type:\n\n```dart\nList<int> x;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "built_in_identifier_in_declaration",
    "description": "_The built-in identifier '{0}' can't be used as a prefix name._\n\n_The built-in identifier '{0}' can't be used as a type name._\n\n_The built-in identifier '{0}' can't be used as a type parameter name._\n\n_The built-in identifier '{0}' can't be used as a typedef name._\n\n_The built-in identifier '{0}' can't be used as an extension name._\n\n_The built-in identifier '{0}' can't be used as an extension type name._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the name used in the declaration\nof a class, extension, mixin, typedef, type parameter, or import prefix is\na built-in identifier. Built-in identifiers can't be used to name any of\nthese kinds of declarations.\n\n## Example\n\nThe following code produces this diagnostic because `mixin` is a built-in\nidentifier:\n\n```dart\nextension [!mixin!] on int {}\n```\n\n## Common fixes\n\nChoose a different name for the declaration.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "camera_permissions_incompatible",
    "description": "_Camera permissions make app incompatible for Chrome OS, consider adding optional features \"android.hardware.camera\" and \"android.hardware.camera.autofocus\"._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "case_block_not_terminated",
    "description": "_The last statement of the 'case' should be 'break', 'continue', 'rethrow', 'return', or 'throw'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the last statement in a `case`\nblock isn't one of the required terminators: `break`, `continue`,\n`rethrow`, `return`, or `throw`.\n\n## Example\n\nThe following code produces this diagnostic because the `case` block ends\nwith an assignment:\n\n```dart\nvoid f(int x) {\n  switch (x) {\n    [!case!] 0:\n      x += 2;\n    default:\n      x += 1;\n  }\n}\n```\n\n## Common fixes\n\nAdd one of the required terminators:\n\n```dart\nvoid f(int x) {\n  switch (x) {\n    case 0:\n      x += 2;\n      break;\n    default:\n      x += 1;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "case_expression_type_implements_equals",
    "description": "_The switch case expression type '{0}' can't override the '==' operator._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the type of the expression\nfollowing the keyword `case` has an implementation of the `==` operator\nother than the one in `Object`.\n\n## Example\n\nThe following code produces this diagnostic because the expression\nfollowing the keyword `case` (`C(0)`) has the type `C`, and the class `C`\noverrides the `==` operator:\n\n```dart\nclass C {\n  final int value;\n\n  const C(this.value);\n\n  bool operator ==(Object other) {\n    return false;\n  }\n}\n\nvoid f(C c) {\n  switch (c) {\n    case [!C(0)!]:\n      break;\n  }\n}\n```\n\n## Common fixes\n\nIf there isn't a strong reason not to do so, then rewrite the code to use\nan if-else structure:\n\n```dart\nclass C {\n  final int value;\n\n  const C(this.value);\n\n  bool operator ==(Object other) {\n    return false;\n  }\n}\n\nvoid f(C c) {\n  if (c == C(0)) {\n    // ...\n  }\n}\n```\n\nIf you can't rewrite the switch statement and the implementation of `==`\nisn't necessary, then remove it:\n\n```dart\nclass C {\n  final int value;\n\n  const C(this.value);\n}\n\nvoid f(C c) {\n  switch (c) {\n    case C(0):\n      break;\n  }\n}\n```\n\nIf you can't rewrite the switch statement and you can't remove the\ndefinition of `==`, then find some other value that can be used to control\nthe switch:\n\n```dart\nclass C {\n  final int value;\n\n  const C(this.value);\n\n  bool operator ==(Object other) {\n    return false;\n  }\n}\n\nvoid f(C c) {\n  switch (c.value) {\n    case 0:\n      break;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "case_expression_type_is_not_switch_expression_subtype",
    "description": "_The switch case expression type '{0}' must be a subtype of the switch expression type '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the expression following `case`\nin a `switch` statement has a static type that isn't a subtype of the\nstatic type of the expression following `switch`.\n\n## Example\n\nThe following code produces this diagnostic because `1` is an `int`, which\nisn't a subtype of `String` (the type of `s`):\n\n```dart\nvoid f(String s) {\n  switch (s) {\n    case [!1!]:\n      break;\n  }\n}\n```\n\n## Common fixes\n\nIf the value of the `case` expression is wrong, then change the `case`\nexpression so that it has the required type:\n\n```dart\nvoid f(String s) {\n  switch (s) {\n    case '1':\n      break;\n  }\n}\n```\n\nIf the value of the `case` expression is correct, then change the `switch`\nexpression to have the required type:\n\n```dart\nvoid f(int s) {\n  switch (s) {\n    case 1:\n      break;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "cast_from_nullable_always_fails",
    "description": "_This cast will always throw an exception because the nullable local variable '{0}' is not assigned._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a local variable that has a\nnullable type hasn't been assigned and is cast to a non-nullable type.\nBecause the variable hasn't been assigned it has the default value of\n`null`, causing the cast to throw an exception.\n\n## Example\n\nThe following code produces this diagnostic because the variable `x` is\ncast to a non-nullable type (`int`) when it's known to have the value\n`null`:\n\n```dart\nvoid f() {\n  num? x;\n  [!x!] as int;\n  print(x);\n}\n```\n\n## Common fixes\n\nIf the variable is expected to have a value before the cast, then add an\ninitializer or an assignment:\n\n```dart\nvoid f() {\n  num? x = 3;\n  x as int;\n  print(x);\n}\n```\n\nIf the variable isn't expected to be assigned, then remove the cast:\n\n```dart\nvoid f() {\n  num? x;\n  print(x);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "cast_from_null_always_fails",
    "description": "_This cast always throws an exception because the expression always evaluates to 'null'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an expression whose type is\n`Null` is being cast to a non-nullable type.\n\n## Example\n\nThe following code produces this diagnostic because `n` is known to always\nbe `null`, but it's being cast to a non-nullable type:\n\n```dart\nvoid f(Null n) {\n  [!n as int!];\n}\n```\n\n## Common fixes\n\nRemove the unnecessary cast:\n\n```dart\nvoid f(Null n) {\n  n;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "cast_to_non_type",
    "description": "_The name '{0}' isn't a type, so it can't be used in an 'as' expression._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the name following the `as` in a\ncast expression is defined to be something other than a type.\n\n## Example\n\nThe following code produces this diagnostic because `x` is a variable, not\na type:\n\n```dart\nnum x = 0;\nint y = x as [!x!];\n```\n\n## Common fixes\n\nReplace the name with the name of a type:\n\n```dart\nnum x = 0;\nint y = x as int;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "catch_syntax",
    "description": "_'catch' must be followed by '(identifier)' or '(identifier, identifier)'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "catch_syntax_extra_parameters",
    "description": "_'catch' must be followed by '(identifier)' or '(identifier, identifier)'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "class_instantiation_access_to_member",
    "description": "_The class '{0}' doesn't have a constructor named '{1}'._\n\n_The instance member '{0}' can't be accessed on a class instantiation._\n\n_The static member '{0}' can't be accessed on a class instantiation._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "class_in_class",
    "description": "_Classes can't be declared inside other classes._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "class_used_as_mixin",
    "description": "_The class '{0}' can't be used as a mixin because it's neither a mixin class nor a mixin._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class that is neither a\n`mixin class` nor a `mixin` is used in a `with` clause.\n\n## Example\n\nThe following code produces this diagnostic because the class `M` is being\nused as a mixin, but it isn't defined as a `mixin class`:\n\n```dart\nclass M {}\nclass C with [!M!] {}\n```\n\n## Common fixes\n\nIf the class can be a pure mixin, then change `class` to `mixin`:\n\n```dart\nmixin M {}\nclass C with M {}\n```\n\nIf the class needs to be both a class and a mixin, then add `mixin`:\n\n```dart\nmixin class M {}\nclass C with M {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "collection_element_from_deferred_library",
    "description": "_Constant values from a deferred library can't be used as keys in a 'const' map literal._\n\n_Constant values from a deferred library can't be used as values in a 'const' constructor._\n\n_Constant values from a deferred library can't be used as values in a 'const' list literal._\n\n_Constant values from a deferred library can't be used as values in a 'const' map literal._\n\n_Constant values from a deferred library can't be used as values in a 'const' set literal._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a collection literal that is\neither explicitly (because it's prefixed by the `const` keyword) or\nimplicitly (because it appears in a [constant context][]) a constant\ncontains a value that is declared in a library that is imported using a\ndeferred import. Constants are evaluated at compile time, and values from\ndeferred libraries aren't available at compile time.\n\nFor more information, check out\n[Lazily loading a library](https://dart.dev/language/libraries#lazily-loading-a-library).\n\n## Example\n\nGiven a file `a.dart` that defines the constant `zero`:\n\n```dart\nconst zero = 0;\n```\n\nThe following code produces this diagnostic because the constant list\nliteral contains `a.zero`, which is imported using a `deferred` import:\n\n```dart\nimport 'a.dart' deferred as a;\n\nvar l = const [a.[!zero!]];\n```\n\n## Common fixes\n\nIf the collection literal isn't required to be constant, then remove the\n`const` keyword:\n\n```dart\nimport 'a.dart' deferred as a;\n\nvar l = [a.zero];\n```\n\nIf the collection is required to be constant and the imported constant must\nbe referenced, then remove the keyword `deferred` from the import:\n\n```dart\nimport 'a.dart' as a;\n\nvar l = const [a.zero];\n```\n\nIf you don't need to reference the constant, then replace it with a\nsuitable value:\n\n```dart\nvar l = const [0];\n```\n\n[constant context]: /resources/glossary#constant-context\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "colon_in_place_of_in",
    "description": "_For-in loops use 'in' rather than a colon._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "compound_implements_finalizable",
    "description": "_The class '{0}' can't implement Finalizable._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a subclass of either `Struct`\nor `Union` implements `Finalizable`.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the class `S`\nimplements `Finalizable`:\n\n```dart\nimport 'dart:ffi';\n\nfinal class [!S!] extends Struct implements Finalizable {\n  external Pointer notEmpty;\n}\n```\n\n## Common fixes\n\nTry removing the implements clause from the class:\n\n```dart\nimport 'dart:ffi';\n\nfinal class S extends Struct {\n  external Pointer notEmpty;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "concrete_class_has_enum_superinterface",
    "description": "_Concrete classes can't have 'Enum' as a superinterface._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a concrete class indirectly has\nthe class `Enum` as a superinterface.\n\n## Example\n\nThe following code produces this diagnostic because the concrete class `B`\nhas `Enum` as a superinterface as a result of implementing `A`:\n\n```dart\nabstract class A implements Enum {}\n\nclass [!B!] implements A {}\n```\n\n## Common fixes\n\nIf the implemented class isn't the class you intend to implement, then\nchange it:\n\n```dart\nabstract class A implements Enum {}\n\nclass B implements C {}\n\nclass C {}\n```\n\nIf the implemented class can be changed to not implement `Enum`, then do\nso:\n\n```dart\nabstract class A {}\n\nclass B implements A {}\n```\n\nIf the implemented class can't be changed to not implement `Enum`, then\nremove it from the `implements` clause:\n\n```dart\nabstract class A implements Enum {}\n\nclass B {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "concrete_class_with_abstract_member",
    "description": "_'{0}' must have a method body because '{1}' isn't abstract._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a member of a concrete class is\nfound that doesn't have a concrete implementation. Concrete classes aren't\nallowed to contain abstract members.\n\n## Example\n\nThe following code produces this diagnostic because `m` is an abstract\nmethod but `C` isn't an abstract class:\n\n```dart\nclass C {\n  [!void m();!]\n}\n```\n\n## Common fixes\n\nIf it's valid to create instances of the class, provide an implementation\nfor the member:\n\n```dart\nclass C {\n  void m() {}\n}\n```\n\nIf it isn't valid to create instances of the class, mark the class as being\nabstract:\n\n```dart\nabstract class C {\n  void m();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "conflicting_constructor_and_static_member",
    "description": "_'{0}' can't be used to name both a constructor and a static field in this class._\n\n_'{0}' can't be used to name both a constructor and a static getter in this class._\n\n_'{0}' can't be used to name both a constructor and a static method in this class._\n\n_'{0}' can't be used to name both a constructor and a static setter in this class._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a named constructor and either a\nstatic method or static field have the same name. Both are accessed using\nthe name of the class, so having the same name makes the reference\nambiguous.\n\n## Examples\n\nThe following code produces this diagnostic because the static field `foo`\nand the named constructor `foo` have the same name:\n\n```dart\nclass C {\n  C.[!foo!]();\n  static int foo = 0;\n}\n```\n\nThe following code produces this diagnostic because the static method `foo`\nand the named constructor `foo` have the same name:\n\n```dart\nclass C {\n  C.[!foo!]();\n  static void foo() {}\n}\n```\n\n## Common fixes\n\nRename either the member or the constructor.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "conflicting_field_and_method",
    "description": "_Class '{0}' can't define field '{1}' and have method '{2}.{1}' with the same name._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "conflicting_generic_interfaces",
    "description": "_The {0} '{1}' can't implement both '{2}' and '{3}' because the type arguments are different._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class attempts to implement a\ngeneric interface multiple times, and the values of the type arguments\naren't the same.\n\n## Example\n\nThe following code produces this diagnostic because `C` is defined to\nimplement both `I<int>` (because it extends `A`) and `I<String>` (because\nit implements`B`), but `int` and `String` aren't the same type:\n\n```dart\nclass I<T> {}\nclass A implements I<int> {}\nclass B implements I<String> {}\nclass [!C!] extends A implements B {}\n```\n\n## Common fixes\n\nRework the type hierarchy to avoid this situation. For example, you might\nmake one or both of the inherited types generic so that `C` can specify the\nsame type for both type arguments:\n\n```dart\nclass I<T> {}\nclass A<S> implements I<S> {}\nclass B implements I<String> {}\nclass C extends A<String> implements B {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "conflicting_inherited_method_and_setter",
    "description": "_The {0} '{1}' can't inherit both a method and a setter named '{2}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "conflicting_method_and_field",
    "description": "_Class '{0}' can't define method '{1}' and have field '{2}.{1}' with the same name._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "conflicting_modifiers",
    "description": "_Members can't be declared to be both '{0}' and '{1}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "conflicting_static_and_instance",
    "description": "_Class '{0}' can't define static member '{1}' and have instance member '{2}.{1}' with the same name._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "conflicting_type_variable_and_container",
    "description": "_'{0}' can't be used to name both a type parameter and the class in which the type parameter is defined._\n\n_'{0}' can't be used to name both a type parameter and the enum in which the type parameter is defined._\n\n_'{0}' can't be used to name both a type parameter and the extension in which the type parameter is defined._\n\n_'{0}' can't be used to name both a type parameter and the extension type in which the type parameter is defined._\n\n_'{0}' can't be used to name both a type parameter and the mixin in which the type parameter is defined._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class, mixin, or extension\ndeclaration declares a type parameter with the same name as the class,\nmixin, or extension that declares it.\n\n## Example\n\nThe following code produces this diagnostic because the type parameter `C`\nhas the same name as the class `C` of which it's a part:\n\n```dart\nclass C<[!C!]> {}\n```\n\n## Common fixes\n\nRename either the type parameter, or the class, mixin, or extension:\n\n```dart\nclass C<T> {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "conflicting_type_variable_and_member",
    "description": "_'{0}' can't be used to name both a type parameter and a member in this class._\n\n_'{0}' can't be used to name both a type parameter and a member in this enum._\n\n_'{0}' can't be used to name both a type parameter and a member in this extension type._\n\n_'{0}' can't be used to name both a type parameter and a member in this extension._\n\n_'{0}' can't be used to name both a type parameter and a member in this mixin._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class, mixin, or extension\ndeclaration declares a type parameter with the same name as one of the\nmembers of the class, mixin, or extension that declares it.\n\n## Example\n\nThe following code produces this diagnostic because the type parameter `T`\nhas the same name as the field `T`:\n\n```dart\nclass C<[!T!]> {\n  int T = 0;\n}\n```\n\n## Common fixes\n\nRename either the type parameter or the member with which it conflicts:\n\n```dart\nclass C<T> {\n  int total = 0;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "constant_pattern_never_matches_value_type",
    "description": "_The matched value type '{0}' can never be equal to this constant of type '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constant pattern can never\nmatch the value it's being tested against because the type of the constant\nis known to never match the type of the value.\n\n## Example\n\nThe following code produces this diagnostic because the type of the\nconstant pattern `(true)` is `bool`, and the type of the value being\nmatched (`x`) is `int`, and a Boolean can never match an integer:\n\n```dart\nvoid f(int x) {\n  if (x case [!true!]) {}\n}\n```\n\n## Common fixes\n\nIf the type of the value is correct, then rewrite the pattern to be\ncompatible:\n\n```dart\nvoid f(int x) {\n  if (x case 3) {}\n}\n```\n\nIf the type of the constant is correct, then rewrite the value to be\ncompatible:\n\n```dart\nvoid f(bool x) {\n  if (x case true) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "constant_pattern_with_non_constant_expression",
    "description": "_The expression of a constant pattern must be a valid constant._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constant pattern has an\nexpression that isn't a valid constant.\n\n## Example\n\nThe following code produces this diagnostic because the constant pattern\n`i` isn't a constant:\n\n```dart\nvoid f(int e, int i) {\n  switch (e) {\n    case [!i!]:\n      break;\n  }\n}\n```\n\n## Common fixes\n\nIf the value that should be matched is known, then replace the expression\nwith a constant:\n\n```dart\nvoid f(int e, int i) {\n  switch (e) {\n    case 0:\n      break;\n  }\n}\n```\n\nIf the value that should be matched isn't known, then rewrite the code to\nnot use a pattern:\n\n```dart\nvoid f(int e, int i) {\n  if (e == i) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "constructor_with_return_type",
    "description": "_Constructors can't have a return type._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "constructor_with_type_arguments",
    "description": "_A constructor invocation can't have type arguments after the constructor name._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_and_final",
    "description": "_Members can't be declared to be both 'const' and 'final'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_class",
    "description": "_Classes can't be declared to be 'const'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_constructor_field_type_mismatch",
    "description": "_In a const constructor, a value of type '{0}' can't be assigned to the field '{1}', which has type '{2}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_constructor_param_type_mismatch",
    "description": "_A value of type '{0}' can't be assigned to a parameter of type '{1}' in a const constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the runtime type of a constant\nvalue can't be assigned to the static type of a constant constructor's\nparameter.\n\n## Example\n\nThe following code produces this diagnostic because the runtime type of `i`\nis `int`, which can't be assigned to the static type of `s`:\n\n```dart\nclass C {\n  final String s;\n\n  const C(this.s);\n}\n\nconst dynamic i = 0;\n\nvoid f() {\n  const C([!i!]);\n}\n```\n\n## Common fixes\n\nPass a value of the correct type to the constructor:\n\n```dart\nclass C {\n  final String s;\n\n  const C(this.s);\n}\n\nconst dynamic i = 0;\n\nvoid f() {\n  const C('$i');\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_constructor_throws_exception",
    "description": "_Const constructors can't throw exceptions._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_constructor_with_body",
    "description": "_Const constructors can't have a body._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_constructor_with_field_initialized_by_non_const",
    "description": "_Can't define the 'const' constructor because the field '{0}' is initialized with a non-constant value._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor has the keyword\n`const`, but a field in the class is initialized to a non-constant value.\n\n## Example\n\nThe following code produces this diagnostic because the field `s` is\ninitialized to a non-constant value:\n\n```dart\nString x = '3';\nclass C {\n  final String s = x;\n  [!const!] C();\n}\n```\n\n## Common fixes\n\nIf the field can be initialized to a constant value, then change the\ninitializer to a constant expression:\n\n```dart\nclass C {\n  final String s = '3';\n  const C();\n}\n```\n\nIf the field can't be initialized to a constant value, then remove the\nkeyword `const` from the constructor:\n\n```dart\nString x = '3';\nclass C {\n  final String s = x;\n  C();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_constructor_with_mixin_with_field",
    "description": "_This constructor can't be declared 'const' because a mixin adds the instance field: {0}._\n\n_This constructor can't be declared 'const' because the mixins add the instance fields: {0}._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_constructor_with_non_const_super",
    "description": "_A constant constructor can't call a non-constant super constructor of '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor that is marked as\n`const` invokes a constructor from its superclass that isn't marked as\n`const`.\n\n## Example\n\nThe following code produces this diagnostic because the `const` constructor\nin `B` invokes the constructor `nonConst` from the class `A`, and the\nsuperclass constructor isn't a `const` constructor:\n\n```dart\nclass A {\n  const A();\n  A.nonConst();\n}\n\nclass B extends A {\n  const B() : [!super.nonConst()!];\n}\n```\n\n## Common fixes\n\nIf it isn't essential to invoke the superclass constructor that is\ncurrently being invoked, then invoke a constant constructor from the\nsuperclass:\n\n```dart\nclass A {\n  const A();\n  A.nonConst();\n}\n\nclass B extends A {\n  const B() : super();\n}\n```\n\nIf it's essential that the current constructor be invoked and if you can\nmodify it, then add `const` to the constructor in the superclass:\n\n```dart\nclass A {\n  const A();\n  const A.nonConst();\n}\n\nclass B extends A {\n  const B() : super.nonConst();\n}\n```\n\nIf it's essential that the current constructor be invoked and you can't\nmodify it, then remove `const` from the constructor in the subclass:\n\n```dart\nclass A {\n  const A();\n  A.nonConst();\n}\n\nclass B extends A {\n  B() : super.nonConst();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_constructor_with_non_final_field",
    "description": "_Can't define a const constructor for a class with non-final fields._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor is marked as a\nconst constructor, but the constructor is defined in a class that has at\nleast one non-final instance field (either directly or by inheritance).\n\n## Example\n\nThe following code produces this diagnostic because the field `x` isn't\nfinal:\n\n```dart\nclass C {\n  int x;\n\n  const [!C!](this.x);\n}\n```\n\n## Common fixes\n\nIf it's possible to mark all of the fields as final, then do so:\n\n```dart\nclass C {\n  final int x;\n\n  const C(this.x);\n}\n```\n\nIf it isn't possible to mark all of the fields as final, then remove the\nkeyword `const` from the constructor:\n\n```dart\nclass C {\n  int x;\n\n  C(this.x);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_deferred_class",
    "description": "_Deferred classes can't be created with 'const'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class from a library that is\nimported using a deferred import is used to create a `const` object.\nConstants are evaluated at compile time, and classes from deferred\nlibraries aren't available at compile time.\n\nFor more information, check out\n[Lazily loading a library](https://dart.dev/language/libraries#lazily-loading-a-library).\n\n## Example\n\nThe following code produces this diagnostic because it attempts to create a\n`const` instance of a class from a deferred library:\n\n```dart\nimport 'dart:convert' deferred as convert;\n\nconst json2 = [!convert.JsonCodec()!];\n```\n\n## Common fixes\n\nIf the object isn't required to be a constant, then change the code so that\na non-constant instance is created:\n\n```dart\nimport 'dart:convert' deferred as convert;\n\nfinal json2 = convert.JsonCodec();\n```\n\nIf the object must be a constant, then remove `deferred` from the import\ndirective:\n\n```dart\nimport 'dart:convert' as convert;\n\nconst json2 = convert.JsonCodec();\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_eval_assertion_failure",
    "description": "_The assertion in this constant expression failed._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_eval_assertion_failure_with_message",
    "description": "_An assertion failed with message '{0}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_eval_extension_method",
    "description": "_Extension methods can't be used in constant expressions._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_eval_extension_type_method",
    "description": "_Extension type methods can't be used in constant expressions._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_eval_for_element",
    "description": "_Constant expressions don't support 'for' elements._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_eval_method_invocation",
    "description": "_Methods can't be invoked in constant expressions._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_eval_primitive_equality",
    "description": "_In constant expressions, operands of the equality operator must have primitive equality._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_eval_property_access",
    "description": "_The property '{0}' can't be accessed on the type '{1}' in a constant expression._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_eval_throws_exception",
    "description": "_Evaluation of this constant expression throws an exception._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_eval_throws_idbze",
    "description": "_Evaluation of this constant expression throws an IntegerDivisionByZeroException._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_eval_type_bool",
    "description": "_In constant expressions, operands of this operator must be of type 'bool'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_eval_type_bool_int",
    "description": "_In constant expressions, operands of this operator must be of type 'bool' or 'int'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_eval_type_bool_num_string",
    "description": "_In constant expressions, operands of this operator must be of type 'bool', 'num', 'String' or 'null'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_eval_type_int",
    "description": "_In constant expressions, operands of this operator must be of type 'int'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_eval_type_num",
    "description": "_In constant expressions, operands of this operator must be of type 'num'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_eval_type_num_string",
    "description": "_In constant expressions, operands of this operator must be of type 'num' or 'String'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_eval_type_string",
    "description": "_In constant expressions, operands of this operator must be of type 'String'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_eval_type_type",
    "description": "_In constant expressions, operands of this operator must be of type 'Type'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_factory",
    "description": "_Only redirecting factory constructors can be declared to be 'const'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_initialized_with_non_constant_value",
    "description": "_Const variables must be initialized with a constant value._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a value that isn't statically\nknown to be a constant is assigned to a variable that's declared to be a\n`const` variable.\n\n## Example\n\nThe following code produces this diagnostic because `x` isn't declared to\nbe `const`:\n\n```dart\nvar x = 0;\nconst y = [!x!];\n```\n\n## Common fixes\n\nIf the value being assigned can be declared to be `const`, then change the\ndeclaration:\n\n```dart\nconst x = 0;\nconst y = x;\n```\n\nIf the value can't be declared to be `const`, then remove the `const`\nmodifier from the variable, possibly using `final` in its place:\n\n```dart\nvar x = 0;\nfinal y = x;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_initialized_with_non_constant_value_from_deferred_library",
    "description": "_Constant values from a deferred library can't be used to initialize a 'const' variable._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `const` variable is\ninitialized using a `const` variable from a library that is imported using\na deferred import. Constants are evaluated at compile time, and values from\ndeferred libraries aren't available at compile time.\n\nFor more information, check out\n[Lazily loading a library](https://dart.dev/language/libraries#lazily-loading-a-library).\n\n## Example\n\nThe following code produces this diagnostic because the variable `pi` is\nbeing initialized using the constant `math.pi` from the library\n`dart:math`, and `dart:math` is imported as a deferred library:\n\n```dart\nimport 'dart:math' deferred as math;\n\nconst pi = math.[!pi!];\n```\n\n## Common fixes\n\nIf you need to reference the value of the constant from the imported\nlibrary, then remove the keyword `deferred`:\n\n```dart\nimport 'dart:math' as math;\n\nconst pi = math.pi;\n```\n\nIf you don't need to reference the imported constant, then remove the\nreference:\n\n```dart\nconst pi = 3.14;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_instance_field",
    "description": "_Only static fields can be declared as const._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an instance field is marked as\nbeing const.\n\n## Example\n\nThe following code produces this diagnostic because `f` is an instance\nfield:\n\n```dart\nclass C {\n  [!const!] int f = 3;\n}\n```\n\n## Common fixes\n\nIf the field needs to be an instance field, then remove the keyword\n`const`, or replace it with `final`:\n\n```dart\nclass C {\n  final int f = 3;\n}\n```\n\nIf the field really should be a const field, then make it a static field:\n\n```dart\nclass C {\n  static const int f = 3;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_map_key_not_primitive_equality",
    "description": "_The type of a key in a constant map can't override the '==' operator, or 'hashCode', but the class '{0}' does._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the class of object used as a\nkey in a constant map literal implements either the `==` operator, the\ngetter `hashCode`, or both. The implementation of constant maps uses both\nthe `==` operator and the `hashCode` getter, so any implementation other\nthan the ones inherited from `Object` requires executing arbitrary code at\ncompile time, which isn't supported.\n\n## Examples\n\nThe following code produces this diagnostic because the constant map\ncontains a key whose type is `C`, and the class `C` overrides the\nimplementation of `==`:\n\n```dart\nclass C {\n  const C();\n\n  bool operator ==(Object other) => true;\n}\n\nconst map = {[!C()!] : 0};\n```\n\nThe following code produces this diagnostic because the constant map\ncontains a key whose type is `C`, and the class `C` overrides the\nimplementation of `hashCode`:\n\n```dart\nclass C {\n  const C();\n\n  int get hashCode => 3;\n}\n\nconst map = {[!C()!] : 0};\n```\n\n## Common fixes\n\nIf you can remove the implementation of `==` and `hashCode` from the\nclass, then do so:\n\n```dart\nclass C {\n  const C();\n}\n\nconst map = {C() : 0};\n```\n\nIf you can't remove the implementation of `==` and `hashCode` from the\nclass, then make the map non-constant:\n\n```dart\nclass C {\n  const C();\n\n  bool operator ==(Object other) => true;\n}\n\nfinal map = {C() : 0};\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_method",
    "description": "_Getters, setters and methods can't be declared to be 'const'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_not_initialized",
    "description": "_The constant '{0}' must be initialized._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a variable that is declared to\nbe a constant doesn't have an initializer.\n\n## Example\n\nThe following code produces this diagnostic because `c` isn't initialized:\n\n```dart\nconst [!c!];\n```\n\n## Common fixes\n\nAdd an initializer:\n\n```dart\nconst c = 'c';\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_set_element_not_primitive_equality",
    "description": "_An element in a constant set can't override the '==' operator, or 'hashCode', but the type '{0}' does._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the class of object used as an\nelement in a constant set literal implements either the `==` operator, the\ngetter `hashCode`, or both. The implementation of constant sets uses both\nthe `==` operator and the `hashCode` getter, so any implementation other\nthan the ones inherited from `Object` requires executing arbitrary code at\ncompile time, which isn't supported.\n\n## Example\n\nThe following code produces this diagnostic because the constant set\ncontains an element whose type is `C`, and the class `C` overrides the\nimplementation of `==`:\n\n```dart\nclass C {\n  const C();\n\n  bool operator ==(Object other) => true;\n}\n\nconst set = {[!C()!]};\n```\n\nThe following code produces this diagnostic because the constant set\ncontains an element whose type is `C`, and the class `C` overrides the\nimplementation of `hashCode`:\n\n```dart\nclass C {\n  const C();\n\n  int get hashCode => 3;\n}\n\nconst map = {[!C()!]};\n```\n\n## Common fixes\n\nIf you can remove the implementation of `==` and `hashCode` from the\nclass, then do so:\n\n```dart\nclass C {\n  const C();\n}\n\nconst set = {C()};\n```\n\nIf you can't remove the implementation of `==` and `hashCode` from the\nclass, then make the set non-constant:\n\n```dart\nclass C {\n  const C();\n\n  bool operator ==(Object other) => true;\n}\n\nfinal set = {C()};\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": [
      "const_set_element_type_implements_equals"
    ]
  },
  {
    "id": "const_spread_expected_list_or_set",
    "description": "_A list or a set is expected in this spread._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the expression of a spread\noperator in a constant list or set evaluates to something other than a list\nor a set.\n\n## Example\n\nThe following code produces this diagnostic because the value of `list1` is\n`null`, which is neither a list nor a set:\n\n```dart\nconst dynamic list1 = 42;\nconst List<int> list2 = [...[!list1!]];\n```\n\n## Common fixes\n\nChange the expression to something that evaluates to either a constant list\nor a constant set:\n\n```dart\nconst dynamic list1 = [42];\nconst List<int> list2 = [...list1];\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_spread_expected_map",
    "description": "_A map is expected in this spread._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the expression of a spread\noperator in a constant map evaluates to something other than a map.\n\n## Example\n\nThe following code produces this diagnostic because the value of `map1` is\n`null`, which isn't a map:\n\n```dart\nconst dynamic map1 = 42;\nconst Map<String, int> map2 = {...[!map1!]};\n```\n\n## Common fixes\n\nChange the expression to something that evaluates to a constant map:\n\n```dart\nconst dynamic map1 = {'answer': 42};\nconst Map<String, int> map2 = {...map1};\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_type_parameter",
    "description": "_Type parameters can't be used in a constant expression._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_without_primary_constructor",
    "description": "_'const' can only be used together with a primary constructor declaration._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_with_non_const",
    "description": "_The constructor being called isn't a const constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the keyword `const` is used to\ninvoke a constructor that isn't marked with `const`.\n\n## Example\n\nThe following code produces this diagnostic because the constructor in `A`\nisn't a const constructor:\n\n```dart\nclass A {\n  A();\n}\n\nA f() => [!const!] A();\n```\n\n## Common fixes\n\nIf it's desirable and possible to make the class a constant class (by\nmaking all of the fields of the class, including inherited fields, final),\nthen add the keyword `const` to the constructor:\n\n```dart\nclass A {\n  const A();\n}\n\nA f() => const A();\n```\n\nOtherwise, remove the keyword `const`:\n\n```dart\nclass A {\n  A();\n}\n\nA f() => A();\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_with_non_constant_argument",
    "description": "_Arguments of a constant creation must be constant expressions._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a const constructor is invoked\nwith an argument that isn't a constant expression.\n\n## Example\n\nThe following code produces this diagnostic because `i` isn't a constant:\n\n```dart\nclass C {\n  final int i;\n  const C(this.i);\n}\nC f(int i) => const C([!i!]);\n```\n\n## Common fixes\n\nEither make all of the arguments constant expressions, or remove the\n`const` keyword to use the non-constant form of the constructor:\n\n```dart\nclass C {\n  final int i;\n  const C(this.i);\n}\nC f(int i) => C(i);\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_with_type_parameters",
    "description": "_A constant constructor tearoff can't use a type parameter as a type argument._\n\n_A constant creation can't use a type parameter as a type argument._\n\n_A constant function tearoff can't use a type parameter as a type argument._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a type parameter is used as a\ntype argument in a `const` invocation of a constructor. This isn't allowed\nbecause the value of the type parameter (the actual type that will be used\nat runtime) can't be known at compile time.\n\n## Example\n\nThe following code produces this diagnostic because the type parameter `T`\nis being used as a type argument when creating a constant:\n\n```dart\nclass C<T> {\n  const C();\n}\n\nC<T> newC<T>() => const C<[!T!]>();\n```\n\n## Common fixes\n\nIf the type that will be used for the type parameter can be known at\ncompile time, then remove the use of the type parameter:\n\n```dart\nclass C<T> {\n  const C();\n}\n\nC<int> newC() => const C<int>();\n```\n\nIf the type that will be used for the type parameter can't be known until\nruntime, then remove the keyword `const`:\n\n```dart\nclass C<T> {\n  const C();\n}\n\nC<T> newC<T>() => C<T>();\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_with_undefined_constructor",
    "description": "_The class '{0}' doesn't have a constant constructor '{1}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "const_with_undefined_constructor_default",
    "description": "_The class '{0}' doesn't have an unnamed constant constructor._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "continue_label_invalid",
    "description": "_The label used in a 'continue' statement must be defined on either a loop or a switch member._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the label in a `continue`\nstatement resolves to a label on a `switch` statement.\n\n## Example\n\nThe following code produces this diagnostic because the label `l`, used to\nlabel a `switch` statement, is used in the `continue` statement:\n\n```dart\nvoid f(int i) {\n  l: switch (i) {\n    case 0:\n      [!continue l;!]\n  }\n}\n```\n\n## Common fixes\n\nFind a different way to achieve the control flow you need; for example, by\nintroducing a loop that re-executes the `switch` statement.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": [
      "continue_label_on_switch"
    ]
  },
  {
    "id": "continue_outside_of_loop",
    "description": "_A continue statement can't be used outside of a loop or switch statement._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "continue_without_label_in_case",
    "description": "_A continue statement in a switch statement must have a label as a target._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "could_not_infer",
    "description": "_Couldn't infer type parameter '{0}'.{1}_",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "covariant_and_static",
    "description": "_Members can't be declared to be both 'covariant' and 'static'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "covariant_constructor",
    "description": "_A constructor can't be declared to be 'covariant'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "covariant_member",
    "description": "_Getters, setters and methods can't be declared to be 'covariant'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "creation_of_struct_or_union",
    "description": "_Subclasses of 'Struct' and 'Union' are backed by native memory, and can't be instantiated by a generative constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a subclass of either `Struct`\nor `Union` is instantiated using a generative constructor.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the class `C` is being\ninstantiated using a generative constructor:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Int32()\n  external int a;\n}\n\nvoid f() {\n  [!C!]();\n}\n```\n\n## Common fixes\n\nIf you need to allocate the structure described by the class, then use the\n`ffi` package to do so:\n\n```dart\nimport 'dart:ffi';\nimport 'package:ffi/ffi.dart';\n\nfinal class C extends Struct {\n  @Int32()\n  external int a;\n}\n\nvoid f() {\n  final pointer = calloc.allocate<C>(4);\n  final c = pointer.ref;\n  print(c);\n  calloc.free(pointer);\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "creation_with_non_type",
    "description": "_The name '{0}' isn't a class._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an instance creation using\neither `new` or `const` specifies a name that isn't defined as a class.\n\n## Example\n\nThe following code produces this diagnostic because `f` is a function\nrather than a class:\n\n```dart\nint f() => 0;\n\nvoid g() {\n  new [!f!]();\n}\n```\n\n## Common fixes\n\nIf a class should be created, then replace the invalid name with the name\nof a valid class:\n\n```dart\nint f() => 0;\n\nvoid g() {\n  new Object();\n}\n```\n\nIf the name is the name of a function and you want that function to be\ninvoked, then remove the `new` or `const` keyword:\n\n```dart\nint f() => 0;\n\nvoid g() {\n  f();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "dead_code",
    "description": "_Dead code._\n\n_Dead code: The assigned-to wildcard variable is marked late and can never be referenced so this initializer will never be evaluated._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when code is found that won't be\nexecuted because execution will never reach the code.\n\n## Example\n\nThe following code produces this diagnostic because the invocation of\n`print` occurs after the function has returned:\n\n```dart\nvoid f() {\n  return;\n  [!print('here');!]\n}\n```\n\n## Common fixes\n\nIf the code isn't needed, then remove it:\n\n```dart\nvoid f() {\n  return;\n}\n```\n\nIf the code needs to be executed, then either move the code to a place\nwhere it will be executed:\n\n```dart\nvoid f() {\n  print('here');\n  return;\n}\n```\n\nOr, rewrite the code before it, so that it can be reached:\n\n```dart\nvoid f({bool skipPrinting = true}) {\n  if (skipPrinting) {\n    return;\n  }\n  print('here');\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "dead_code_catch_following_catch",
    "description": "_Dead code: Catch clauses after a 'catch (e)' or an 'on Object catch (e)' are never reached._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `catch` clause is found that\ncan't be executed because it's after a `catch` clause of the form\n`catch (e)` or `on Object catch (e)`. The first `catch` clause that matches\nthe thrown object is selected, and both of those forms will match any\nobject, so no `catch` clauses that follow them will be selected.\n\n## Example\n\nThe following code produces this diagnostic:\n\n```dart\nvoid f() {\n  try {\n  } catch (e) {\n  } [!on String {!]\n  [!}!]\n}\n```\n\n## Common fixes\n\nIf the clause should be selectable, then move the clause before the general\nclause:\n\n```dart\nvoid f() {\n  try {\n  } on String {\n  } catch (e) {\n  }\n}\n```\n\nIf the clause doesn't need to be selectable, then remove it:\n\n```dart\nvoid f() {\n  try {\n  } catch (e) {\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "dead_code_on_catch_subtype",
    "description": "_Dead code: This on-catch block won't be executed because '{0}' is a subtype of '{1}' and hence will have been caught already._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `catch` clause is found that\ncan't be executed because it is after a `catch` clause that catches either\nthe same type or a supertype of the clause's type. The first `catch` clause\nthat matches the thrown object is selected, and the earlier clause always\nmatches anything matchable by the highlighted clause, so the highlighted\nclause will never be selected.\n\n## Example\n\nThe following code produces this diagnostic:\n\n```dart\nvoid f() {\n  try {\n  } on num {\n  } [!on int {!]\n  [!}!]\n}\n```\n\n## Common fixes\n\nIf the clause should be selectable, then move the clause before the general\nclause:\n\n```dart\nvoid f() {\n  try {\n  } on int {\n  } on num {\n  }\n}\n```\n\nIf the clause doesn't need to be selectable, then remove it:\n\n```dart\nvoid f() {\n  try {\n  } on num {\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "dead_null_aware_expression",
    "description": "_The left operand can't be null, so the right operand is never executed._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic in two cases.\n\nThe first is when the left operand of an `??` operator can't be `null`.\nThe right operand is only evaluated if the left operand has the value\n`null`, and because the left operand can't be `null`, the right operand is\nnever evaluated.\n\nThe second is when the left-hand side of an assignment using the `??=`\noperator can't be `null`. The right-hand side is only evaluated if the\nleft-hand side has the value `null`, and because the left-hand side can't\nbe `null`, the right-hand side is never evaluated.\n\n## Examples\n\nThe following code produces this diagnostic because `x` can't be `null`:\n\n```dart\nint f(int x) {\n  return x ?? [!0!];\n}\n```\n\nThe following code produces this diagnostic because `f` can't be `null`:\n\n```dart\nclass C {\n  int f = -1;\n\n  void m(int x) {\n    f ??= [!x!];\n  }\n}\n```\n\n## Common fixes\n\nIf the diagnostic is reported for an `??` operator, then remove the `??`\noperator and the right operand:\n\n```dart\nint f(int x) {\n  return x;\n}\n```\n\nIf the diagnostic is reported for an assignment, and the assignment isn't\nneeded, then remove the assignment:\n\n```dart\nclass C {\n  int f = -1;\n\n  void m(int x) {\n  }\n}\n```\n\nIf the assignment is needed, but should be based on a different condition,\nthen rewrite the code to use `=` and the different condition:\n\n```dart\nclass C {\n  int f = -1;\n\n  void m(int x) {\n    if (f < 0) {\n      f = x;\n    }\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "default_in_switch_expression",
    "description": "_A switch expression may not use the `default` keyword._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "default_list_constructor",
    "description": "_The default 'List' constructor isn't available when null safety is enabled._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it finds a use of the default\nconstructor for the class `List` in code that has opted in to null safety.\n\n## Example\n\nAssuming the following code is opted in to null safety, it produces this\ndiagnostic because it uses the default `List` constructor:\n\n```dart\nvar l = [!List<int>!]();\n```\n\n## Common fixes\n\nIf no initial size is provided, then convert the code to use a list\nliteral:\n\n```dart\nvar l = <int>[];\n```\n\nIf an initial size needs to be provided and there is a single reasonable\ninitial value for the elements, then use `List.filled`:\n\n```dart\nvar l = List.filled(3, 0);\n```\n\nIf an initial size needs to be provided but each element needs to be\ncomputed, then use `List.generate`:\n\n```dart\nvar l = List.generate(3, (i) => i);\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "default_value_in_function_type",
    "description": "_Parameters in a function type can't have default values._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a function type associated with\na parameter includes optional parameters that have a default value. This\nisn't allowed because the default values of parameters aren't part of the\nfunction's type, and therefore including them doesn't provide any value.\n\n## Example\n\nThe following code produces this diagnostic because the parameter `p` has a\ndefault value even though it's part of the type of the parameter `g`:\n\n```dart\nvoid f(void Function([int p [!=!] 0]) g) {\n}\n```\n\n## Common fixes\n\nRemove the default value from the function-type's parameter:\n\n```dart\nvoid f(void Function([int p]) g) {\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "default_value_in_redirecting_factory_constructor",
    "description": "_Default values aren't allowed in factory constructors that redirect to another constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a factory constructor that\nredirects to another constructor specifies a default value for an optional\nparameter.\n\n## Example\n\nThe following code produces this diagnostic because the factory constructor\nin `A` has a default value for the optional parameter `x`:\n\n```dart\nclass A {\n  factory A([int [!x!] = 0]) = B;\n}\n\nclass B implements A {\n  B([int x = 1]) {}\n}\n```\n\n## Common fixes\n\nRemove the default value from the factory constructor:\n\n```dart\nclass A {\n  factory A([int x]) = B;\n}\n\nclass B implements A {\n  B([int x = 1]) {}\n}\n```\n\nNote that this fix might change the value used when the optional parameter\nis omitted. If that happens, and if that change is a problem, then consider\nmaking the optional parameter a required parameter in the factory method:\n\n```dart\nclass A {\n factory A(int x) = B;\n}\n\nclass B implements A {\n  B([int x = 1]) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "default_value_on_required_parameter",
    "description": "_Required named parameters can't have a default value._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a named parameter has both the\n`required` modifier and a default value. If the parameter is required, then\na value for the parameter is always provided at the call sites, so the\ndefault value can never be used.\n\n## Example\n\nThe following code generates this diagnostic:\n\n```dart\nvoid log({required String [!message!] = 'no message'}) {}\n```\n\n## Common fixes\n\nIf the parameter is really required, then remove the default value:\n\n```dart\nvoid log({required String message}) {}\n```\n\nIf the parameter isn't always required, then remove the `required`\nmodifier:\n\n```dart\nvoid log({String message = 'no message'}) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "deferred_after_prefix",
    "description": "_The deferred keyword should come immediately before the prefix ('as' clause)._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "deferred_import_of_extension",
    "description": "_Imports of deferred libraries must hide all extensions._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a library that is imported using\na deferred import declares an extension that is visible in the importing\nlibrary. Extension methods are resolved at compile time, and extensions\nfrom deferred libraries aren't available at compile time.\n\nFor more information, check out\n[Lazily loading a library](https://dart.dev/language/libraries#lazily-loading-a-library).\n\n## Example\n\nGiven a file `a.dart` that defines a named extension:\n\n```dart\nclass C {}\n\nextension E on String {\n  int get size => length;\n}\n```\n\nThe following code produces this diagnostic because the named extension is\nvisible to the library:\n\n```dart\nimport [!'a.dart'!] deferred as a;\n\nvoid f() {\n  a.C();\n}\n```\n\n## Common fixes\n\nIf the library must be imported as `deferred`, then either add a `show`\nclause listing the names being referenced or add a `hide` clause listing\nall of the named extensions. Adding a `show` clause would look like this:\n\n```dart\nimport 'a.dart' deferred as a show C;\n\nvoid f() {\n  a.C();\n}\n```\n\nAdding a `hide` clause would look like this:\n\n```dart\nimport 'a.dart' deferred as a hide E;\n\nvoid f() {\n  a.C();\n}\n```\n\nWith the first fix, the benefit is that if new extensions are added to the\nimported library, then the extensions won't cause a diagnostic to be\ngenerated.\n\nIf the library doesn't need to be imported as `deferred`, or if you need to\nmake use of the extension method declared in it, then remove the keyword\n`deferred`:\n\n```dart\nimport 'a.dart' as a;\n\nvoid f() {\n  a.C();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "definitely_unassigned_late_local_variable",
    "description": "_The late local variable '{0}' is definitely unassigned at this point._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when [definite assignment][] analysis\nshows that a local variable that's marked as `late` is read before being\nassigned.\n\n## Example\n\nThe following code produces this diagnostic because `x` wasn't assigned a\nvalue before being read:\n\n```dart\nvoid f(bool b) {\n  late int x;\n  print([!x!]);\n}\n```\n\n## Common fixes\n\nAssign a value to the variable before reading from it:\n\n```dart\nvoid f(bool b) {\n  late int x;\n  x = b ? 1 : 0;\n  print(x);\n}\n```\n\n[definite assignment]: /resources/glossary#definite-assignment\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "dependencies_field_not_map",
    "description": "_The value of the '{0}' field is expected to be a map._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the value of either the\n`dependencies` or `dev_dependencies` key isn't a map.\n\n## Example\n\nThe following code produces this diagnostic because the value of the\ntop-level `dependencies` key is a list:\n\n```yaml\nname: example\ndependencies:\n  [!- meta!]\n```\n\n## Common fixes\n\nUse a map as the value of the `dependencies` key:\n\n```yaml\nname: example\ndependencies:\n  meta: ^1.0.2\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "deprecated_colon_for_default_value",
    "description": "_Using a colon as the separator before a default value is deprecated and will not be supported in language version 3.0 and later._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a colon (`:`) is used as the\nseparator before the default value of an optional named parameter.\nWhile this syntax is allowed, it is deprecated in favor of\nusing an equal sign (`=`).\n\n## Example\n\nThe following code produces this diagnostic because a colon is being used\nbefore the default value of the optional parameter `i`:\n\n```dart\nvoid f({int i [!:!] 0}) {}\n```\n\n## Common fixes\n\nReplace the colon with an equal sign.\n\n```dart\nvoid f({int i = 0}) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "deprecated_export_use",
    "description": "_The ability to import '{0}' indirectly is deprecated._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when one library imports a name from\na second library, and the second library exports the name from a third\nlibrary but has indicated that it won't export the third library in the\nfuture.\n\n## Example\n\nGiven a library `a.dart` defining the class `A`:\n\n```dart\nclass A {}\n```\n\nAnd a second library `b.dart` that exports `a.dart` but has marked the\nexport as being deprecated:\n\n```dart\nimport 'a.dart';\n\n@deprecated\nexport 'a.dart';\n```\n\nThe following code produces this diagnostic because the class `A` won't be\nexported from `b.dart` in some future version:\n\n```dart\nimport 'b.dart';\n\n[!A!]? a;\n```\n\n## Common fixes\n\nIf the name is available from a different library that you can import,\nthen replace the existing import with an import for that library (or add\nan import for the defining library if you still need the old import):\n\n```dart\nimport 'a.dart';\n\nA? a;\n```\n\nIf the name isn't available, then look for instructions from the library\nauthor or contact them directly to find out how to update your code.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "deprecated_extend",
    "description": "_Extending '{0}' is deprecated._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class annotated with\n`@Deprecated.extend` is used in the `extends` clause of a class\ndeclaration.\n\nThis annotation indicates that the ability to extend the annotated class\nis deprecated and will soon be removed. This change will likely be\nenforced by marking the class with `interface`, `final`, or `sealed`.\n\n## Example\n\nIf the library `p` defines a class annotated with `@Deprecated.extend`:\n\n```dart\n@Deprecated.extend()\nclass C {}\n```\n\nThen, in any library other than `p`, the following code produces this\ndiagnostic:\n\n```dart\nimport 'package:p/p.dart';\n\nclass D extends [!C!] {}\n```\n\n## Common fixes\n\nFollow any directions found in the `Deprecation.extend` annotation.\nOtherwise, remove the `extends` clause.\n\n```dart\nclass D {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "deprecated_factory_method",
    "description": "_Methods named 'factory' will become constructors when the primary\\_constructors feature is enabled._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "deprecated_field",
    "description": "_The '{0}' field is no longer used and can be removed._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a key is used in a\n`pubspec.yaml` file that was deprecated. Unused keys take up space and\nmight imply semantics that are no longer valid.\n\n## Example\n\nThe following code produces this diagnostic because the `author` key is no\nlonger being used:\n\n```dart\nname: example\nauthor: 'Dash'\n```\n\n## Common fixes\n\nRemove the deprecated key:\n\n```dart\nname: example\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "deprecated_implement",
    "description": "_Implementing '{0}' is deprecated._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class annotated with\n`@Deprecated.implement` is used in the `implements` clause of a class or\nenum declaration. This annotation indicates that the ability to implement\nthe annotated class is deprecated and will soon be removed. This change\nwill likely be enforced by marking the class with `interface`, `final`, or\n`sealed`.\n\n## Example\n\nIf the library `p` defines a class annotated with `@Deprecated.implement`:\n\n```dart\n@Deprecated.implement()\nclass C {}\n```\n\nThen, in any library other than `p`, the following code produces this\ndiagnostic:\n\n```dart\nimport 'package:p/p.dart';\n\nclass D implements [!C!] {}\n```\n\n## Common fixes\n\nFollow any directions found in the `Deprecation.implement` annotation.\nOtherwise, remove the `implements` clause.\n\n```dart\nclass D {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "deprecated_instantiate",
    "description": "_Instantiating '{0}' is deprecated._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class annotated with\n`@Deprecated.instantiate` is instantiated. This annotation indicates that\ninstantiating the class is deprecated and will soon be removed. This\nchange will likely be enforced by marking the class as `abstract` or\n`sealed`.\n\n## Example\n\nIf the library `p` defines a class annotated with\n`@Deprecated.instantiate`:\n\n```dart\n@Deprecated.instantiate()\nclass C {}\n```\n\nThen, in any library other than `p`, the following code produces this\ndiagnostic:\n\n```dart\nimport 'package:p/p.dart';\n\nvar c = [!C!]();\n```\n\n## Common fixes\n\nFollow any directions found in the `Deprecation.instantiate` annotation.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "deprecated_lint",
    "description": "_The lint rule '{0}' is deprecated and shouldn't be enabled._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an enabled lint rule is\ndeprecated.\n\n## Example\n\nThe following code produces this diagnostic because the rule\n`always_specify_types` is deprecated:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nlinter:\n  rules:\n    - [!always_specify_types!]\n    - annotate_overrides\n```\n\n## Common fixes\n\nIf a replacement rule exists, enable it:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nlinter:\n  rules:\n    - annotate_overrides\n    - specify_nonobvious_property_types\n```\n\nIf no replacement rule exists, remove the deprecated lint rule from the\nlist:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nlinter:\n  rules:\n    - annotate_overrides\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "deprecated_lint_with_replacement",
    "description": "_The lint rule '{0}' is deprecated and replaced by '{1}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "deprecated_member_use",
    "description": "_'{0}' is deprecated and shouldn't be used._\n\n_'{0}' is deprecated and shouldn't be used. {1}_",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a deprecated library or class\nmember is used in a different package.\n\n## Example\n\nIf the method `m` in the class `C` is annotated with `@deprecated`, then\nthe following code produces this diagnostic:\n\n```dart\nvoid f(C c) {\n  c.[!m!]();\n}\n```\n\n## Common fixes\n\nThe documentation for declarations that are annotated with `@deprecated`\nshould indicate what code to use in place of the deprecated code.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "deprecated_mixin",
    "description": "_Mixing in '{0}' is deprecated._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a mixin class annotated with\n`@Deprecated.mixin` is used in the `with` clause of a class or enum\ndeclaration. This annotation indicates that using the annotated mixin is\ndeprecated and will soon be removed. This change will likely be enforced\nby removing the `mixin` class modifier.\n\n## Example\n\nIf the library `p` defines a class annotated with `@Deprecated.mixin`:\n\n```dart\n@Deprecated.mixin()\nmixin class C {}\n```\n\nThen, in any library other than `p`, the following code produces this\ndiagnostic:\n\n```dart\nimport 'package:p/p.dart';\n\nclass D with [!C!] {}\n```\n\n## Common fixes\n\nFollow any directions found in the `Deprecation.mixin` annotation.\nOtherwise, remove the mixin class name from the `with` clause.\n\n```dart\nclass D {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "deprecated_new_in_comment_reference",
    "description": "_Using the 'new' keyword in a comment reference is deprecated._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a comment reference (the name\nof a declaration enclosed in square brackets in a documentation comment)\nuses the keyword `new` to refer to a constructor. This form is deprecated.\n\n## Examples\n\nThe following code produces this diagnostic because the unnamed\nconstructor is being referenced using `new C`:\n\n```dart\n/// See [[!new!] C].\nclass C {\n  C();\n}\n```\n\nThe following code produces this diagnostic because the constructor named\n`c` is being referenced using `new C.c`:\n\n```dart\n/// See [[!new!] C.c].\nclass C {\n  C.c();\n}\n```\n\n## Common fixes\n\nIf you're referencing a named constructor, then remove the keyword `new`:\n\n```dart\n/// See [C.c].\nclass C {\n  C.c();\n}\n```\n\nIf you're referencing the unnamed constructor, then remove the keyword\n`new` and append `.new` after the class name:\n\n```dart\n/// See [C.new].\nclass C {\n  C.c();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "deprecated_optional",
    "description": "_Omitting an argument for the '{0}' parameter is deprecated._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an argument is omitted for an\noptional parameter annotated with `@Deprecated.optional`. This annotation\nindicates that omitting an argument for the parameter is deprecated, and\nthe parameter will soon become required.\n\n## Example\n\nGiven a library `p` that defines a function with an optional parameter\nannotated with `@Deprecated.optional`:\n\n```dart\nvoid f({@Deprecated.optional() int a = 0}) {}\n```\n\nThe following code produces this diagnostic, because the invocation\ndoesn't pass a value for the parameter `a`:\n\n```dart\nimport 'package:p/p.dart';\n\nvoid g() {\n  [!f!]();\n}\n```\n\n## Common fixes\n\nFollow any specific instructions provided in the `@Deprecated.optional`\nannotation.\n\nIf no instructions are present, pass an appropriate argument for the\ncorresponding parameter:\n\n\n```dart\nimport 'package:p/p.dart';\n\nvoid g() {\n  f(a: 0);\n}\n```\n\nUsing the default value will preserve the current behavior of the code.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "deprecated_subclass",
    "description": "_Subclassing '{0}' is deprecated._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class annotated with\n`@Deprecated.subclass` is used in the `extends` clause of a class\ndeclaration, or the `implements` clause of a class or enum declaration.\n\nThis annotation indicates that extending or implementing the annotated\nclass is deprecated and will soon be removed. This change will likely be\nenforced by marking the class with `final` or `sealed`.\n\n## Example\n\nIf the library `p` defines a class annotated with `@Deprecated.subclass`:\n\n```dart\n@Deprecated.subclass()\nclass C {}\n```\n\nThen, in any library other than `p`, the following code produces this\ndiagnostic:\n\n```dart\nimport 'package:p/p.dart';\n\nclass D extends [!C!] {}\n```\n\n## Common fixes\n\nFollow any specific instructions provided in the `@Deprecated.subclass`\nannotation. Otherwise, remove the relevant `extends` clause or remove the\nclass name from the `implements` clause:\n\n```dart\nclass D {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "deprecated_subtype_of_function",
    "description": "_Extending 'Function' is deprecated._\n\n_Implementing 'Function' has no effect._\n\n_Mixing in 'Function' is deprecated._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the class `Function` is used in\neither the `extends`, `implements`, or `with` clause of a class or mixin.\nUsing the class `Function` in this way has no semantic value, so it's\neffectively dead code.\n\n## Example\n\nThe following code produces this diagnostic because `Function` is used as\nthe superclass of `F`:\n\n```dart\nclass F extends [!Function!] {}\n```\n\n## Common fixes\n\nRemove the class `Function` from whichever clause it's in, and remove the\nwhole clause if `Function` is the only type in the clause:\n\n```dart\nclass F {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "directive_after_declaration",
    "description": "_Directives must appear before any declarations._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "disallowed_type_instantiation_expression",
    "description": "_Only a generic type, generic function, generic instance method, or generic constructor can have type arguments._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an expression with a value that\nis anything other than one of the allowed kinds of values is followed by\ntype arguments. The allowed kinds of values are:\n- generic types,\n- generic constructors, and\n- generic functions, including top-level functions, static and instance\n  members, and local functions.\n\n## Example\n\nThe following code produces this diagnostic because `i` is a top-level\nvariable, which isn't one of the allowed cases:\n\n```dart\nint i = 1;\n\nvoid f() {\n  print([!i!]<int>);\n}\n```\n\n## Common fixes\n\nIf the referenced value is correct, then remove the type arguments:\n\n```dart\nint i = 1;\n\nvoid f() {\n  print(i);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "division_optimization",
    "description": "_The operator x ~/ y is more efficient than (x / y).toInt()._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the result of dividing two\nnumbers is converted to an integer using `toInt`. Dart has a built-in\ninteger division operator that is both more efficient and more concise.\n\n## Example\n\nThe following code produces this diagnostic because the result of dividing\n`x` and `y` is converted to an integer using `toInt`:\n\n```dart\nint divide(int x, int y) => [!(x / y).toInt()!];\n```\n\n## Common fixes\n\nUse the integer division operator (`~/`):\n\n```dart\nint divide(int x, int y) => x ~/ y;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "doc_directive_argument_wrong_format",
    "description": "_The '{0}' argument must be formatted as {1}._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "doc_directive_has_extra_arguments",
    "description": "_The '{0}' directive has '{1}' arguments, but only '{2}' are expected._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "doc_directive_has_unexpected_named_argument",
    "description": "_The '{0}' directive has an unexpected named argument, '{1}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "doc_directive_missing_argument",
    "description": "_The '{0}' directive is missing a '{1}' and a '{2}' argument._\n\n_The '{0}' directive is missing a '{1}' argument._\n\n_The '{0}' directive is missing a '{1}', a '{2}', and a '{3}' argument._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "doc_directive_missing_closing_brace",
    "description": "_Doc directive is missing a closing curly brace ('}')._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "doc_directive_missing_closing_tag",
    "description": "_Doc directive is missing a closing tag._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "doc_directive_missing_opening_tag",
    "description": "_Doc directive is missing an opening tag._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "doc_directive_unknown",
    "description": "_Doc directive '{0}' is unknown._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "doc_import_cannot_be_deferred",
    "description": "_Doc imports can't be deferred._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a documentation import uses the\n`deferred` keyword.\n\nDocumentation imports can't be deferred because deferring them wouldn't\nimpact the size of the compiled code.\n\n## Example\n\nThe following code produces this diagnostic because the documentation\nimport has a `deferred` keyword:\n\n```dart\n// ignore:missing_prefix_in_deferred_import\n/// @docImport 'package:meta/meta.dart' [!deferred!];\nlibrary;\n```\n\n## Common fixes\n\nRemove the `deferred` keyword:\n\n```dart\n/// @docImport 'package:meta/meta.dart';\nlibrary;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "doc_import_cannot_have_combinators",
    "description": "_Doc imports can't have show or hide combinators._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a documentation import has one\nor more `hide` or `show` combinators.\n\nUsing combinators isn't supported for documentation imports.\n\n## Example\n\nThe following code produces this diagnostic because the documentation\nimport has a `show` combinator:\n\n```dart\n/// @docImport 'package:meta/meta.dart' [!show max!];\nlibrary;\n```\n\n## Common fixes\n\nRemove the `hide` and `show` combinators:\n\n```dart\n/// @docImport 'package:meta/meta.dart';\nlibrary;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "doc_import_cannot_have_configurations",
    "description": "_Doc imports can't have configurations._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a documentation import has one\nor more `if` clauses.\n\nDocumentation imports aren't configurable.\n\n## Example\n\nThe following code produces this diagnostic because the documentation\nimport has an `if` clause:\n\n```dart\n/// @docImport 'package:meta/meta.dart' [!if (dart.library.io) 'dart:io'!];\nlibrary;\n```\n\n## Common fixes\n\nRemove the `if` clauses:\n\n```dart\n/// @docImport 'package:meta/meta.dart';\nlibrary;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "doc_import_cannot_have_prefix",
    "description": "_Doc imports can't have prefixes._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a documentation import has a\nprefix.\n\nUsing prefixes isn't supported for documentation imports.\n\n## Example\n\nThe following code produces this diagnostic because the documentation\nimport declares a prefix:\n\n```dart\n/// @docImport 'package:meta/meta.dart' as [!a!];\nlibrary;\n```\n\n## Common fixes\n\nRemove the prefix:\n\n```dart\n/// @docImport 'package:meta/meta.dart';\nlibrary;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "dot_shorthand_missing_context",
    "description": "_A dot shorthand can't be used where there is no context type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a dot shorthand is used where\nthere is no context type.\n\n## Example\n\nThe following code produces this diagnostic because there is no context\ntype for the expression `.a`:\n\n```dart\nvoid f() {\n  var e = [!.a!];\n  print(e);\n}\n\nenum E {a, b}\n```\n\n## Common fixes\n\nIf you want to use a dot shorthand, then add a context type, which in this\nexample means adding the explicit type `E` to the local variable:\n\n```dart\nvoid f() {\n  E e = .a;\n  print(e);\n}\n\nenum E {a, b}\n```\n\nIf you don't want to add a context type, then specify the name of the\ntype containing the member being referenced, which in this case is `E`:\n\n```dart\nvoid f() {\n  var e = E.a;\n  print(e);\n}\n\nenum E {a, b}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "dot_shorthand_undefined_member",
    "description": "_The static getter '{0}' isn't defined for the context type '{1}'._\n\n_The static method or constructor '{0}' isn't defined for the context type '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a dot shorthand is used to\nreference a member, but that member doesn't exist.\n\n## Example\n\nThe following code produces this diagnostic because the enum `E` doesn't\ndefine a static member named `c`:\n\n```dart\nvoid f() {\n  E e = .[!c!];\n  print(e);\n}\n\nenum E {a, b}\n```\n\n## Common fixes\n\nIf the name is correct, then define a member with that name in the context\ntype, which in this case is the enum `E`:\n\n```dart\nvoid f() {\n  E e = .c;\n  print(e);\n}\n\nenum E {a, b, c}\n```\n\nIf the name is not correct, then replace the name with the name of an\nexisting member from the context type, which in this case is the enum `E`:\n\n```dart\nvoid f() {\n  E e = .b;\n  print(e);\n}\n\nenum E {a, b}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "duplicated_modifier",
    "description": "_The modifier '{0}' was already specified._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "duplicate_constructor",
    "description": "_The constructor with name '{0}' is already defined._\n\n_The unnamed constructor is already defined._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class declares more than one\nunnamed constructor or when it declares more than one constructor with the\nsame name.\n\n## Examples\n\nThe following code produces this diagnostic because there are two\ndeclarations for the unnamed constructor:\n\n```dart\nclass C {\n  C();\n\n  [!C!]();\n}\n```\n\nThe following code produces this diagnostic because there are two\ndeclarations for the constructor named `m`:\n\n```dart\nclass C {\n  C.m();\n\n  [!C.m!]();\n}\n```\n\n## Common fixes\n\nIf there are multiple unnamed constructors and all of the constructors are\nneeded, then give all of them, or all except one of them, a name:\n\n```dart\nclass C {\n  C();\n\n  C.n();\n}\n```\n\nIf there are multiple unnamed constructors and all except one of them are\nunneeded, then remove the constructors that aren't needed:\n\n```dart\nclass C {\n  C();\n}\n```\n\nIf there are multiple named constructors and all of the constructors are\nneeded, then rename all except one of them:\n\n```dart\nclass C {\n  C.m();\n\n  C.n();\n}\n```\n\nIf there are multiple named constructors and all except one of them are\nunneeded, then remove the constructors that aren't needed:\n\n```dart\nclass C {\n  C.m();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "duplicate_deferred",
    "description": "_An import directive can only have one 'deferred' keyword._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "duplicate_definition",
    "description": "_The name '{0}' is already defined._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a name is declared, and there is\na previous declaration with the same name in the same scope.\n\n## Example\n\nThe following code produces this diagnostic because the name `x` is\ndeclared twice:\n\n```dart\nint x = 0;\nint [!x!] = 1;\n```\n\n## Common fixes\n\nChoose a different name for one of the declarations.\n\n```dart\nint x = 0;\nint y = 1;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "duplicate_export",
    "description": "_Duplicate export._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an export directive is found\nthat is the same as an export before it in the file. The second export\ndoesn't add value and should be removed.\n\n## Example\n\nThe following code produces this diagnostic because the same library is\nbeing exported twice:\n\n```dart\nexport 'package:meta/meta.dart';\nexport [!'package:meta/meta.dart'!];\n```\n\n## Common fixes\n\nRemove the unnecessary export:\n\n```dart\nexport 'package:meta/meta.dart';\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "duplicate_field_formal_parameter",
    "description": "_The field '{0}' can't be initialized by multiple parameters in the same constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when there's more than one\ninitializing formal parameter for the same field in a constructor's\nparameter list. It isn't useful to assign a value that will immediately be\noverwritten.\n\n## Example\n\nThe following code produces this diagnostic because `this.f` appears twice\nin the parameter list:\n\n```dart\nclass C {\n  int f;\n\n  C(this.f, this.[!f!]) {}\n}\n```\n\n## Common fixes\n\nRemove one of the initializing formal parameters:\n\n```dart\nclass C {\n  int f;\n\n  C(this.f) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "duplicate_field_name",
    "description": "_The field name '{0}' is already used in this record._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when either a record literal or a\nrecord type annotation contains a field whose name is the same as a\npreviously declared field in the same literal or type.\n\n## Examples\n\nThe following code produces this diagnostic because the record literal has\ntwo fields named `a`:\n\n```dart\nvar r = (a: 1, [!a!]: 2);\n```\n\nThe following code produces this diagnostic because the record type\nannotation has two fields named `a`, one a positional field and the other\na named field:\n\n```dart\nvoid f((int a, {int [!a!]}) r) {}\n```\n\n## Common fixes\n\nRename one or both of the fields:\n\n```dart\nvar r = (a: 1, b: 2);\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "duplicate_hidden_name",
    "description": "_Duplicate hidden name._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a name occurs multiple times in\na `hide` clause. Repeating the name is unnecessary.\n\n## Example\n\nThe following code produces this diagnostic because the name `min` is\nhidden more than once:\n\n```dart\nimport 'dart:math' hide min, [!min!];\n\nvar x = pi;\n```\n\n## Common fixes\n\nIf the name was mistyped in one or more places, then correct the mistyped\nnames:\n\n```dart\nimport 'dart:math' hide max, min;\n\nvar x = pi;\n```\n\nIf the name wasn't mistyped, then remove the unnecessary name from the\nlist:\n\n```dart\nimport 'dart:math' hide min;\n\nvar x = pi;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "duplicate_ignore",
    "description": "_The diagnostic '{0}' doesn't need to be ignored here because it's already being ignored._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a diagnostic name appears in an\n`ignore` comment, but the diagnostic is already being ignored, either\nbecause it's already included in the same `ignore` comment or because it\nappears in an `ignore-in-file` comment.\n\n## Examples\n\nThe following code produces this diagnostic because the diagnostic named\n`unused_local_variable` is already being ignored for the whole file so it\ndoesn't need to be ignored on a specific line:\n\n```dart\n// ignore_for_file: unused_local_variable\nvoid f() {\n  // ignore: [!unused_local_variable!]\n  var x = 0;\n}\n```\n\nThe following code produces this diagnostic because the diagnostic named\n`unused_local_variable` is being ignored twice on the same line:\n\n```dart\nvoid f() {\n  // ignore: unused_local_variable, [!unused_local_variable!]\n  var x = 0;\n}\n```\n\n## Common fixes\n\nRemove the ignore comment, or remove the unnecessary diagnostic name if the\nignore comment is ignoring more than one diagnostic:\n\n```dart\n// ignore_for_file: unused_local_variable\nvoid f() {\n  var x = 0;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "duplicate_import",
    "description": "_Duplicate import._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an import directive is found\nthat is the same as an import before it in the file. The second import\ndoesn't add value and should be removed.\n\n## Example\n\nThe following code produces this diagnostic:\n\n```dart\nimport 'package:meta/meta.dart';\nimport [!'package:meta/meta.dart'!];\n\n@sealed class C {}\n```\n\n## Common fixes\n\nRemove the unnecessary import:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@sealed class C {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "duplicate_label_in_switch_statement",
    "description": "_The label '{0}' was already used in this switch statement._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "duplicate_named_argument",
    "description": "_The argument for the named parameter '{0}' was already specified._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an invocation has two or more\nnamed arguments that have the same name.\n\n## Example\n\nThe following code produces this diagnostic because there are two arguments\nwith the name `a`:\n\n```dart\nvoid f(C c) {\n  c.m(a: 0, [!a!]: 1);\n}\n\nclass C {\n  void m({int? a, int? b}) {}\n}\n```\n\n## Common fixes\n\nIf one of the arguments should have a different name, then change the name:\n\n```dart\nvoid f(C c) {\n  c.m(a: 0, b: 1);\n}\n\nclass C {\n  void m({int? a, int? b}) {}\n}\n```\n\nIf one of the arguments is wrong, then remove it:\n\n```dart\nvoid f(C c) {\n  c.m(a: 1);\n}\n\nclass C {\n  void m({int? a, int? b}) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "duplicate_part",
    "description": "_The library already contains a part with the URI '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a single file is referenced in\nmultiple part directives.\n\n## Example\n\nGiven a file `part.dart` containing\n\n```dart\npart of 'test.dart';\n```\n\nThe following code produces this diagnostic because the file `part.dart` is\nincluded multiple times:\n\n```dart\npart 'part.dart';\npart [!'part.dart'!];\n```\n\n## Common fixes\n\nRemove all except the first of the duplicated part directives:\n\n```dart\npart 'part.dart';\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "duplicate_pattern_assignment_variable",
    "description": "_The variable '{0}' is already assigned in this pattern._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a single pattern variable is\nassigned a value more than once in the same pattern assignment.\n\n## Example\n\nThe following code produces this diagnostic because the variable `a` is\nassigned twice in the pattern `(a, a)`:\n\n```dart\nint f((int, int) r) {\n  int a;\n  (a, [!a!]) = r;\n  return a;\n}\n```\n\n## Common fixes\n\nIf you need to capture all of the values, then use a unique variable for\neach of the subpatterns being matched:\n\n```dart\nint f((int, int) r) {\n  int a, b;\n  (a, b) = r;\n  return a + b;\n}\n```\n\nIf some of the values don't need to be captured, then use a wildcard\npattern `_` to avoid having to bind the value to a variable:\n\n```dart\nint f((int, int) r) {\n  int a;\n  (_, a) = r;\n  return a;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "duplicate_pattern_field",
    "description": "_The field '{0}' is already matched in this pattern._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a record pattern matches the\nsame field more than once, or when an object pattern matches the same\ngetter more than once.\n\n## Examples\n\nThe following code produces this diagnostic because the record field `a`\nis matched twice in the same record pattern:\n\n```dart\nvoid f(({int a, int b}) r) {\n  switch (r) {\n    case (a: 1, [!a!]: 2):\n      return;\n  }\n}\n```\n\nThe following code produces this diagnostic because the getter `f` is\nmatched twice in the same object pattern:\n\n```dart\nvoid f(Object o) {\n  switch (o) {\n    case C(f: 1, [!f!]: 2):\n      return;\n  }\n}\nclass C {\n  int? f;\n}\n```\n\n## Common fixes\n\nIf the pattern should match for more than one value of the duplicated\nfield, then use a logical-or pattern:\n\n```dart\nvoid f(({int a, int b}) r) {\n  switch (r) {\n    case (a: 1, b: _) || (a: 2, b: _):\n      break;\n  }\n}\n```\n\nIf the pattern should match against multiple fields, then change the name\nof one of the fields:\n\n```dart\nvoid f(({int a, int b}) r) {\n  switch (r) {\n    case (a: 1, b: 2):\n      return;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "duplicate_prefix",
    "description": "_An import directive can only have one prefix ('as' clause)._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "duplicate_rest_element_in_pattern",
    "description": "_At most one rest element is allowed in a list or map pattern._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when there's more than one rest\npattern in either a list or map pattern. A rest pattern will capture any\nvalues unmatched by other subpatterns, making subsequent rest patterns\nunnecessary because there's nothing left to capture.\n\n## Example\n\nThe following code produces this diagnostic because there are two rest\npatterns in the list pattern:\n\n```dart\nvoid f(List<int> x) {\n  if (x case [0, ..., [!...!]]) {}\n}\n```\n\n## Common fixes\n\nRemove all but one of the rest patterns:\n\n```dart\nvoid f(List<int> x) {\n  if (x case [0, ...]) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "duplicate_rule",
    "description": "_The rule '{0}' is already enabled and doesn't need to be enabled again._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the same lint rule is listed\nmore than once in the linter/rules section.\n\n## Example\n\nThe following code produces this diagnostic because the lint rule\n`avoid_print` appears twice in the list of enabled rules:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nlinter:\n  rules:\n    - avoid_print\n    - [!avoid_print!]\n```\n\n## Common fixes\n\nRemove the duplicates:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nlinter:\n  rules:\n    - avoid_print\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "duplicate_shown_name",
    "description": "_Duplicate shown name._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a name occurs multiple times in\na `show` clause. Repeating the name is unnecessary.\n\n## Example\n\nThe following code produces this diagnostic because the name `min` is shown\nmore than once:\n\n```dart\nimport 'dart:math' show min, [!min!];\n\nvar x = min(2, min(0, 1));\n```\n\n## Common fixes\n\nIf the name was mistyped in one or more places, then correct the mistyped\nnames:\n\n```dart\nimport 'dart:math' show max, min;\n\nvar x = max(2, min(0, 1));\n```\n\nIf the name wasn't mistyped, then remove the unnecessary name from the\nlist:\n\n```dart\nimport 'dart:math' show min;\n\nvar x = min(2, min(0, 1));\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "duplicate_variable_pattern",
    "description": "_The variable '{0}' is already defined in this pattern._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a branch of a logical-and\npattern declares a variable that is already declared in an earlier branch\nof the same pattern.\n\n## Example\n\nThe following code produces this diagnostic because the variable `a` is\ndeclared in both branches of the logical-and pattern:\n\n```dart\nvoid f((int, int) r) {\n  if (r case (var a, 0) && (0, var [!a!])) {\n    print(a);\n  }\n}\n```\n\n## Common fixes\n\nIf you need to capture the matched value in multiple branches, then change\nthe names of the variables so that they are unique:\n\n```dart\nvoid f((int, int) r) {\n  if (r case (var a, 0) && (0, var b)) {\n    print(a + b);\n  }\n}\n```\n\nIf you only need to capture the matched value on one branch, then remove\nthe variable pattern from all but one branch:\n\n```dart\nvoid f((int, int) r) {\n  if (r case (var a, 0) && (0, _)) {\n    print(a);\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "empty_enum_body",
    "description": "_An enum must declare at least one constant name._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "empty_map_pattern",
    "description": "_A map pattern must have at least one entry._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a map pattern is empty.\n\n## Example\n\nThe following code produces this diagnostic because the map pattern\nis empty:\n\n```dart\nvoid f(Map<int, String> x) {\n  if (x case [!{}!]) {}\n}\n```\n\n## Common fixes\n\nIf the pattern should match any map, then replace it with an object\npattern:\n\n```dart\nvoid f(Map<int, String> x) {\n  if (x case Map()) {}\n}\n```\n\nIf the pattern should only match an empty map, then check the length\nin the pattern:\n\n```dart\nvoid f(Map<int, String> x) {\n  if (x case Map(isEmpty: true)) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "empty_record_literal_with_comma",
    "description": "_A record literal without fields can't have a trailing comma._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a record literal that has no\nfields has a trailing comma. Empty record literals can't contain a comma.\n\n## Example\n\nThe following code produces this diagnostic because the empty record\nliteral has a trailing comma:\n\n```dart\nvar r = ([!,!]);\n```\n\n## Common fixes\n\nIf the record is intended to be empty, then remove the comma:\n\n```dart\nvar r = ();\n```\n\nIf the record is intended to have one or more fields, then add the\nexpressions used to compute the values of those fields:\n\n```dart\nvar r = (3, 4);\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "empty_record_type_named_fields_list",
    "description": "_The list of named fields in a record type can't be empty._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a record type has an empty list\nof named fields.\n\n## Example\n\nThe following code produces this diagnostic because the record type has an\nempty list of named fields:\n\n```dart\nvoid f((int, int, {[!}!]) r) {}\n```\n\n## Common fixes\n\nIf the record is intended to have named fields, then add the types and\nnames of the fields:\n\n```dart\nvoid f((int, int, {int z}) r) {}\n```\n\nIf the record isn't intended to have named fields, then remove the curly\nbraces:\n\n```dart\nvoid f((int, int) r) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "empty_record_type_with_comma",
    "description": "_A record type without fields can't have a trailing comma._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a record type that has no\nfields has a trailing comma. Empty record types can't contain a comma.\n\n## Example\n\nThe following code produces this diagnostic because the empty record type\nhas a trailing comma:\n\n```dart\nvoid f(([!,!]) r) {}\n```\n\n## Common fixes\n\nIf the record type is intended to be empty, then remove the comma:\n\n```dart\nvoid f(() r) {}\n```\n\nIf the record type is intended to have one or more fields, then add the\ntypes of those fields:\n\n```dart\nvoid f((int, int) r) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "empty_struct",
    "description": "_The class '{0}' can't be empty because it's a subclass of '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a subclass of `Struct` or\n`Union` doesn't have any fields. Having an empty `Struct` or `Union`\nisn't supported.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the class `C`, which\nextends `Struct`, doesn't declare any fields:\n\n```dart\nimport 'dart:ffi';\n\nfinal class [!C!] extends Struct {}\n```\n\n## Common fixes\n\nIf the class is intended to be a struct, then declare one or more fields:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Int32()\n  external int x;\n}\n```\n\nIf the class is intended to be used as a type argument to `Pointer`, then\nmake it a subclass of `Opaque`:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Opaque {}\n```\n\nIf the class isn't intended to be a struct, then remove or change the\nextends clause:\n\n```dart\nclass C {}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "encoding",
    "description": "_Unable to decode bytes as UTF-8._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "enum_constant_invokes_factory_constructor",
    "description": "_An enum value can't invoke a factory constructor._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "enum_constant_same_name_as_enclosing",
    "description": "_The name of the enum value can't be the same as the enum's name._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an enum value has the same name\nas the enum in which it's declared.\n\n## Example\n\nThe following code produces this diagnostic because the enum value `E` has\nthe same name as the enclosing enum `E`:\n\n```dart\nenum E {\n  [!E!]\n}\n```\n\n## Common fixes\n\nIf the name of the enum is correct, then rename the constant:\n\n```dart\nenum E {\n  e\n}\n```\n\nIf the name of the constant is correct, then rename the enum:\n\n```dart\nenum F {\n  E\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "enum_constant_with_non_const_constructor",
    "description": "_The invoked constructor isn't a 'const' constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an enum value is being created\nusing either a factory constructor or a generative constructor that isn't\nmarked as being `const`.\n\n## Example\n\nThe following code produces this diagnostic because the enum value `e` is\nbeing initialized by a factory constructor:\n\n```dart\nenum E {\n  [!e!]();\n\n  factory E() => e;\n}\n```\n\n## Common fixes\n\nUse a generative constructor marked as `const`:\n\n```dart\nenum E {\n  e._();\n\n  factory E() => e;\n\n  const E._();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "enum_instantiated_to_bounds_is_not_well_bounded",
    "description": "_The result of instantiating the enum to bounds is not well-bounded._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "enum_in_class",
    "description": "_Enums can't be declared inside classes._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "enum_mixin_with_instance_variable",
    "description": "_Mixins applied to enums can't have instance variables._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a mixin that's applied to an\nenum declares one or more instance variables. This isn't allowed because\nthe enum values are constant, and there isn't any way for the constructor\nin the enum to initialize any of the mixin's fields.\n\n## Example\n\nThe following code produces this diagnostic because the mixin `M` defines\nthe instance field `x`:\n\n```dart\nmixin M {\n  int x = 0;\n}\n\nenum E with [!M!] {\n  a\n}\n```\n\n## Common fixes\n\nIf you need to apply the mixin, then change all instance fields into\ngetter and setter pairs and implement them in the enum if necessary:\n\n```dart\nmixin M {\n  int get x => 0;\n}\n\nenum E with M {\n  a\n}\n```\n\nIf you don't need to apply the mixin, then remove it:\n\n```dart\nenum E {\n  a\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "enum_without_constants",
    "description": "_The enum must have at least one enum constant._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "enum_with_abstract_member",
    "description": "_'{0}' must have a method body because '{1}' is an enum._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a member of an enum is found\nthat doesn't have a concrete implementation. Enums aren't allowed to\ncontain abstract members.\n\n## Example\n\nThe following code produces this diagnostic because `m` is an abstract\nmethod and `E` is an enum:\n\n```dart\nenum E {\n  e;\n\n  [!void m();!]\n}\n```\n\n## Common fixes\n\nProvide an implementation for the member:\n\n```dart\nenum E {\n  e;\n\n  void m() {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "enum_with_name_values",
    "description": "_The name 'values' is not a valid name for an enum._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an enum is declared to have the\nname `values`. This isn't allowed because the enum has an implicit static\nfield named `values`, and the two would collide.\n\n## Example\n\nThe following code produces this diagnostic because there's an enum\ndeclaration that has the name `values`:\n\n```dart\nenum [!values!] {\n  c\n}\n```\n\n## Common fixes\n\nRename the enum to something other than `values`.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "equality_cannot_be_equality_operand",
    "description": "_A comparison expression can't be an operand of another comparison expression._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "equal_elements_in_const_set",
    "description": "_Two elements in a constant set literal can't be equal._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when two elements in a constant set\nliteral have the same value. The set can only contain each value once,\nwhich means that one of the values is unnecessary.\n\n## Example\n\nThe following code produces this diagnostic because the string `'a'` is\nspecified twice:\n\n```dart\nconst Set<String> set = {'a', [!'a'!]};\n```\n\n## Common fixes\n\nRemove one of the duplicate values:\n\n```dart\nconst Set<String> set = {'a'};\n```\n\nNote that literal sets preserve the order of their elements, so the choice\nof which element to remove might affect the order in which elements are\nreturned by an iterator.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "equal_elements_in_set",
    "description": "_Two elements in a set literal shouldn't be equal._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an element in a non-constant set\nis the same as a previous element in the same set. If two elements are the\nsame, then the second value is ignored, which makes having both elements\npointless and likely signals a bug.\n\n## Example\n\nThe following code produces this diagnostic because the element `1` appears\ntwice:\n\n```dart\nconst a = 1;\nconst b = 1;\nvar s = <int>{a, [!b!]};\n```\n\n## Common fixes\n\nIf both elements should be included in the set, then change one of the\nelements:\n\n```dart\nconst a = 1;\nconst b = 2;\nvar s = <int>{a, b};\n```\n\nIf only one of the elements is needed, then remove the one that isn't\nneeded:\n\n```dart\nconst a = 1;\nvar s = <int>{a};\n```\n\nNote that literal sets preserve the order of their elements, so the choice\nof which element to remove might affect the order in which elements are\nreturned by an iterator.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "equal_keys_in_const_map",
    "description": "_Two keys in a constant map literal can't be equal._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a key in a constant map is the\nsame as a previous key in the same map. If two keys are the same, then the\nsecond value would overwrite the first value, which makes having both pairs\npointless.\n\n## Example\n\nThe following code produces this diagnostic because the key `1` is used\ntwice:\n\n```dart\nconst map = <int, String>{1: 'a', 2: 'b', [!1!]: 'c', 4: 'd'};\n```\n\n## Common fixes\n\nIf both entries should be included in the map, then change one of the keys\nto be different:\n\n```dart\nconst map = <int, String>{1: 'a', 2: 'b', 3: 'c', 4: 'd'};\n```\n\nIf only one of the entries is needed, then remove the one that isn't\nneeded:\n\n```dart\nconst map = <int, String>{1: 'a', 2: 'b', 4: 'd'};\n```\n\nNote that literal maps preserve the order of their entries, so the choice\nof which entry to remove might affect the order in which keys and values\nare returned by an iterator.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "equal_keys_in_map",
    "description": "_Two keys in a map literal shouldn't be equal._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a key in a non-constant map is\nthe same as a previous key in the same map. If two keys are the same, then\nthe second value overwrites the first value, which makes having both pairs\npointless and likely signals a bug.\n\n## Example\n\nThe following code produces this diagnostic because the keys `a` and `b`\nhave the same value:\n\n```dart\nconst a = 1;\nconst b = 1;\nvar m = <int, String>{a: 'a', [!b!]: 'b'};\n```\n\n## Common fixes\n\nIf both entries should be included in the map, then change one of the keys:\n\n```dart\nconst a = 1;\nconst b = 2;\nvar m = <int, String>{a: 'a', b: 'b'};\n```\n\nIf only one of the entries is needed, then remove the one that isn't\nneeded:\n\n```dart\nconst a = 1;\nvar m = <int, String>{a: 'a'};\n```\n\nNote that literal maps preserve the order of their entries, so the choice\nof which entry to remove might affect the order in which the keys and\nvalues are returned by an iterator.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "equal_keys_in_map_pattern",
    "description": "_Two keys in a map pattern can't be equal._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a map pattern contains more\nthan one key with the same name. The same key can't be matched twice.\n\n## Example\n\nThe following code produces this diagnostic because the key `'a'` appears\ntwice:\n\n```dart\nvoid f(Map<String, int> x) {\n  if (x case {'a': 1, [!'a'!]: 2}) {}\n}\n```\n\n## Common fixes\n\nIf you are trying to match two different keys, then change one of the keys\nin the pattern:\n\n```dart\nvoid f(Map<String, int> x) {\n  if (x case {'a': 1, 'b': 2}) {}\n}\n```\n\nIf you are trying to match the same key, but allow any one of multiple\npatterns to match, the use a logical-or pattern:\n\n```dart\nvoid f(Map<String, int> x) {\n  if (x case {'a': 1 || 2}) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "expected_body",
    "description": "_A catch clause must have a body, even if it is empty._\n\n_A class declaration must have a body, even if it is empty._\n\n_A finally clause must have a body, even if it is empty._\n\n_A mixin declaration must have a body, even if it is empty._\n\n_A switch expression must have a body, even if it is empty._\n\n_A switch statement must have a body, even if it is empty._\n\n_A try statement must have a body, even if it is empty._\n\n_An extension declaration must have a body, even if it is empty._\n\n_An extension type declaration must have a body, even if it is empty._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "expected_case_or_default",
    "description": "_Expected 'case' or 'default'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "expected_class_member",
    "description": "_Expected a class member._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "expected_else_or_comma",
    "description": "_Expected 'else' or comma._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "expected_executable",
    "description": "_Expected a method, getter, setter or operator declaration._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "expected_identifier_but_got_keyword",
    "description": "_'{0}' can't be used as an identifier because it's a keyword._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "expected_instead",
    "description": "_Expected '{0}' instead of this._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "expected_list_or_map_literal",
    "description": "_Expected a list or map literal._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "expected_named_type",
    "description": "_Expected a class name._\n\n_Expected a mixin name._\n\n_Expected the name of a class or mixin._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "expected_one_list_pattern_type_arguments",
    "description": "_List patterns require one type argument or none, but {0} found._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a list pattern has more than\none type argument. List patterns can have either zero type arguments or\none type argument, but can't have more than one.\n\n## Example\n\nThe following code produces this diagnostic because the list pattern\n(`[0]`) has two type arguments:\n\n```dart\nvoid f(Object x) {\n  if (x case [!<int, int>!][0]) {}\n}\n```\n\n## Common fixes\n\nRemove all but one of the type arguments:\n\n```dart\nvoid f(Object x) {\n  if (x case <int>[0]) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "expected_one_list_type_arguments",
    "description": "_List literals require one type argument or none, but {0} found._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a list literal has more than one\ntype argument.\n\n## Example\n\nThe following code produces this diagnostic because the list literal has\ntwo type arguments when it can have at most one:\n\n```dart\nvar l = [!<int, int>!][];\n```\n\n## Common fixes\n\nRemove all except one of the type arguments:\n\n```dart\nvar l = <int>[];\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "expected_one_set_type_arguments",
    "description": "_Set literals require one type argument or none, but {0} were found._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a set literal has more than one\ntype argument.\n\n## Example\n\nThe following code produces this diagnostic because the set literal has\nthree type arguments when it can have at most one:\n\n```dart\nvar s = [!<int, String, int>!]{0, 'a', 1};\n```\n\n## Common fixes\n\nRemove all except one of the type arguments:\n\n```dart\nvar s = <int>{0, 1};\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "expected_representation_field",
    "description": "_Expected a representation field._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "expected_representation_type",
    "description": "_Expected a representation type._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "expected_string_literal",
    "description": "_Expected a string literal._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "expected_token",
    "description": "_Expected to find '{0}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "expected_two_map_pattern_type_arguments",
    "description": "_Map patterns require two type arguments or none, but {0} found._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a map pattern has either one\ntype argument or more than two type arguments. Map patterns can have\neither two type arguments or zero type arguments, but can't have any other\nnumber.\n\n## Example\n\nThe following code produces this diagnostic because the map pattern\n(`<int>{}`) has one type argument:\n\n```dart\nvoid f(Object x) {\n  if (x case [!<int>!]{0: _}) {}\n}\n```\n\n## Common fixes\n\nAdd or remove type arguments until there are two, or none:\n\n```dart\nvoid f(Object x) {\n  if (x case <int, int>{0: _}) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "expected_two_map_type_arguments",
    "description": "_Map literals require two type arguments or none, but {0} found._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a map literal has either one or\nmore than two type arguments.\n\n## Example\n\nThe following code produces this diagnostic because the map literal has\nthree type arguments when it can have either two or zero:\n\n```dart\nvar m = [!<int, String, int>!]{};\n```\n\n## Common fixes\n\nRemove all except two of the type arguments:\n\n```dart\nvar m = <int, String>{};\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "expected_type_name",
    "description": "_Expected a type name._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "experimental_member_use",
    "description": "_'{0}' is experimental and could be removed or changed at any time._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "experiment_not_enabled",
    "description": "_This requires the '{0}' language feature to be enabled._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "experiment_not_enabled_off_by_default",
    "description": "_This requires the experimental '{0}' language feature to be enabled._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "export_directive_after_part_directive",
    "description": "_Export directives must precede part directives._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "export_internal_library",
    "description": "_The library '{0}' is internal and can't be exported._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it finds an export whose `dart:`\nURI references an internal library.\n\n## Example\n\nThe following code produces this diagnostic because `_interceptors` is an\ninternal library:\n\n```dart\nexport [!'dart:_interceptors'!];\n```\n\n## Common fixes\n\nRemove the export directive.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "export_legacy_symbol",
    "description": "_The symbol '{0}' is defined in a legacy library, and can't be re-exported from a library with null safety enabled._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a library that was opted in to\nnull safety exports another library, and the exported library is opted out\nof null safety.\n\n## Example\n\nGiven a library that is opted out of null safety:\n\n```dart\n// @dart = 2.8\nString s;\n```\n\nThe following code produces this diagnostic because it's exporting symbols\nfrom an opted-out library:\n\n```dart\nexport [!'optedOut.dart'!];\n\nclass C {}\n```\n\n## Common fixes\n\nIf you're able to do so, migrate the exported library so that it doesn't\nneed to opt out:\n\n```dart\nString? s;\n```\n\nIf you can't migrate the library, then remove the export:\n\n```dart\nclass C {}\n```\n\nIf the exported library (the one that is opted out) itself exports an\nopted-in library, then it's valid for your library to indirectly export the\nsymbols from the opted-in library. You can do so by adding a hide\ncombinator to the export directive in your library that hides all of the\nnames declared in the opted-out library.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "export_of_non_library",
    "description": "_The exported library '{0}' can't have a part-of directive._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an export directive references a\npart rather than a library.\n\n## Example\n\nGiven a file `part.dart` containing\n\n```dart\npart of lib;\n```\n\nThe following code produces this diagnostic because the file `part.dart` is\na part, and only libraries can be exported:\n\n```dart\nlibrary lib;\n\nexport [!'part.dart'!];\n```\n\n## Common fixes\n\nEither remove the export directive, or change the URI to be the URI of the\nlibrary containing the part.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "expression_in_map",
    "description": "_Expressions can't be used in a map literal._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the analyzer finds an\nexpression, rather than a map entry, in what appears to be a map literal.\n\n## Example\n\nThe following code produces this diagnostic:\n\n```dart\nvar map = <String, int>{'a': 0, 'b': 1, [!'c'!]};\n```\n\n## Common fixes\n\nIf the expression is intended to compute either a key or a value in an\nentry, fix the issue by replacing the expression with the key or the value.\nFor example:\n\n```dart\nvar map = <String, int>{'a': 0, 'b': 1, 'c': 2};\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extends_non_class",
    "description": "_Classes can only extend other classes._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an `extends` clause contains a\nname that is declared to be something other than a class.\n\n## Example\n\nThe following code produces this diagnostic because `f` is declared to be a\nfunction:\n\n```dart\nvoid f() {}\n\nclass C extends [!f!] {}\n```\n\n## Common fixes\n\nIf you want the class to extend a class other than `Object`, then replace\nthe name in the `extends` clause with the name of that class:\n\n```dart\nvoid f() {}\n\nclass C extends B {}\n\nclass B {}\n```\n\nIf you want the class to extend `Object`, then remove the `extends` clause:\n\n```dart\nvoid f() {}\n\nclass C {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_as_expression",
    "description": "_Extension '{0}' can't be used as an expression._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the name of an extension is used\nin an expression other than in an extension override or to qualify an\naccess to a static member of the extension. Because classes define a type,\nthe name of a class can be used to refer to the instance of `Type`\nrepresenting the type of the class. Extensions, on the other hand, don't\ndefine a type and can't be used as a type literal.\n\n## Example\n\nThe following code produces this diagnostic because `E` is an extension:\n\n```dart\nextension E on int {\n  static String m() => '';\n}\n\nvar x = [!E!];\n```\n\n## Common fixes\n\nReplace the name of the extension with a name that can be referenced, such\nas a static member defined on the extension:\n\n```dart\nextension E on int {\n  static String m() => '';\n}\n\nvar x = E.m();\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_augmentation_has_on_clause",
    "description": "_Extension augmentations can't have 'on' clauses._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_conflicting_static_and_instance",
    "description": "_An extension can't define static member '{0}' and an instance member with the same name._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an extension declaration\ncontains both an instance member and a static member that have the same\nname. The instance member and the static member can't have the same name\nbecause it's unclear which member is being referenced by an unqualified use\nof the name within the body of the extension.\n\n## Example\n\nThe following code produces this diagnostic because the name `a` is being\nused for two different members:\n\n```dart\nextension E on Object {\n  int get a => 0;\n  static int [!a!]() => 0;\n}\n```\n\n## Common fixes\n\nRename or remove one of the members:\n\n```dart\nextension E on Object {\n  int get a => 0;\n  static int b() => 0;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_declares_abstract_member",
    "description": "_Extensions can't declare abstract members._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an abstract declaration is\ndeclared in an extension. Extensions can declare only concrete members.\n\n## Example\n\nThe following code produces this diagnostic because the method `a` doesn't\nhave a body:\n\n```dart\nextension E on String {\n  int [!a!]();\n}\n```\n\n## Common fixes\n\nEither provide an implementation for the member or remove it.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_declares_constructor",
    "description": "_Extensions can't declare constructors._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor declaration is\nfound in an extension. It isn't valid to define a constructor because\nextensions aren't classes, and it isn't possible to create an instance of\nan extension.\n\n## Example\n\nThe following code produces this diagnostic because there is a constructor\ndeclaration in `E`:\n\n```dart\nextension E on String {\n  [!E!]() : super();\n}\n```\n\n## Common fixes\n\nRemove the constructor or replace it with a static method.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_declares_instance_field",
    "description": "_Extensions can't declare instance fields._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an instance field declaration is\nfound in an extension. It isn't valid to define an instance field because\nextensions can only add behavior, not state.\n\n## Example\n\nThe following code produces this diagnostic because `s` is an instance\nfield:\n\n```dart\nextension E on String {\n  String [!s!];\n}\n```\n\n## Common fixes\n\nIf the value can be computed without storing it in a field, then try\nusing a getter or a method:\n\n```dart\nextension E on String {\n  String get s => '';\n\n  void s(String value) => print(s);\n}\n```\n\nIf the value must be stored, but is the same for every instance,\ntry using a static field:\n\n```dart\nextension E on String {\n  static String s = '';\n}\n```\n\nIf each instance needs to have its own value stored, then try\nusing a getter and setter pair backed by a static `Expando`:\n\n```dart\nextension E on SomeType {\n  static final _s = Expando<String>();\n\n  String get s => _s[this] ?? '';\n  set s(String value) => _s[this] = value;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_declares_member_of_object",
    "description": "_Extensions can't declare members with the same name as a member declared by 'Object'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an extension declaration\ndeclares a member with the same name as a member declared in the class\n`Object`. Such a member can never be used because the member in `Object` is\nalways found first.\n\n## Example\n\nThe following code produces this diagnostic because `toString` is defined\nby `Object`:\n\n```dart\nextension E on String {\n  String [!toString!]() => this;\n}\n```\n\n## Common fixes\n\nRemove the member or rename it so that the name doesn't conflict with the\nmember in `Object`:\n\n```dart\nextension E on String {\n  String displayString() => this;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_override_access_to_static_member",
    "description": "_An extension override can't be used to access a static member from an extension._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an extension override is the\nreceiver of the invocation of a static member. Similar to static members in\nclasses, the static members of an extension should be accessed using the\nname of the extension, not an extension override.\n\n## Example\n\nThe following code produces this diagnostic because `m` is static:\n\n```dart\nextension E on String {\n  static void m() {}\n}\n\nvoid f() {\n  E('').[!m!]();\n}\n```\n\n## Common fixes\n\nReplace the extension override with the name of the extension:\n\n```dart\nextension E on String {\n  static void m() {}\n}\n\nvoid f() {\n  E.m();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_override_argument_not_assignable",
    "description": "_The type of the argument to the extension override '{0}' isn't assignable to the extended type '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the argument to an extension\noverride isn't assignable to the type being extended by the extension.\n\n## Example\n\nThe following code produces this diagnostic because `3` isn't a `String`:\n\n```dart\nextension E on String {\n  void method() {}\n}\n\nvoid f() {\n  E([!3!]).method();\n}\n```\n\n## Common fixes\n\nIf you're using the correct extension, then update the argument to have the\ncorrect type:\n\n```dart\nextension E on String {\n  void method() {}\n}\n\nvoid f() {\n  E(3.toString()).method();\n}\n```\n\nIf there's a different extension that's valid for the type of the argument,\nthen either replace the name of the extension or unwrap the argument so\nthat the correct extension is found.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_override_without_access",
    "description": "_An extension override can only be used to access instance members._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an extension override is found\nthat isn't being used to access one of the members of the extension. The\nextension override syntax doesn't have any runtime semantics; it only\ncontrols which member is selected at compile time.\n\n## Example\n\nThe following code produces this diagnostic because `E(i)` isn't an\nexpression:\n\n```dart\nextension E on int {\n  int get a => 0;\n}\n\nvoid f(int i) {\n  print([!E(i)!]);\n}\n```\n\n## Common fixes\n\nIf you want to invoke one of the members of the extension, then add the\ninvocation:\n\n```dart\nextension E on int {\n  int get a => 0;\n}\n\nvoid f(int i) {\n  print(E(i).a);\n}\n```\n\nIf you don't want to invoke a member, then unwrap the argument:\n\n```dart\nextension E on int {\n  int get a => 0;\n}\n\nvoid f(int i) {\n  print(i);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_override_with_cascade",
    "description": "_Extension overrides have no value so they can't be used as the receiver of a cascade expression._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an extension override is used as\nthe receiver of a cascade expression. The value of a cascade expression\n`e..m` is the value of the receiver `e`, but extension overrides aren't\nexpressions and don't have a value.\n\n## Example\n\nThe following code produces this diagnostic because `E(3)` isn't an\nexpression:\n\n```dart\nextension E on int {\n  void m() {}\n}\nf() {\n  [!E!](3)..m();\n}\n```\n\n## Common fixes\n\nUse `.` rather than `..`:\n\n```dart\nextension E on int {\n  void m() {}\n}\nf() {\n  E(3).m();\n}\n```\n\nIf there are multiple cascaded accesses, you'll need to duplicate the\nextension override for each one.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_type_constructor_with_super_formal_parameter",
    "description": "_Extension type constructors can't declare super formal parameters._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor in an extension\ntype has a super parameter. Super parameters aren't valid because\nextension types don't have a superclass.\n\n## Example\n\nThe following code produces this diagnostic because the named constructor\n`n` contains a super parameter:\n\n```dart\nextension type E(int i) {\n  E.n(this.i, [!super!].foo);\n}\n```\n\n## Common fixes\n\nIf you need the parameter, replace the super parameter with a normal\nparameter:\n\n```dart\nextension type E(int i) {\n  E.n(this.i, String foo);\n}\n```\n\nIf you don't need the parameter, remove the super parameter:\n\n```dart\nextension type E(int i) {\n  E.n(this.i);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_type_constructor_with_super_invocation",
    "description": "_Extension type constructors can't include super initializers._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor in an extension\ntype includes an invocation of a super constructor in the initializer\nlist. Because extension types don't have a superclass, there's no\nconstructor to invoke.\n\n## Example\n\nThe following code produces this diagnostic because the constructor `E.n`\ninvokes a super constructor in its initializer list:\n\n```dart\nextension type E(int i) {\n  E.n() : i = 0, [!super!].n();\n}\n```\n\n## Common fixes\n\nRemove the invocation of the super constructor:\n\n```dart\nextension type E(int i) {\n  E.n() : i = 0;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_type_declares_instance_field",
    "description": "_Extension types can't declare instance fields._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when there's a field declaration in\nthe body of an extension type declaration.\n\n## Example\n\nThe following code produces this diagnostic because the extension type `E`\ndeclares a field named `f`:\n\n```dart\nextension type E(int i) {\n  final int [!f!] = 0;\n}\n```\n\n## Common fixes\n\nIf you don't need the field, then remove it or replace it with a getter\nand/or setter:\n\n```dart\nextension type E(int i) {\n  int get f => 0;\n}\n```\n\nIf you need the field, then convert the extension type into a class:\n\n```dart\nclass E {\n  final int i;\n\n  final int f = 0;\n\n  E(this.i);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_type_declares_member_of_object",
    "description": "_Extension types can't declare members with the same name as a member declared by 'Object'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the body of an extension type\ndeclaration contains a member with the same name as one of the members\ndeclared by `Object`.\n\n## Example\n\nThe following code produces this diagnostic because the class `Object`\nalready defines a member named `hashCode`:\n\n```dart\nextension type E(int i) {\n  int get [!hashCode!] => 0;\n}\n```\n\n## Common fixes\n\nIf you need a member with the implemented semantics, then rename the\nmember:\n\n```dart\nextension type E(int i) {\n  int get myHashCode => 0;\n}\n```\n\nIf you don't need a member with the implemented semantics, then remove the\nmember:\n\n```dart\nextension type E(int i) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_type_extends",
    "description": "_An extension type declaration can't have an 'extends' clause._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_type_implements_disallowed_type",
    "description": "_Extension types can't implement '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an extension type implements a\ntype that it isn't allowed to implement.\n\n## Example\n\nThe following code produces this diagnostic because extension types can't\nimplement the type `dynamic`:\n\n```dart\nextension type A(int i) implements [!dynamic!] {}\n```\n\n## Common fixes\n\nRemove the disallowed type from the implements clause:\n\n```dart\nextension type A(int i) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_type_implements_itself",
    "description": "_The extension type can't implement itself._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an extension type implements\nitself, either directly or indirectly.\n\n## Example\n\nThe following code produces this diagnostic because the extension type `A`\ndirectly implements itself:\n\n```dart\nextension type [!A!](int i) implements A {}\n```\n\nThe following code produces this diagnostic because the extension type `A`\nindirectly implements itself (through `B`):\n\n```dart\nextension type [!A!](int i) implements B {}\n\nextension type [!B!](int i) implements A {}\n```\n\n## Common fixes\n\nBreak the cycle by removing a type from the implements clause of at least\none of the types involved in the cycle:\n\n```dart\nextension type A(int i) implements B {}\n\nextension type B(int i) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_type_implements_not_supertype",
    "description": "_'{0}' is not a supertype of '{1}', the representation type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an extension type implements a\ntype that isn't a supertype of the representation type.\n\n## Example\n\nThe following code produces this diagnostic because the extension type `A`\nimplements `String`, but `String` isn't a supertype of the representation\ntype `int`:\n\n```dart\nextension type A(int i) implements [!String!] {}\n```\n\n## Common fixes\n\nIf the representation type is correct, then remove or replace the type in\nthe implements clause:\n\n```dart\nextension type A(int i) {}\n```\n\nIf the representation type isn't correct, then replace it with the correct\ntype:\n\n```dart\nextension type A(String s) implements String {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_type_implements_representation_not_supertype",
    "description": "_'{0}', the representation type of '{1}', is not a supertype of '{2}', the representation type of '{3}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an extension type implements\nanother extension type, and the representation type of the implemented\nextension type isn't a subtype of the representation type of the implementing\nextension type.\n\n## Example\n\nThe following code produces this diagnostic because the extension type `B`\nimplements `A`, but the representation type of `A` (`num`) isn't a\nsubtype of the representation type of `B` (`String`):\n\n```dart\nextension type A(num i) {}\n\nextension type B(String s) implements [!A!] {}\n```\n\n## Common fixes\n\nEither change the representation types of the two extension types so that\nthe representation type of the implemented type is a supertype of the\nrepresentation type of the implementing type:\n\n```dart\nextension type A(num i) {}\n\nextension type B(int n) implements A {}\n```\n\nOr remove the implemented type from the implements clause:\n\n```dart\nextension type A(num i) {}\n\nextension type B(String s) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_type_inherited_member_conflict",
    "description": "_The extension type '{0}' has more than one distinct member named '{1}' from implemented types._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an extension type implements\ntwo or more other types, and at least two of those types declare a member\nwith the same name.\n\n## Example\n\nThe following code produces this diagnostic because the extension type `C`\nimplements both `A` and `B`, and both declare a member named `m`:\n\n```dart\nclass A {\n  void m() {}\n}\n\nextension type B(A a) {\n  void m() {}\n}\n\nextension type [!C!](A a) implements A, B {}\n```\n\n## Common fixes\n\nIf the extension type doesn't need to implement all of the listed types,\nthen remove all but one of the types introducing the conflicting members:\n\n```dart\nclass A {\n  void m() {}\n}\n\nextension type B(A a) {\n  void m() {}\n}\n\nextension type C(A a) implements A {}\n```\n\nIf the extension type needs to implement all of the listed types but you\ncan rename the members in those types, then give the conflicting members\nunique names:\n\n```dart\nclass A {\n  void m() {}\n}\n\nextension type B(A a) {\n  void n() {}\n}\n\nextension type C(A a) implements A, B {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_type_representation_depends_on_itself",
    "description": "_The extension type representation can't depend on itself._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an extension type has a\nrepresentation type that depends on the extension type itself, either\ndirectly or indirectly.\n\n## Example\n\nThe following code produces this diagnostic because the representation\ntype of the extension type `A` depends on `A` directly:\n\n```dart\nextension type [!A!](A a) {}\n```\n\nThe following two code examples produce this diagnostic because the\nrepresentation type of the extension type `A` depends on `A`\nindirectly through the extension type `B`:\n\n```dart\nextension type [!A!](B b) {}\n\nextension type [!B!](A a) {}\n```\n\n```dart\nextension type [!A!](List<B> b) {}\n\nextension type [!B!](List<A> a) {}\n```\n\n## Common fixes\n\nRemove the dependency by choosing a different representation type for at\nleast one of the types in the cycle:\n\n```dart\nextension type A(String s) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_type_representation_type_bottom",
    "description": "_The representation type can't be a bottom type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the representation type of an\nextension type is the [bottom type][] `Never`. The type `Never` can't be\nthe representation type of an extension type because there are no values\nthat can be extended.\n\n## Example\n\nThe following code produces this diagnostic because the representation\ntype of the extension type `E` is `Never`:\n\n```dart\nextension type E([!Never!] n) {}\n```\n\n## Common fixes\n\nReplace the extension type with a different type:\n\n```dart\nextension type E(String s) {}\n```\n\n[bottom type]: /null-safety/understanding-null-safety#top-and-bottom\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_type_with",
    "description": "_An extension type declaration can't have a 'with' clause._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extension_type_with_abstract_member",
    "description": "_'{0}' must have a method body because '{1}' is an extension type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an extension type declares an\nabstract member. Because extension type member references are resolved\nstatically, an abstract member in an extension type could never be\nexecuted.\n\n## Example\n\nThe following code produces this diagnostic because the method `m` in the\nextension type `E` is abstract:\n\n```dart\nextension type E(String s) {\n  [!void m();!]\n}\n```\n\n## Common fixes\n\nIf the member is intended to be executable, then provide an implementation\nof the member:\n\n```dart\nextension type E(String s) {\n  void m() {}\n}\n```\n\nIf the member isn't intended to be executable, then remove it:\n\n```dart\nextension type E(String s) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "external_class",
    "description": "_Classes can't be declared to be 'external'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "external_constructor_with_field_initializers",
    "description": "_An external constructor can't initialize fields._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "external_constructor_with_initializer",
    "description": "_An external constructor can't have any initializers._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "external_enum",
    "description": "_Enums can't be declared to be 'external'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "external_factory_redirection",
    "description": "_A redirecting factory can't be external._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "external_factory_with_body",
    "description": "_External factories can't have a body._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "external_getter_with_body",
    "description": "_External getters can't have a body._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "external_late_field",
    "description": "_External fields cannot be late._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "external_method_with_body",
    "description": "_An external or native method can't have a body._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "external_operator_with_body",
    "description": "_External operators can't have a body._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "external_setter_with_body",
    "description": "_External setters can't have a body._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "external_typedef",
    "description": "_Typedefs can't be declared to be 'external'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "external_with_initializer",
    "description": "_External fields can't have initializers._\n\n_External variables can't have initializers._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a field or variable marked with\nthe keyword `external` has an initializer, or when an external field is\ninitialized in a constructor.\n\n## Examples\n\nThe following code produces this diagnostic because the external field `x`\nis assigned a value in an initializer:\n\n```dart\nclass C {\n  external int x;\n  C() : [!x!] = 0;\n}\n```\n\nThe following code produces this diagnostic because the external field `x`\nhas an initializer:\n\n```dart\nclass C {\n  external final int [!x!] = 0;\n}\n```\n\nThe following code produces this diagnostic because the external top level\nvariable `x` has an initializer:\n\n```dart\nexternal final int [!x!] = 0;\n```\n\n## Common fixes\n\nRemove the initializer:\n\n```dart\nclass C {\n  external final int x;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extraneous_modifier",
    "description": "_Can't have modifier '{0}' here._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extraneous_modifier_in_extension_type",
    "description": "_Can't have modifier '{0}' in an extension type._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extraneous_modifier_in_primary_constructor",
    "description": "_Can't have modifier '{0}' in a primary constructor._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extra_annotation_on_struct_field",
    "description": "_Fields in a struct class must have exactly one annotation indicating the native type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a field in a subclass of\n`Struct` has more than one annotation describing the native type of the\nfield.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the field `x` has two\nannotations describing the native type of the field:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Int32()\n  [!@Int16()!]\n  external int x;\n}\n```\n\n## Common fixes\n\nRemove all but one of the annotations:\n\n```dart\nimport 'dart:ffi';\nfinal class C extends Struct {\n  @Int32()\n  external int x;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extra_positional_arguments",
    "description": "_Too many positional arguments: {0} expected, but {1} found._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a method or function invocation\nhas more positional arguments than the method or function allows.\n\n## Example\n\nThe following code produces this diagnostic because `f` defines 2\nparameters but is invoked with 3 arguments:\n\n```dart\nvoid f(int a, int b) {}\nvoid g() {\n  f(1, 2, [!3!]);\n}\n```\n\n## Common fixes\n\nRemove the arguments that don't correspond to parameters:\n\n```dart\nvoid f(int a, int b) {}\nvoid g() {\n  f(1, 2);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extra_positional_arguments_could_be_named",
    "description": "_Too many positional arguments: {0} expected, but {1} found._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a method or function invocation\nhas more positional arguments than the method or function allows, but the\nmethod or function defines named parameters.\n\n## Example\n\nThe following code produces this diagnostic because `f` defines 2\npositional parameters but has a named parameter that could be used for the\nthird argument:\n\n```dart\nvoid f(int a, int b, {int? c}) {}\nvoid g() {\n  f(1, 2, [!3!]);\n}\n```\n\n## Common fixes\n\nIf some of the arguments should be values for named parameters, then add\nthe names before the arguments:\n\n```dart\nvoid f(int a, int b, {int? c}) {}\nvoid g() {\n  f(1, 2, c: 3);\n}\n```\n\nOtherwise, remove the arguments that don't correspond to positional\nparameters:\n\n```dart\nvoid f(int a, int b, {int? c}) {}\nvoid g() {\n  f(1, 2);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "extra_size_annotation_carray",
    "description": "_'Array's must have exactly one 'Array' annotation._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a field in a subclass of\n`Struct` has more than one annotation describing the size of the native\narray.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the field `a0` has two\nannotations that specify the size of the native array:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Array(4)\n  [!@Array(8)!]\n  external Array<Uint8> a0;\n}\n```\n\n## Common fixes\n\nRemove all but one of the annotations:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Array(8)\n  external Array<Uint8> a0;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "factory_constructor_new_name",
    "description": "_Factory constructors can't be named 'new'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "factory_top_level_declaration",
    "description": "_Top-level declarations can't be declared to be 'factory'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "factory_without_body",
    "description": "_A non-redirecting 'factory' constructor must have a body._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "factory_with_initializers",
    "description": "_A 'factory' constructor can't have initializers._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "ffi_native_invalid_duplicate_default_asset",
    "description": "_There may be at most one @DefaultAsset annotation on a library._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a library directive has more\nthan one `DefaultAsset` annotation associated with it.\n\n## Example\n\nThe following code produces this diagnostic because the library directive\nhas two `DefaultAsset` annotations associated with it:\n\n```dart\n@DefaultAsset('a')\n@[!DefaultAsset!]('b')\nlibrary;\n\nimport 'dart:ffi';\n```\n\n## Common fixes\n\nRemove all but one of the `DefaultAsset` annotations:\n\n```dart\n@DefaultAsset('a')\nlibrary;\n\nimport 'dart:ffi';\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "ffi_native_invalid_multiple_annotations",
    "description": "_Native functions and fields must have exactly one `@Native` annotation._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when there is more than one `Native`\nannotation on a single declaration.\n\n## Example\n\nThe following code produces this diagnostic because the function `f` has\ntwo `Native` annotations associated with it:\n\n```dart\nimport 'dart:ffi';\n\n@Native<Int32 Function(Int32)>()\n@[!Native!]<Int32 Function(Int32)>(isLeaf: true)\nexternal int f(int v);\n```\n\n## Common fixes\n\nRemove all but one of the annotations:\n\n```dart\nimport 'dart:ffi';\n\n@Native<Int32 Function(Int32)>(isLeaf: true)\nexternal int f(int v);\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "ffi_native_must_be_external",
    "description": "_Native functions must be declared external._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a function annotated as being\n`@Native` isn't marked as `external`.\n\n## Example\n\nThe following code produces this diagnostic because the function `free` is\nannotated as being `@Native`, but the function isn't marked as `external`:\n\n```dart\nimport 'dart:ffi';\n\n@Native<Void Function(Pointer<Void>)>()\nvoid [!free!](Pointer<Void> ptr) {}\n```\n\n## Common fixes\n\nIf the function is a native function, then add the modifier `external`\nbefore the return type:\n\n```dart\nimport 'dart:ffi';\n\n@Native<Void Function(Pointer<Void>)>()\nexternal void free(Pointer<Void> ptr);\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "ffi_native_only_classes_extending_nativefieldwrapperclass1_can_be_pointer",
    "description": "_Only classes extending NativeFieldWrapperClass1 can be passed as Pointer._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a function or method annotated\nwith `@Native` has a parameter in its FFI signature that is a `Pointer`,\nbut the corresponding Dart parameter type is a class instance that doesn't\nextend `NativeFieldWrapperClass1` (or is a Pointer or TypedData).\n\n## Example\n\nThe following code produces this diagnostic because `MyService` doesn't\nextend `NativeFieldWrapperClass1`, but the `@Native` signature for its\n`process` method indicates the receiver should be passed as a `Pointer<Void>`:\n\n```dart\nimport 'dart:ffi';\n\nclass MyService { // MyService does not extend NativeFieldWrapperClass1\n  @Native<Void Function(Pointer<Void>, Int8)>(symbol: 'MyService_process')\n  external void [!process!](int data);\n}\n```\n\n## Common fixes\n\n1.  **If the Dart class is intended to wrap a native object:**\n    Make the Dart class extend `NativeFieldWrapperClass1`. This is the\n    correct approach if the Dart class instance has a corresponding native\n    object whose pointer should be passed.\n    ```dart\n    import 'dart:ffi';\n\n    class MyService extends NativeFieldWrapperClass1 {\n      @Native<Void Function(Pointer<Void>, Int8)>(symbol: 'MyService_process')\n      external void process(int data);\n    }\n    ```\n\n2.  **If you intend to pass an opaque handle to the Dart object:**\n    Change the FFI signature in the `@Native` annotation to use `Handle`\n    instead of `Pointer` for the parameter. This allows passing a\n    reference to the Dart object itself, which native code can interact\n    with using the Dart C API.\n    ```dart\n    import 'dart:ffi';\n\n    class MyService {\n      @Native<Void Function(Handle, Int8)>(symbol: 'MyService_process')\n      external void process(int data);\n    }\n    ```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "ffi_native_unexpected_number_of_parameters",
    "description": "_Unexpected number of Native annotation parameters. Expected {0} but has {1}._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the number of parameters in the\nfunction type used as a type argument for the `@Native` annotation doesn't\nmatch the number of parameters in the function being annotated.\n\n## Example\n\nThe following code produces this diagnostic because the function type used\nas a type argument for the `@Native` annotation (`Void Function(Double)`)\nhas one argument and the type of the annotated function\n(`void f(double, double)`) has two arguments:\n\n```dart\nimport 'dart:ffi';\n\n@Native<Void Function(Double)>(symbol: 'f')\nexternal void [!f!](double x, double y);\n```\n\n## Common fixes\n\nIf the annotated function is correct, then update the function type in the\n`@Native` annotation to match:\n\n```dart\nimport 'dart:ffi';\n\n@Native<Void Function(Double, Double)>(symbol: 'f')\nexternal void f(double x, double y);\n```\n\nIf the function type in the `@Native` annotation is correct, then update\nthe annotated function to match:\n\n```dart\nimport 'dart:ffi';\n\n@Native<Void Function(Double)>(symbol: 'f')\nexternal void f(double x);\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "ffi_native_unexpected_number_of_parameters_with_receiver",
    "description": "_Unexpected number of Native annotation parameters. Expected {0} but has {1}. Native instance method annotation must have receiver as first argument._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the type argument used on the\n`@Native` annotation of a native method doesn't include a type for the\nreceiver of the method.\n\n## Example\n\nThe following code produces this diagnostic because the type argument on\nthe `@Native` annotation (`Void Function(Double)`) doesn't include a type\nfor the receiver of the method:\n\n```dart\nimport 'dart:ffi';\n\nclass C {\n  @Native<Void Function(Double)>()\n  external void [!f!](double x);\n}\n```\n\n## Common fixes\n\nAdd an initial parameter whose type is the same as the class in which the\nnative method is being declared:\n\n```dart\nimport 'dart:ffi';\n\nclass C {\n  @Native<Void Function(C, Double)>()\n  external void f(double x);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "field_initialized_by_multiple_initializers",
    "description": "_The field '{0}' can't be initialized twice in the same constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the initializer list of a\nconstructor initializes a field more than once. There is no value to allow\nboth initializers because only the last value is preserved.\n\n## Example\n\nThe following code produces this diagnostic because the field `f` is being\ninitialized twice:\n\n```dart\nclass C {\n  int f;\n\n  C() : f = 0, [!f!] = 1;\n}\n```\n\n## Common fixes\n\nRemove one of the initializers:\n\n```dart\nclass C {\n  int f;\n\n  C() : f = 0;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "field_initialized_in_initializer_and_declaration",
    "description": "_Fields can't be initialized in the constructor if they are final and were already initialized at their declaration._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a final field is initialized in\nboth the declaration of the field and in an initializer in a constructor.\nFinal fields can only be assigned once, so it can't be initialized in both\nplaces.\n\n## Example\n\nThe following code produces this diagnostic because `f` is :\n\n```dart\nclass C {\n  final int f = 0;\n  C() : [!f!] = 1;\n}\n```\n\n## Common fixes\n\nIf the initialization doesn't depend on any values passed to the\nconstructor, and if all of the constructors need to initialize the field to\nthe same value, then remove the initializer from the constructor:\n\n```dart\nclass C {\n  final int f = 0;\n  C();\n}\n```\n\nIf the initialization depends on a value passed to the constructor, or if\ndifferent constructors need to initialize the field differently, then\nremove the initializer in the field's declaration:\n\n```dart\nclass C {\n  final int f;\n  C() : f = 1;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "field_initialized_in_parameter_and_initializer",
    "description": "_Fields can't be initialized in both the parameter list and the initializers._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a field is initialized in both\nthe parameter list and in the initializer list of a constructor.\n\n## Example\n\nThe following code produces this diagnostic because the field `f` is\ninitialized both by an initializing formal parameter and in the\ninitializer list:\n\n```dart\nclass C {\n  int f;\n\n  C(this.f) : [!f!] = 0;\n}\n```\n\n## Common fixes\n\nIf the field should be initialized by the parameter, then remove the\ninitialization in the initializer list:\n\n```dart\nclass C {\n  int f;\n\n  C(this.f);\n}\n```\n\nIf the field should be initialized in the initializer list and the\nparameter isn't needed, then remove the parameter:\n\n```dart\nclass C {\n  int f;\n\n  C() : f = 0;\n}\n```\n\nIf the field should be initialized in the initializer list and the\nparameter is needed, then make it a normal parameter:\n\n```dart\nclass C {\n  int f;\n\n  C(int g) : f = g * 2;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "field_initialized_outside_declaring_class",
    "description": "_A field can only be initialized in its declaring class_",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "field_initializer_factory_constructor",
    "description": "_Initializing formal parameters can't be used in factory constructors._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a factory constructor has an\ninitializing formal parameter. Factory constructors can't assign values to\nfields because no instance is created; hence, there is no field to assign.\n\n## Example\n\nThe following code produces this diagnostic because the factory constructor\nuses an initializing formal parameter:\n\n```dart\nclass C {\n  int? f;\n\n  factory C([!this.f!]) => throw 0;\n}\n```\n\n## Common fixes\n\nReplace the initializing formal parameter with a normal parameter:\n\n```dart\nclass C {\n  int? f;\n\n  factory C(int f) => throw 0;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "field_initializer_in_struct",
    "description": "_Constructors in subclasses of 'Struct' and 'Union' can't have field initializers._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor in a subclass of\neither `Struct` or `Union` has one or more field initializers.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the class `C` has a\nconstructor with an initializer for the field `f`:\n\n```dart\n// @dart = 2.9\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Int32()\n  int f;\n\n  C() : [!f = 0!];\n}\n```\n\n## Common fixes\n\nRemove the field initializer:\n\n```dart\n// @dart = 2.9\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Int32()\n  int f;\n\n  C();\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "field_initializer_not_assignable",
    "description": "_The initializer type '{0}' can't be assigned to the field type '{1}' in a const constructor._\n\n_The initializer type '{0}' can't be assigned to the field type '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the initializer list of a\nconstructor initializes a field to a value that isn't assignable to the\nfield.\n\n## Example\n\nThe following code produces this diagnostic because `0` has the type `int`,\nand an `int` can't be assigned to a field of type `String`:\n\n```dart\nclass C {\n  String s;\n\n  C() : s = [!0!];\n}\n```\n\n## Common fixes\n\nIf the type of the field is correct, then change the value assigned to it\nso that the value has a valid type:\n\n```dart\nclass C {\n  String s;\n\n  C() : s = '0';\n}\n```\n\nIf the type of the value is correct, then change the type of the field to\nallow the assignment:\n\n```dart\nclass C {\n  int s;\n\n  C() : s = 0;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "field_initializer_outside_constructor",
    "description": "_Field formal parameters can only be used in a constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an initializing formal\nparameter is used in the parameter list for anything other than a\nconstructor.\n\n## Example\n\nThe following code produces this diagnostic because the initializing\nformal parameter `this.x` is being used in the method `m`:\n\n```dart\nclass A {\n  int x = 0;\n\n  m([[!this.x!] = 0]) {}\n}\n```\n\n## Common fixes\n\nReplace the initializing formal parameter with a normal parameter and\nassign the field within the body of the method:\n\n```dart\nclass A {\n  int x = 0;\n\n  m([int x = 0]) {\n    this.x = x;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "field_initializer_redirecting_constructor",
    "description": "_The redirecting constructor can't have a field initializer._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a redirecting constructor\ninitializes a field in the object. This isn't allowed because the instance\nthat has the field hasn't been created at the point at which it should be\ninitialized.\n\n## Examples\n\nThe following code produces this diagnostic because the constructor\n`C.zero`, which redirects to the constructor `C`, has an initializing\nformal parameter that initializes the field `f`:\n\n```dart\nclass C {\n  int f;\n\n  C(this.f);\n\n  C.zero([!this.f!]) : this(f);\n}\n```\n\nThe following code produces this diagnostic because the constructor\n`C.zero`, which redirects to the constructor `C`, has an initializer that\ninitializes the field `f`:\n\n```dart\nclass C {\n  int f;\n\n  C(this.f);\n\n  C.zero() : [!f = 0!], this(1);\n}\n```\n\n## Common fixes\n\nIf the initialization is done by an initializing formal parameter, then\nuse a normal parameter:\n\n```dart\nclass C {\n  int f;\n\n  C(this.f);\n\n  C.zero(int f) : this(f);\n}\n```\n\nIf the initialization is done in an initializer, then remove the\ninitializer:\n\n```dart\nclass C {\n  int f;\n\n  C(this.f);\n\n  C.zero() : this(0);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "field_initializing_formal_not_assignable",
    "description": "_The parameter type '{0}' is incompatible with the field type '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the type of an initializing\nformal parameter isn't assignable to the type of the field being\ninitialized.\n\n## Example\n\nThe following code produces this diagnostic because the initializing\nformal parameter has the type `String`, but the type of the field is\n`int`. The parameter must have a type that is a subtype of the field's\ntype.\n\n```dart\nclass C {\n  int f;\n\n  C([!String this.f!]);\n}\n```\n\n## Common fixes\n\nIf the type of the field is incorrect, then change the type of the field to\nmatch the type of the parameter, and consider removing the type from the\nparameter:\n\n```dart\nclass C {\n  String f;\n\n  C(this.f);\n}\n```\n\nIf the type of the parameter is incorrect, then remove the type of the\nparameter:\n\n```dart\nclass C {\n  int f;\n\n  C(this.f);\n}\n```\n\nIf the types of both the field and the parameter are correct, then use an\ninitializer rather than an initializing formal parameter to convert the\nparameter value into a value of the correct type:\n\n```dart\nclass C {\n  int f;\n\n  C(String s) : f = int.parse(s);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "field_in_struct_with_initializer",
    "description": "_Fields in subclasses of 'Struct' and 'Union' can't have initializers._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a field in a subclass of\n`Struct` has an initializer.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the field `p` has an\ninitializer:\n\n```dart\n// @dart = 2.9\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  Pointer [!p!] = nullptr;\n}\n```\n\n## Common fixes\n\nRemove the initializer:\n\n```dart\n// @dart = 2.9\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  Pointer p;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "field_must_be_external_in_struct",
    "description": "_Fields of 'Struct' and 'Union' subclasses must be marked external._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a field in a subclass of either\n`Struct` or `Union` isn't marked as being `external`.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the field `a` isn't\nmarked as being `external`:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Int16()\n  int [!a!];\n}\n```\n\n## Common fixes\n\nAdd the required `external` modifier:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Int16()\n  external int a;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "final_and_covariant",
    "description": "_Members can't be declared to be both 'final' and 'covariant'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "final_and_covariant_late_with_initializer",
    "description": "_Members marked 'late' with an initializer can't be declared to be both 'final' and 'covariant'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "final_and_var",
    "description": "_Members can't be declared to be both 'final' and 'var'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "final_constructor",
    "description": "_A constructor can't be declared to be 'final'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "final_enum",
    "description": "_Enums can't be declared to be 'final'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "final_initialized_in_declaration_and_constructor",
    "description": "_'{0}' is final and was given a value when it was declared, so it can't be set to a new value._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a final field is initialized\ntwice: once where it's declared and once by a constructor's parameter.\n\n## Example\n\nThe following code produces this diagnostic because the field `f` is\ninitialized twice:\n\n```dart\nclass C {\n  final int f = 0;\n\n  C(this.[!f!]);\n}\n```\n\n## Common fixes\n\nIf the field should have the same value for all instances, then remove the\ninitialization in the parameter list:\n\n```dart\nclass C {\n  final int f = 0;\n\n  C();\n}\n```\n\nIf the field can have different values in different instances, then remove\nthe initialization in the declaration:\n\n```dart\nclass C {\n  final int f;\n\n  C(this.f);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "final_method",
    "description": "_Getters, setters and methods can't be declared to be 'final'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "final_mixin",
    "description": "_A mixin can't be declared 'final'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "final_mixin_class",
    "description": "_A mixin class can't be declared 'final'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "final_not_initialized",
    "description": "_The final variable '{0}' must be initialized._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a final field or variable isn't\ninitialized.\n\n## Example\n\nThe following code produces this diagnostic because `x` doesn't have an\ninitializer:\n\n```dart\nfinal [!x!];\n```\n\n## Common fixes\n\nFor variables and static fields, you can add an initializer:\n\n```dart\nfinal x = 0;\n```\n\nFor instance fields, you can add an initializer as shown in the previous\nexample, or you can initialize the field in every constructor. You can\ninitialize the field by using an initializing formal parameter:\n\n```dart\nclass C {\n  final int x;\n  C(this.x);\n}\n```\n\nYou can also initialize the field by using an initializer in the\nconstructor:\n\n```dart\nclass C {\n  final int x;\n  C(int y) : x = y * 2;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "final_not_initialized_constructor",
    "description": "_All final variables must be initialized, but '{0}' and '{1}' aren't._\n\n_All final variables must be initialized, but '{0}' isn't._\n\n_All final variables must be initialized, but '{0}', '{1}', and {2} others aren't._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class defines one or more\nfinal instance fields without initializers and has at least one constructor\nthat doesn't initialize those fields. All final instance fields must be\ninitialized when the instance is created, either by the field's initializer\nor by the constructor.\n\n## Example\n\nThe following code produces this diagnostic:\n\n```dart\nclass C {\n  final String value;\n\n  [!C!]();\n}\n```\n\n## Common fixes\n\nIf the value should be passed in to the constructor directly, then use an\ninitializing formal parameter to initialize the field `value`:\n\n```dart\nclass C {\n  final String value;\n\n  C(this.value);\n}\n```\n\nIf the value should be computed indirectly from a value provided by the\ncaller, then add a parameter and include an initializer:\n\n```dart\nclass C {\n  final String value;\n\n  C(Object o) : value = o.toString();\n}\n```\n\nIf the value of the field doesn't depend on values that can be passed to\nthe constructor, then add an initializer for the field as part of the field\ndeclaration:\n\n```dart\nclass C {\n  final String value = '';\n\n  C();\n}\n```\n\nIf the value of the field doesn't depend on values that can be passed to\nthe constructor but different constructors need to initialize it to\ndifferent values, then add an initializer for the field in the initializer\nlist:\n\n```dart\nclass C {\n  final String value;\n\n  C() : value = '';\n\n  C.named() : value = 'c';\n}\n```\n\nHowever, if the value is the same for all instances, then consider using a\nstatic field instead of an instance field:\n\n```dart\nclass C {\n  static const String value = '';\n\n  C();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "fixme",
    "description": "_{0}_",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "flutter_field_not_map",
    "description": "_The value of the 'flutter' field is expected to be a map._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the value of the `flutter` key\nisn't a map.\n\n## Example\n\nThe following code produces this diagnostic because the value of the\ntop-level `flutter` key is a string:\n\n```yaml\nname: example\nflutter: [!true!]\n```\n\n## Common fixes\n\nIf you need to specify Flutter-specific options, then change the value to\nbe a map:\n\n```yaml\nname: example\nflutter:\n  uses-material-design: true\n```\n\nIf you don't need to specify Flutter-specific options, then remove the\n`flutter` key:\n\n```yaml\nname: example\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "for_in_of_invalid_element_type",
    "description": "_The type '{0}' used in the 'for' loop must implement '{1}' with a type argument that can be assigned to '{2}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the `Iterable` or `Stream` in a\nfor-in loop has an element type that can't be assigned to the loop\nvariable.\n\n## Example\n\nThe following code produces this diagnostic because `<String>[]` has an\nelement type of `String`, and `String` can't be assigned to the type of `e`\n(`int`):\n\n```dart\nvoid f() {\n  for (int e in [!<String>[]!]) {\n    print(e);\n  }\n}\n```\n\n## Common fixes\n\nIf the type of the loop variable is correct, then update the type of the\niterable:\n\n```dart\nvoid f() {\n  for (int e in <int>[]) {\n    print(e);\n  }\n}\n```\n\nIf the type of the iterable is correct, then update the type of the loop\nvariable:\n\n```dart\nvoid f() {\n  for (String e in <String>[]) {\n    print(e);\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "for_in_of_invalid_type",
    "description": "_The type '{0}' used in the 'for' loop must implement '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the expression following `in` in\na for-in loop has a type that isn't a subclass of `Iterable`.\n\n## Example\n\nThe following code produces this diagnostic because `m` is a `Map`, and\n`Map` isn't a subclass of `Iterable`:\n\n```dart\nvoid f(Map<String, String> m) {\n  for (String s in [!m!]) {\n    print(s);\n  }\n}\n```\n\n## Common fixes\n\nReplace the expression with one that produces an iterable value:\n\n```dart\nvoid f(Map<String, String> m) {\n  for (String s in m.values) {\n    print(s);\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "for_in_with_const_variable",
    "description": "_A for-in loop variable can't be a 'const'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the loop variable declared in a\nfor-in loop is declared to be a `const`. The variable can't be a `const`\nbecause the value can't be computed at compile time.\n\n## Example\n\nThe following code produces this diagnostic because the loop variable `x`\nis declared to be a `const`:\n\n```dart\nvoid f() {\n  for ([!const!] x in [0, 1, 2]) {\n    print(x);\n  }\n}\n```\n\n## Common fixes\n\nIf there's a type annotation, then remove the `const` modifier from the\ndeclaration.\n\nIf there's no type, then replace the `const` modifier with `final`, `var`,\nor a type annotation:\n\n```dart\nvoid f() {\n  for (final x in [0, 1, 2]) {\n    print(x);\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "function_typed_parameter_var",
    "description": "_Function-typed parameters can't specify 'const', 'final' or 'var' in place of a return type._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "generic_function_type_cannot_be_bound",
    "description": "_Generic function types can't be used as type parameter bounds._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "generic_function_type_cannot_be_type_argument",
    "description": "_A generic function type can't be a type argument._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "generic_method_type_instantiation_on_dynamic",
    "description": "_A method tear-off on a receiver whose type is 'dynamic' can't have type arguments._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an instance method is being torn\noff from a receiver whose type is `dynamic`, and the tear-off includes type\narguments. Because the analyzer can't know how many type parameters the\nmethod has, or whether it has any type parameters, there's no way it can\nvalidate that the type arguments are correct. As a result, the type\narguments aren't allowed.\n\n## Example\n\nThe following code produces this diagnostic because the type of `p` is\n`dynamic` and the tear-off of `m` has type arguments:\n\n```dart\nvoid f(dynamic list) {\n  [!list.fold!]<int>;\n}\n```\n\n## Common fixes\n\nIf you can use a more specific type than `dynamic`, then change the type of\nthe receiver:\n\n```dart\nvoid f(List<Object> list) {\n  list.fold<int>;\n}\n```\n\nIf you can't use a more specific type, then remove the type arguments:\n\n```dart\nvoid f(dynamic list) {\n  list.cast;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "generic_struct_subclass",
    "description": "_The class '{0}' can't extend 'Struct' or 'Union' because '{0}' is generic._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a subclass of either `Struct`\nor `Union` has a type parameter.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the class `S` defines\nthe type parameter `T`:\n\n```dart\nimport 'dart:ffi';\n\nfinal class [!S!]<T> extends Struct {\n  external Pointer notEmpty;\n}\n```\n\n## Common fixes\n\nRemove the type parameters from the class:\n\n```dart\nimport 'dart:ffi';\n\nfinal class S extends Struct {\n  external Pointer notEmpty;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "getter_constructor",
    "description": "_Constructors can't be a getter._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "getter_in_function",
    "description": "_Getters can't be defined within methods or functions._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "getter_not_assignable_setter_types",
    "description": "_The return type of getter '{0}' is '{1}' which isn't assignable to the type '{2}' of its setter '{3}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "getter_not_subtype_setter_types",
    "description": "_The return type of getter '{0}' is '{1}' which isn't a subtype of the type '{2}' of its setter '{3}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the return type of a getter\nisn't a subtype of the type of the parameter of a setter with the same\nname.\n\nThe subtype relationship is a requirement whether the getter and setter are\nin the same class or whether one of them is in a superclass of the other.\n\n## Example\n\nThe following code produces this diagnostic because the return type of the\ngetter `x` is `num`, the parameter type of the setter `x` is `int`, and\n`num` isn't a subtype of `int`:\n\n```dart\nclass C {\n  num get [!x!] => 0;\n\n  set x(int y) {}\n}\n```\n\n## Common fixes\n\nIf the type of the getter is correct, then change the type of the setter:\n\n```dart\nclass C {\n  num get x => 0;\n\n  set x(num y) {}\n}\n```\n\nIf the type of the setter is correct, then change the type of the getter:\n\n```dart\nclass C {\n  int get x => 0;\n\n  set x(int y) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "getter_with_parameters",
    "description": "_Getters must be declared without a parameter list._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "hack",
    "description": "_{0}_",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "if_element_condition_from_deferred_library",
    "description": "_Constant values from a deferred library can't be used as values in an if condition inside a const collection literal._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "illegal_assignment_to_non_assignable",
    "description": "_Illegal assignment to non-assignable expression._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "illegal_async_generator_return_type",
    "description": "_Functions marked 'async*' must have a return type that is a supertype of 'Stream<T>' for some type 'T'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the body of a function has the\n`async*` modifier even though the return type of the function isn't either\n`Stream` or a supertype of `Stream`.\n\n## Example\n\nThe following code produces this diagnostic because the body of the\nfunction `f` has the 'async*' modifier even though the return type `int`\nisn't a supertype of `Stream`:\n\n```dart\n[!int!] f() async* {}\n```\n\n## Common fixes\n\nIf the function should be asynchronous, then change the return type to be\neither `Stream` or a supertype of `Stream`:\n\n```dart\nStream<int> f() async* {}\n```\n\nIf the function should be synchronous, then remove the `async*` modifier:\n\n```dart\nint f() => 0;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "illegal_async_return_type",
    "description": "_Functions marked 'async' must have a return type which is a supertype of 'Future'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the body of a function has the\n`async` modifier even though the return type of the function isn't\nassignable to `Future`.\n\n## Example\n\nThe following code produces this diagnostic because the body of the\nfunction `f` has the `async` modifier even though the return type isn't\nassignable to `Future`:\n\n```dart\n[!int!] f() async {\n  return 0;\n}\n```\n\n## Common fixes\n\nIf the function should be asynchronous, then change the return type to be\nassignable to `Future`:\n\n```dart\nFuture<int> f() async {\n  return 0;\n}\n```\n\nIf the function should be synchronous, then remove the `async` modifier:\n\n```dart\nint f() => 0;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "illegal_character",
    "description": "_Illegal character '{0}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "illegal_concrete_enum_member",
    "description": "_A concrete instance member named '{0}' can't be declared in a class that implements 'Enum'._\n\n_A concrete instance member named '{0}' can't be inherited from '{1}' in a class that implements 'Enum'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when either an enum declaration, a\nclass that implements `Enum`, or a mixin with a superclass constraint of\n`Enum`, declares or inherits a concrete instance member named either\n`index`, `hashCode`, or `==`.\n\n## Examples\n\nThe following code produces this diagnostic because the enum `E` declares\nan instance getter named `index`:\n\n```dart\nenum E {\n  v;\n\n  int get [!index!] => 0;\n}\n```\n\nThe following code produces this diagnostic because the class `C`, which\nimplements `Enum`, declares an instance field named `hashCode`:\n\n```dart\nabstract class C implements Enum {\n  int [!hashCode!] = 0;\n}\n```\n\nThe following code produces this diagnostic because the class `C`, which\nindirectly implements `Enum` through the class `A`, declares an instance\ngetter named `hashCode`:\n\n```dart\nabstract class A implements Enum {}\n\nabstract class C implements A {\n  int get [!hashCode!] => 0;\n}\n```\n\nThe following code produces this diagnostic because the mixin `M`, which\nhas `Enum` in the `on` clause, declares an explicit operator named `==`:\n\n```dart\nmixin M on Enum {\n  bool operator [!==!](Object other) => false;\n}\n```\n\n## Common fixes\n\nRename the conflicting member:\n\n```dart\nenum E {\n  v;\n\n  int get getIndex => 0;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "illegal_enum_values",
    "description": "_An instance member named 'values' can't be declared in a class that implements 'Enum'._\n\n_An instance member named 'values' can't be inherited from '{0}' in a class that implements 'Enum'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when either a class that implements\n`Enum` or a mixin with a superclass constraint of `Enum` has an instance\nmember named `values`.\n\n## Examples\n\nThe following code produces this diagnostic because the class `C`, which\nimplements `Enum`, declares an instance field named `values`:\n\n```dart\nabstract class C implements Enum {\n  int get [!values!] => 0;\n}\n```\n\nThe following code produces this diagnostic because the class `B`, which\nimplements `Enum`, inherits an instance method named `values` from `A`:\n\n```dart\nabstract class A {\n  int values() => 0;\n}\n\nabstract class [!B!] extends A implements Enum {}\n```\n\n## Common fixes\n\nChange the name of the conflicting member:\n\n```dart\nabstract class C implements Enum {\n  int get value => 0;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "illegal_language_version_override",
    "description": "_The language version must be {0}._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "illegal_pattern_assignment_variable_name",
    "description": "_A variable assigned by a pattern assignment can't be named '{0}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "illegal_pattern_identifier_name",
    "description": "_A pattern can't refer to an identifier named '{0}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "illegal_pattern_variable_name",
    "description": "_The variable declared by a variable pattern can't be named '{0}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "illegal_sync_generator_return_type",
    "description": "_Functions marked 'sync*' must have a return type that is a supertype of 'Iterable<T>' for some type 'T'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the body of a function has the\n`sync*` modifier even though the return type of the function isn't either\n`Iterable` or a supertype of `Iterable`.\n\n## Example\n\nThe following code produces this diagnostic because the body of the\nfunction `f` has the 'sync*' modifier even though the return type `int`\nisn't a supertype of `Iterable`:\n\n```dart\n[!int!] f() sync* {}\n```\n\n## Common fixes\n\nIf the function should return an iterable, then change the return type to\nbe either `Iterable` or a supertype of `Iterable`:\n\n```dart\nIterable<int> f() sync* {}\n```\n\nIf the function should return a single value, then remove the `sync*`\nmodifier:\n\n```dart\nint f() => 0;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "implements_before_extends",
    "description": "_The extends clause must be before the implements clause._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "implements_before_on",
    "description": "_The on clause must be before the implements clause._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "implements_before_with",
    "description": "_The with clause must be before the implements clause._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "implements_non_class",
    "description": "_Classes and mixins can only implement other classes and mixins._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a name used in the `implements`\nclause of a class or mixin declaration is defined to be something other\nthan a class or mixin.\n\n## Example\n\nThe following code produces this diagnostic because `x` is a variable\nrather than a class or mixin:\n\n```dart\nvar x;\nclass C implements [!x!] {}\n```\n\n## Common fixes\n\nIf the name is the name of an existing class or mixin that's already being\nimported, then add a prefix to the import so that the local definition of\nthe name doesn't shadow the imported name.\n\nIf the name is the name of an existing class or mixin that isn't being\nimported, then add an import, with a prefix, for the library in which it's\ndeclared.\n\nOtherwise, either replace the name in the `implements` clause with the name\nof an existing class or mixin, or remove the name from the `implements`\nclause.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "implements_repeated",
    "description": "_'{0}' can only be implemented once._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a single class is specified more\nthan once in an `implements` clause.\n\n## Example\n\nThe following code produces this diagnostic because `A` is in the list\ntwice:\n\n```dart\nclass A {}\nclass B implements A, [!A!] {}\n```\n\n## Common fixes\n\nRemove all except one occurrence of the class name:\n\n```dart\nclass A {}\nclass B implements A {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "implements_super_class",
    "description": "_'{0}' can't be used in both the 'extends' and 'implements' clauses._\n\n_'{0}' can't be used in both the 'extends' and 'with' clauses._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class is listed in the\n`extends` clause of a class declaration and also in either the\n`implements` or `with` clause of the same declaration.\n\n## Example\n\nThe following code produces this diagnostic because the class `A` is used\nin both the `extends` and `implements` clauses for the class `B`:\n\n```dart\nclass A {}\n\nclass B extends A implements [!A!] {}\n```\n\nThe following code produces this diagnostic because the class `A` is used\nin both the `extends` and `with` clauses for the class `B`:\n\n```dart\nmixin class A {}\n\nclass B extends A with [!A!] {}\n```\n\n## Common fixes\n\nIf you want to inherit the implementation from the class, then remove the\nclass from the `implements` clause:\n\n```dart\nclass A {}\n\nclass B extends A {}\n```\n\nIf you don't want to inherit the implementation from the class, then remove\nthe `extends` clause:\n\n```dart\nclass A {}\n\nclass B implements A {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "implicit_super_initializer_missing_arguments",
    "description": "_The implicitly invoked unnamed constructor from '{0}' has required parameters._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor implicitly\ninvokes the unnamed constructor from the superclass, the unnamed\nconstructor of the superclass has a required parameter, and there's no\nsuper parameter corresponding to the required parameter.\n\n## Examples\n\nThe following code produces this diagnostic because the unnamed\nconstructor in the class `B` implicitly invokes the unnamed constructor in\nthe class `A`, but the constructor in `A` has a required positional\nparameter named `x`:\n\n```dart\nclass A {\n  A(int x);\n}\n\nclass B extends A {\n  [!B!]();\n}\n```\n\nThe following code produces this diagnostic because the unnamed\nconstructor in the class `B` implicitly invokes the unnamed constructor in\nthe class `A`, but the constructor in `A` has a required named parameter\nnamed `x`:\n\n```dart\nclass A {\n  A({required int x});\n}\n\nclass B extends A {\n  [!B!]();\n}\n```\n\n## Common fixes\n\nIf you can add a parameter to the constructor in the subclass, then add a\nsuper parameter corresponding to the required parameter in the superclass'\nconstructor. The new parameter can either be required:\n\n```dart\nclass A {\n  A({required int x});\n}\n\nclass B extends A {\n  B({required super.x});\n}\n```\n\nor it can be optional:\n\n```dart\nclass A {\n  A({required int x});\n}\n\nclass B extends A {\n  B({super.x = 0});\n}\n```\n\nIf you can't add a parameter to the constructor in the subclass, then add\nan explicit super constructor invocation with the required argument:\n\n```dart\nclass A {\n  A(int x);\n}\n\nclass B extends A {\n  B() : super(0);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "implicit_this_reference_in_initializer",
    "description": "_The instance member '{0}' can't be accessed in an initializer._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it finds a reference to an\ninstance member in a constructor's initializer list.\n\n## Example\n\nThe following code produces this diagnostic because `defaultX` is an\ninstance member:\n\n```dart\nclass C {\n  int x;\n\n  C() : x = [!defaultX!];\n\n  int get defaultX => 0;\n}\n```\n\n## Common fixes\n\nIf the member can be made static, then do so:\n\n```dart\nclass C {\n  int x;\n\n  C() : x = defaultX;\n\n  static int get defaultX => 0;\n}\n```\n\nIf not, then replace the reference in the initializer with a different\nexpression that doesn't use an instance member:\n\n```dart\nclass C {\n  int x;\n\n  C() : x = 0;\n\n  int get defaultX => 0;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "import_deferred_library_with_load_function",
    "description": "_The imported library defines a top-level function named 'loadLibrary' that is hidden by deferring this library._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a library that declares a\nfunction named `loadLibrary` is imported using a deferred import. A\ndeferred import introduces an implicit function named `loadLibrary`. This\nfunction is used to load the contents of the deferred library, and the\nimplicit function hides the explicit declaration in the deferred library.\n\nFor more information, check out\n[Lazily loading a library](https://dart.dev/language/libraries#lazily-loading-a-library).\n\n## Example\n\nGiven a file `a.dart` that defines a function named `loadLibrary`:\n\n```dart\nvoid loadLibrary(Library library) {}\n\nclass Library {}\n```\n\nThe following code produces this diagnostic because the implicit\ndeclaration of `a.loadLibrary` is hiding the explicit declaration of\n`loadLibrary` in `a.dart`:\n\n```dart\n[!import 'a.dart' deferred as a;!]\n\nvoid f() {\n  a.Library();\n}\n```\n\n## Common fixes\n\nIf the imported library isn't required to be deferred, then remove the\nkeyword `deferred`:\n\n```dart\nimport 'a.dart' as a;\n\nvoid f() {\n  a.Library();\n}\n```\n\nIf the imported library is required to be deferred and you need to\nreference the imported function, then rename the function in the imported\nlibrary:\n\n```dart\nvoid populateLibrary(Library library) {}\n\nclass Library {}\n```\n\nIf the imported library is required to be deferred and you don't need to\nreference the imported function, then add a `hide` clause:\n\n```dart\nimport 'a.dart' deferred as a hide loadLibrary;\n\nvoid f() {\n  a.Library();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "import_directive_after_part_directive",
    "description": "_Import directives must precede part directives._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "import_internal_library",
    "description": "_The library '{0}' is internal and can't be imported._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it finds an import whose `dart:`\nURI references an internal library.\n\n## Example\n\nThe following code produces this diagnostic because `_interceptors` is an\ninternal library:\n\n```dart\nimport [!'dart:_interceptors'!];\n```\n\n## Common fixes\n\nRemove the import directive.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "import_of_legacy_library_into_null_safe",
    "description": "_The library '{0}' is legacy, and shouldn't be imported into a null safe library._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a library that is null safe\nimports a library that isn't null safe.\n\n## Example\n\nGiven a file `a.dart` that contains the following:\n\n```dart\n// @dart = 2.9\n\nclass A {}\n```\n\nThe following code produces this diagnostic because a library that null\nsafe is importing a library that isn't null safe:\n\n```dart\nimport [!'a.dart'!];\n\nA? f() => null;\n```\n\n## Common fixes\n\nIf you can migrate the imported library to be null safe, then migrate it\nand update or remove the migrated library's language version.\n\nIf you can't migrate the imported library, then the importing library\nneeds to have a language version that is before 2.12, when null safety was\nenabled by default.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "import_of_non_library",
    "description": "_The imported library '{0}' can't have a part-of directive._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a [part file][] is imported\ninto a library.\n\n## Example\n\nGiven a [part file][] named `part.dart` containing the following:\n\n```dart\npart of lib;\n```\n\nThe following code produces this diagnostic because imported files can't\nhave a part-of directive:\n\n```dart\nlibrary lib;\n\nimport [!'part.dart'!];\n```\n\n## Common fixes\n\nImport the library that contains the [part file][] rather than the\n[part file][] itself.\n\n[part file]: /resources/glossary#part-file\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "included_file_parse_error",
    "description": "_{0} in {1}({2}..{3})_",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the content of a file that is\nincluded into an analysis options file isn't valid YAML.\n\n## Example\n\nGiven a file named `shared.yaml` that contains:\n\n```yaml\n// %uri=\"shared.yaml\"\nanalyzer:\n  enable-experiment:\n    - augmentations\n  enable-experiment:\n    - dot-shorthands\n```\n\nThe following code produces this diagnostic because the included file\nisn't valid YAML: the analyzer map contains duplicate `enable-experiment`\nkeys.\n\n```yaml\n// %uri=\"analysis_options.yaml\"\ninclude: [!shared.yaml!]\nanalyzer:\n  enable-experiment:\n    - enhanced-parts\n```\n\n## Common fixes\n\nIf the file is intended to be included, then correct the included file to\nbe valid YAML:\n\n```yaml\n// %uri=\"shared.yaml\"\nanalyzer:\n  enable-experiment:\n    - augmentations\n    - dot-shorthands\n```\n\nIf the file isn't intended to be included, then remove the `include` key:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nanalyzer:\n  enable-experiment:\n    - enhanced-parts\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "included_file_warning",
    "description": "_Warning in the included options file {0}({1}..{2}): {3}_",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an analysis options file\ncontains an `include` key, and the included file contains a warning.\n\n## Example\n\nGiven a file named `shared.yaml` that contains:\n\n```yaml\n// %uri=\"shared.yaml\"\nlinter:\n  rules:\n    - undefined_lint_rule\n```\n\nThe following code produces this diagnostic because the file `shared.yaml`\nhas a warning that the rule `undefined_lint_rule` doesn't exist:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\ninclude: [!shared.yaml!]\n```\n\n## Common fixes\n\nIf the included file can be fixed, then fix the warning in it.\n\nIf the included file can't be fixed, then don't include it.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "include_file_not_found",
    "description": "_The URI '{0}' included in '{1}' can't be found when analyzing '{2}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an `include` key in an analysis\noptions file specifies a URI that either can't be resolved or doesn't\nexist.\n\n## Example\n\nThe following code produces this diagnostic because the URI refers to a\npackage that doesn't exist:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\ninclude: package:lint/recommended.yaml\n```\n\n## Common fixes\n\nIf the URI is incorrect, replace it with a correct URI:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\ninclude: package:lints/recommended.yaml\n```\n\nIf the URI is correct but the package isn't a dependency, add a\n`dev_dependency` for the package to the `pubspec.yaml` file and run\n`dart pub get` or `flutter pub get`.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "incompatible_lint",
    "description": "_The rule '{0}' is incompatible with '{1}'._\n\n_The rule '{0}' is incompatible with {1}, which is included from {2} file{3}._\n\n_The rule '{0}' is incompatible with {1}._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when two specified lint rules are\nincompatible, such as when they enforce opposite styles.\n\n## Example\n\nThe following code produces this diagnostic because the rules\n`prefer_single_quotes` and `prefer_double_quotes` are incompatible with\neach other:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nlinter:\n  rules:\n    - prefer_single_quotes\n    - [!prefer_double_quotes!]\n```\n\n## Common fixes\n\nRemove all but one of the incompatible rules:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nlinter:\n  rules:\n    - prefer_single_quotes\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "inconsistent_case_expression_types",
    "description": "_Case expressions must have the same types, '{0}' isn't a '{1}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "inconsistent_inheritance",
    "description": "_Superinterfaces don't have a valid override for '{0}': {1}._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class inherits two or more\nconflicting signatures for a member and doesn't provide an implementation\nthat satisfies all the inherited signatures.\n\n## Example\n\nThe following code produces this diagnostic because `C` is inheriting the\ndeclaration of `m` from `A`, and that implementation isn't consistent with\nthe signature of `m` that's inherited from `B`:\n\n```dart\nclass A {\n  void m({int? a}) {}\n}\n\nclass B {\n  void m({int? b}) {}\n}\n\nclass [!C!] extends A implements B {\n}\n```\n\n## Common fixes\n\nAdd an implementation of the method that satisfies all the inherited\nsignatures:\n\n```dart\nclass A {\n  void m({int? a}) {}\n}\n\nclass B {\n  void m({int? b}) {}\n}\n\nclass C extends A implements B {\n  void m({int? a, int? b}) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "inconsistent_inheritance_getter_and_method",
    "description": "_'{0}' is inherited as a getter (from '{1}') and also a method (from '{2}')._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "inconsistent_language_version_override",
    "description": "_Parts must have exactly the same language version override as the library._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a [part file][] has a language\nversion override comment that specifies a different language version than\nthe one being used for the library to which the part belongs.\n\n## Example\n\nGiven a [part file][] named `part.dart` that contains the following:\n\n```dart\n// @dart = 2.14\npart of 'test.dart';\n```\n\nThe following code produces this diagnostic because the parts of a library\nmust have the same language version as the defining compilation unit:\n\n```dart\n// @dart = 2.15\npart [!'part.dart'!];\n```\n\n## Common fixes\n\nRemove the language version override from the [part file][], so that it\nimplicitly uses the same version as the defining compilation unit:\n\n```dart\npart of 'test.dart';\n```\n\nIf necessary, either adjust the language version override in the defining\ncompilation unit to be appropriate for the code in the part, or migrate\nthe code in the [part file][] to be consistent with the new language\nversion.\n\n[part file]: /resources/glossary#part-file\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "inconsistent_pattern_variable_logical_or",
    "description": "_The variable '{0}' has a different type and/or finality in this branch of the logical-or pattern._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a pattern variable that is\ndeclared on all branches of a logical-or pattern doesn't have the same\ntype on every branch. It is also produced when the variable has a\ndifferent finality on different branches. A pattern variable declared on\nmultiple branches of a logical-or pattern is required to have the same\ntype and finality in each branch, so that the type and finality of the\nvariable can be known in code that's guarded by the logical-or pattern.\n\n## Examples\n\nThe following code produces this diagnostic because the variable `a` is\ndefined to be an `int` on one branch and a `double` on the other:\n\n```dart\nvoid f(Object? x) {\n  if (x case (int a) || (double [!a!])) {\n    print(a);\n  }\n}\n```\n\nThe following code produces this diagnostic because the variable `a` is\n`final` in the first branch and isn't `final` in the second branch:\n\n```dart\nvoid f(Object? x) {\n  if (x case (final int a) || (int [!a!])) {\n    print(a);\n  }\n}\n```\n\n## Common fixes\n\nIf the finality of the variable is different, decide whether it should be\n`final` or not `final` and make the cases consistent:\n\n```dart\nvoid f(Object? x) {\n  if (x case (int a) || (int a)) {\n    print(a);\n  }\n}\n```\n\nIf the type of the variable is different and the type isn't critical to\nthe condition being matched, then ensure that the variable has the same\ntype on both branches:\n\n```dart\nvoid f(Object? x) {\n  if (x case (num a) || (num a)) {\n    print(a);\n  }\n}\n```\n\nIf the type of the variable is different and the type is critical to the\ncondition being matched, then consider breaking the condition into\nmultiple `if` statements or `case` clauses:\n\n```dart\nvoid f(Object? x) {\n  if (x case int a) {\n    print(a);\n  } else if (x case double a) {\n    print(a);\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "inference_failure_on_collection_literal",
    "description": "_The type argument(s) of '{0}' can't be inferred._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when:\n- the language option `strict-inference` is enabled in the analysis options file,\n- a list, map, or set literal has no type arguments, and\n- the values for the type arguments can't be inferred from the elements.\n\n## Example\n\nGiven an analysis options file containing the following:\n\n```yaml\nanalyzer:\n  language:\n    strict-inference: true\n```\n\nThe following code produces this diagnostic because the type of the list\nliteral's elements can't be inferred:\n\n```dart\nvoid f() {\n  var list = [![]!];\n  print(list);\n}\n```\n\n## Common fixes\n\nProvide explicit type arguments for the literal:\n\n```dart\nvoid f() {\n  var list = <int>[];\n  print(list);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "inference_failure_on_function_invocation",
    "description": "_The type argument(s) of the function '{0}' can't be inferred._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when:\n- the language option `strict-inference` is enabled in the analysis options file,\n- the invocation of a method or function has no type arguments, and\n- the values for the type arguments can't be inferred.\n\n## Example\n\nGiven an analysis options file containing the following:\n\n```yaml\nanalyzer:\n  language:\n    strict-inference: true\n```\n\nThe following code produces this diagnostic because the invocation of `m`\nhas no explicit type arguments, and the arguments can't be inferred:\n\n```dart\nabstract class C {\n  void m<T>();\n}\n\nvoid f(C c) {\n  c.[!m!]();\n}\n```\n\n## Common fixes\n\nProvide explicit type arguments for the invocation:\n\n```dart\nabstract class C {\n  void m<T>();\n}\n\nvoid f(C c) {\n  c.m<int>();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "inference_failure_on_function_return_type",
    "description": "_The return type of '{0}' can't be inferred._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when:\n- the language option `strict-inference` is enabled in the analysis options file,\n- the declaration of a method or function has no return type, and\n- the return type can't be inferred.\n\n## Example\n\nGiven an analysis options file containing the following:\n\n```yaml\nanalyzer:\n  language:\n    strict-inference: true\n```\n\nThe following code produces this diagnostic because the method `m` doesn't\nhave a return type:\n\n```dart\nclass C {\n  [!m!]() => 7;\n}\n```\n\n## Common fixes\n\nAdd a return type to the method or function:\n\n```dart\nclass C {\n  int m() => 7;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "inference_failure_on_generic_invocation",
    "description": "_The type argument(s) of the generic function type '{0}' can't be inferred._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "inference_failure_on_instance_creation",
    "description": "_The type argument(s) of the constructor '{0}' can't be inferred._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "inference_failure_on_uninitialized_variable",
    "description": "_The type of {0} can't be inferred without either a type or initializer._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when:\n- the language option `strict-inference` is enabled in the analysis options file,\n- the declaration of a variable has no type, and\n- the type of the variable can't be inferred.\n\n## Example\n\nGiven an analysis options file containing the following:\n\n```yaml\nanalyzer:\n  language:\n    strict-inference: true\n```\n\nThe following code produces this diagnostic because the variable `s`\ndoesn't have an explicit type and the type can't be inferred because\nthere's no initializer:\n\n```dart\nvar [!s!];\n```\n\n## Common fixes\n\nAdd an explicit type:\n\n```dart\nString? s;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "inference_failure_on_untyped_parameter",
    "description": "_The type of {0} can't be inferred; a type must be explicitly provided._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when:\n- the language option `strict-inference` is enabled in the analysis options file,\n- the declaration of a formal parameter has no type, and\n- the type of the parameter can't be inferred.\n\nThe type of a method's parameter can be inferred if it overrides an\ninherited method.\n\n## Example\n\nGiven an analysis options file containing the following:\n\n```yaml\nanalyzer:\n  language:\n    strict-inference: true\n```\n\nThe following code produces this diagnostic because the formal parameter\n`p` doesn't have an explicit type and the type can't be inferred:\n\n```dart\nvoid f([!p!]) => print(p);\n```\n\n## Common fixes\n\nAdd an explicit type:\n\n```dart\nvoid f(int p) => print(p);\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "initialized_variable_in_for_each",
    "description": "_The loop variable in a for-each loop can't be initialized._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "initializer_for_non_existent_field",
    "description": "_'{0}' isn't a field in the enclosing class._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor initializes a\nfield that isn't declared in the class containing the constructor.\nConstructors can't initialize fields that aren't declared and fields that\nare inherited from superclasses.\n\n## Example\n\nThe following code produces this diagnostic because the initializer is\ninitializing `x`, but `x` isn't a field in the class:\n\n```dart\nclass C {\n  int? y;\n\n  C() : [!x = 0!];\n}\n```\n\n## Common fixes\n\nIf a different field should be initialized, then change the name to the\nname of the field:\n\n```dart\nclass C {\n  int? y;\n\n  C() : y = 0;\n}\n```\n\nIf the field must be declared, then add a declaration:\n\n```dart\nclass C {\n  int? x;\n  int? y;\n\n  C() : x = 0;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "initializer_for_static_field",
    "description": "_'{0}' is a static field in the enclosing class. Fields initialized in a constructor can't be static._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a static field is initialized\nin a constructor using either an initializing formal parameter or an\nassignment in the initializer list.\n\n## Example\n\nThe following code produces this diagnostic because the static field `a`\nis being initialized by the initializing formal parameter `this.a`:\n\n```dart\nclass C {\n  static int? a;\n  C([!this.a!]);\n}\n```\n\n## Common fixes\n\nIf the field should be an instance field, then remove the keyword `static`:\n\n```dart\nclass C {\n  int? a;\n  C(this.a);\n}\n```\n\nIf you intended to initialize an instance field and typed the wrong name,\nthen correct the name of the field being initialized:\n\n```dart\nclass C {\n  static int? a;\n  int? b;\n  C(this.b);\n}\n```\n\nIf you really want to initialize the static field, then move the\ninitialization into the constructor body:\n\n```dart\nclass C {\n  static int? a;\n  C(int? c) {\n    a = c;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "initializing_formal_for_non_existent_field",
    "description": "_'{0}' isn't a field in the enclosing class._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an initializing formal\nparameter is found in a constructor in a class that doesn't declare the\nfield being initialized. Constructors can't initialize fields that aren't\ndeclared and fields that are inherited from superclasses.\n\n## Example\n\nThe following code produces this diagnostic because the field `x` isn't\ndefined:\n\n```dart\nclass C {\n  int? y;\n\n  C([!this.x!]);\n}\n```\n\n## Common fixes\n\nIf the field name was wrong, then change it to the name of an existing\nfield:\n\n```dart\nclass C {\n  int? y;\n\n  C(this.y);\n}\n```\n\nIf the field name is correct but hasn't yet been defined, then declare the\nfield:\n\n```dart\nclass C {\n  int? x;\n  int? y;\n\n  C(this.x);\n}\n```\n\nIf the parameter is needed but shouldn't initialize a field, then convert\nit to a normal parameter and use it:\n\n```dart\nclass C {\n  int y;\n\n  C(int x) : y = x * 2;\n}\n```\n\nIf the parameter isn't needed, then remove it:\n\n```dart\nclass C {\n  int? y;\n\n  C();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "instance_access_to_static_member",
    "description": "_The static {0} '{1}' can't be accessed through an instance._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an access operator is used to\naccess a static member through an instance of the class.\n\n## Example\n\nThe following code produces this diagnostic because `zero` is a static\nfield, but it's being accessed as if it were an instance field:\n\n```dart\nvoid f(C c) {\n  c.[!zero!];\n}\n\nclass C {\n  static int zero = 0;\n}\n```\n\n## Common fixes\n\nUse the class to access the static member:\n\n```dart\nvoid f(C c) {\n  C.zero;\n}\n\nclass C {\n  static int zero = 0;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "instance_member_access_from_factory",
    "description": "_Instance members can't be accessed from a factory constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a factory constructor contains\nan unqualified reference to an instance member. In a generative\nconstructor, the instance of the class is created and initialized before\nthe body of the constructor is executed, so the instance can be bound to\n`this` and accessed just like it would be in an instance method. But, in a\nfactory constructor, the instance isn't created before executing the body,\nso `this` can't be used to reference it.\n\n## Example\n\nThe following code produces this diagnostic because `x` isn't in scope in\nthe factory constructor:\n\n```dart\nclass C {\n  int x;\n  factory C() {\n    return C._([!x!]);\n  }\n  C._(this.x);\n}\n```\n\n## Common fixes\n\nRewrite the code so that it doesn't reference the instance member:\n\n```dart\nclass C {\n  int x;\n  factory C() {\n    return C._(0);\n  }\n  C._(this.x);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "instance_member_access_from_static",
    "description": "_Instance members can't be accessed from a static method._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a static method contains an\nunqualified reference to an instance member.\n\n## Example\n\nThe following code produces this diagnostic because the instance field `x`\nis being referenced in a static method:\n\n```dart\nclass C {\n  int x = 0;\n\n  static int m() {\n    return [!x!];\n  }\n}\n```\n\n## Common fixes\n\nIf the method must reference the instance member, then it can't be static,\nso remove the keyword:\n\n```dart\nclass C {\n  int x = 0;\n\n  int m() {\n    return x;\n  }\n}\n```\n\nIf the method can't be made an instance method, then add a parameter so\nthat an instance of the class can be passed in:\n\n```dart\nclass C {\n  int x = 0;\n\n  static int m(C c) {\n    return c.x;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "instantiate_abstract_class",
    "description": "_Abstract classes can't be instantiated._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it finds a constructor\ninvocation and the constructor is declared in an abstract class. Even\nthough you can't create an instance of an abstract class, abstract classes\ncan declare constructors that can be invoked by subclasses.\n\n## Example\n\nThe following code produces this diagnostic because `C` is an abstract\nclass:\n\n```dart\nabstract class C {}\n\nvar c = new [!C!]();\n```\n\n## Common fixes\n\nIf there's a concrete subclass of the abstract class that can be used, then\ncreate an instance of the concrete subclass.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "instantiate_enum",
    "description": "_Enums can't be instantiated._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an enum is instantiated. It's\ninvalid to create an instance of an enum by invoking a constructor; only\nthe instances named in the declaration of the enum can exist.\n\n## Example\n\nThe following code produces this diagnostic because the enum `E` is being\ninstantiated:\n\n```dart\n// @dart = 2.16\nenum E {a}\n\nvar e = [!E!]();\n```\n\n## Common fixes\n\nIf you intend to use an instance of the enum, then reference one of the\nconstants defined in the enum:\n\n```dart\n// @dart = 2.16\nenum E {a}\n\nvar e = E.a;\n```\n\nIf you intend to use an instance of a class, then use the name of that class in place of the name of the enum.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "instantiate_type_alias_expands_to_type_parameter",
    "description": "_Type aliases that expand to a type parameter can't be instantiated._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor invocation is\nfound where the type being instantiated is a type alias for one of the type\nparameters of the type alias. This isn't allowed because the value of the\ntype parameter is a type rather than a class.\n\n## Example\n\nThe following code produces this diagnostic because it creates an instance\nof `A`, even though `A` is a type alias that is defined to be equivalent to\na type parameter:\n\n```dart\ntypedef A<T> = T;\n\nvoid f() {\n  const [!A!]<int>();\n}\n```\n\n## Common fixes\n\nUse either a class name or a type alias defined to be a class, rather than\na type alias defined to be a type parameter:\n\n```dart\ntypedef A<T> = C<T>;\n\nvoid f() {\n  const A<int>();\n}\n\nclass C<T> {\n  const C();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "integer_literal_imprecise_as_double",
    "description": "_The integer literal is being used as a double, but can't be represented as a 64-bit double without overflow or loss of precision: '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an integer literal is being\nimplicitly converted to a double, but can't be represented as a 64-bit\ndouble without overflow or loss of precision. Integer literals are\nimplicitly converted to a double if the context requires the type `double`.\n\n## Example\n\nThe following code produces this diagnostic because the integer value\n`9223372036854775807` can't be represented exactly as a double:\n\n```dart\ndouble x = [!9223372036854775807!];\n```\n\n## Common fixes\n\nIf you need to use the exact value, then use the class `BigInt` to\nrepresent the value:\n\n```dart\nvar x = BigInt.parse('9223372036854775807');\n```\n\nIf you need to use a double, then change the value to one that can be\nrepresented exactly:\n\n```dart\ndouble x = 9223372036854775808;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "integer_literal_out_of_range",
    "description": "_The integer literal {0} can't be represented in 64 bits._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an integer literal has a value\nthat is too large (positive) or too small (negative) to be represented in a\n64-bit word.\n\n## Example\n\nThe following code produces this diagnostic because the value can't be\nrepresented in 64 bits:\n\n```dart\nvar x = [!9223372036854775810!];\n```\n\n## Common fixes\n\nIf you need to represent the current value, then wrap it in an instance of\nthe class `BigInt`:\n\n```dart\nvar x = BigInt.parse('9223372036854775810');\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "interface_enum",
    "description": "_Enums can't be declared to be 'interface'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "interface_mixin",
    "description": "_A mixin can't be declared 'interface'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "interface_mixin_class",
    "description": "_A mixin class can't be declared 'interface'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_annotation",
    "description": "_Annotation must be either a const variable reference or const constructor invocation._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an annotation is found that is\nusing something that is neither a variable marked as `const` or the\ninvocation of a `const` constructor.\n\nGetters can't be used as annotations.\n\n## Examples\n\nThe following code produces this diagnostic because the variable `v` isn't\na `const` variable:\n\n```dart\nvar v = 0;\n\n[!@v!]\nvoid f() {\n}\n```\n\nThe following code produces this diagnostic because `f` isn't a variable:\n\n```dart\n[!@f!]\nvoid f() {\n}\n```\n\nThe following code produces this diagnostic because `f` isn't a\nconstructor:\n\n```dart\n[!@f()!]\nvoid f() {\n}\n```\n\nThe following code produces this diagnostic because `g` is a getter:\n\n```dart\n[!@g!]\nint get g => 0;\n```\n\n## Common fixes\n\nIf the annotation is referencing a variable that isn't a `const`\nconstructor, add the keyword `const` to the variable's declaration:\n\n```dart\nconst v = 0;\n\n@v\nvoid f() {\n}\n```\n\nIf the annotation isn't referencing a variable, then remove it:\n\n```dart\nint v = 0;\n\nvoid f() {\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_annotation_constant_value_from_deferred_library",
    "description": "_Constant values from a deferred library can't be used in annotations._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constant defined in a library\nthat is imported as a deferred library is referenced in the argument list\nof an annotation. Annotations are evaluated at compile time, and values\nfrom deferred libraries aren't available at compile time.\n\nFor more information, check out\n[Lazily loading a library](https://dart.dev/language/libraries#lazily-loading-a-library).\n\n## Example\n\nThe following code produces this diagnostic because the constant `pi` is\nbeing referenced in the argument list of an annotation, even though the\nlibrary that defines it is being imported as a deferred library:\n\n```dart\nimport 'dart:math' deferred as math;\n\nclass C {\n  const C(double d);\n}\n\n@C(math.[!pi!])\nvoid f () {}\n```\n\n## Common fixes\n\nIf you need to reference the imported constant, then remove the `deferred`\nkeyword:\n\n```dart\nimport 'dart:math' as math;\n\nclass C {\n  const C(double d);\n}\n\n@C(math.pi)\nvoid f () {}\n```\n\nIf the import is required to be deferred and there's another constant that\nis appropriate, then use that constant in place of the constant from the\ndeferred library.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_annotation_from_deferred_library",
    "description": "_Constant values from a deferred library can't be used as annotations._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constant from a library that\nis imported using a deferred import is used as an annotation. Annotations\nare evaluated at compile time, and constants from deferred libraries aren't\navailable at compile time.\n\nFor more information, check out\n[Lazily loading a library](https://dart.dev/language/libraries#lazily-loading-a-library).\n\n## Example\n\nThe following code produces this diagnostic because the constant `pi` is\nbeing used as an annotation when the library `dart:math` is imported as\n`deferred`:\n\n```dart\nimport 'dart:math' deferred as math;\n\n@[!math.pi!]\nvoid f() {}\n```\n\n## Common fixes\n\nIf you need to reference the constant as an annotation, then remove the\nkeyword `deferred` from the import:\n\n```dart\nimport 'dart:math' as math;\n\n@math.pi\nvoid f() {}\n```\n\nIf you can use a different constant as an annotation, then replace the\nannotation with a different constant:\n\n```dart\n@deprecated\nvoid f() {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_annotation_target",
    "description": "_The annotation '{0}' can only be used on {1}._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an annotation is applied to a\nkind of declaration that it doesn't support.\n\n## Example\n\nThe following code produces this diagnostic because the `optionalTypeArgs`\nannotation isn't defined to be valid for top-level variables:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@[!optionalTypeArgs!]\nint x = 0;\n```\n\n## Common fixes\n\nRemove the annotation from the declaration.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_assignment",
    "description": "_A value of type '{0}' can't be assigned to a variable of type '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the static type of an expression\nthat is assigned to a variable isn't assignable to the type of the\nvariable.\n\n## Example\n\nThe following code produces this diagnostic because the type of the\ninitializer (`int`) isn't assignable to the type of the variable\n(`String`):\n\n```dart\nint i = 0;\nString s = [!i!];\n```\n\n## Common fixes\n\nIf the value being assigned is always assignable at runtime, even though\nthe static types don't reflect that, then add an explicit cast.\n\nOtherwise, change the value being assigned so that it has the expected\ntype. In the previous example, this might look like:\n\n```dart\nint i = 0;\nString s = i.toString();\n```\n\nIf you can't change the value, then change the type of the variable to be\ncompatible with the type of the value being assigned:\n\n```dart\nint i = 0;\nint s = i;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_await_in_for",
    "description": "_The keyword 'await' isn't allowed for a normal 'for' statement._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_await_not_required_annotation",
    "description": "_The annotation 'awaitNotRequired' can only be applied to a Future-returning function, or a Future-typed field._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when anything other than a\n`Future`-returning function or a `Future`-typed field or top-level\nvariable is annotated with [`awaitNotRequired`][meta-awaitNotRequired].\n\n## Example\n\nThe following code produces this diagnostic because the annotation is on a\n`void`-returning function:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@[!awaitNotRequired!]\nvoid f() {}\n```\n\n## Common fixes\n\nRemove the annotation:\n\n```dart\nvoid f() {}\n```\n\n[meta-awaitNotRequired]: https://pub.dev/documentation/meta/latest/meta/awaitNotRequired-constant.html\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_cast_function",
    "description": "_The function '{0}' has type '{1}' that isn't of expected type '{2}'. This means its parameter or return type doesn't match what is expected._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_cast_function_expr",
    "description": "_The function expression type '{0}' isn't of type '{1}'. This means its parameter or return type doesn't match what is expected. Consider changing parameter type(s) or the returned type(s)._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_cast_literal",
    "description": "_The literal '{0}' with type '{1}' isn't of expected type '{2}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_cast_literal_list",
    "description": "_The list literal type '{0}' isn't of expected type '{1}'. The list's type can be changed with an explicit generic type argument or by changing the element types._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_cast_literal_map",
    "description": "_The map literal type '{0}' isn't of expected type '{1}'. The map's type can be changed with an explicit generic type arguments or by changing the key and value types._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_cast_literal_set",
    "description": "_The set literal type '{0}' isn't of expected type '{1}'. The set's type can be changed with an explicit generic type argument or by changing the element types._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_cast_method",
    "description": "_The method tear-off '{0}' has type '{1}' that isn't of expected type '{2}'. This means its parameter or return type doesn't match what is expected._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_cast_new_expr",
    "description": "_The constructor returns type '{0}' that isn't of expected type '{1}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_code_point",
    "description": "_The escape sequence '{0}' isn't a valid code point._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_comment_reference",
    "description": "_Comment references should contain a possibly prefixed identifier and can start with 'new', but shouldn't contain anything else._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_constant",
    "description": "_Invalid constant value._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_constant_const_prefix",
    "description": "_The expression can't be prefixed by 'const' to form a constant pattern._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_constant_pattern_binary",
    "description": "_The binary operator {0} is not supported as a constant pattern._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_constant_pattern_duplicate_const",
    "description": "_Duplicate 'const' keyword in constant expression._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_constant_pattern_empty_record_literal",
    "description": "_The empty record literal is not supported as a constant pattern._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_constant_pattern_generic",
    "description": "_This expression is not supported as a constant pattern._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_constant_pattern_negation",
    "description": "_Only negation of a numeric literal is supported as a constant pattern._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_constant_pattern_unary",
    "description": "_The unary operator {0} is not supported as a constant pattern._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_constructor_name",
    "description": "_The name of a constructor must match the name of the enclosing class._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_dependency",
    "description": "_Publishable packages can't have '{0}' dependencies._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a publishable package\nincludes a package in the `dependencies` list of its `pubspec.yaml` file\nthat isn't a pub-hosted dependency.\n\nTo learn more about the different types of dependency sources,\ncheck out [Package dependencies](https://dart.dev/tools/pub/dependencies).\n\n## Example\n\nThe following code produces this diagnostic because the dependency on\nthe package `transmogrify` isn't a pub-hosted dependency.\n\n```yaml\nname: example\ndependencies:\n  transmogrify:\n    [!path!]: ../transmogrify\n```\n\n## Common fixes\n\nIf you want to publish the package to `pub.dev`, then change\nthe dependency to a hosted package that is published on `pub.dev`.\n\nIf the package isn't intended to be published on `pub.dev`, then\nadd a `publish_to: none` entry to its `pubspec.yaml` file to\nmark it as not intended to be published:\n\n```yaml\nname: example\npublish_to: none\ndependencies:\n  transmogrify:\n    path: ../transmogrify\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_deprecated_extend_annotation",
    "description": "_The annotation '@Deprecated.extend' can only be applied to extendable classes._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the `@Deprecated.extend`\nannotation is applied to a declaration that isn't an extendable class. An\nextendable class is one that isn't declared with the `interface`,\n`final`, or `sealed` keywords and has at least one public, generative\nconstructor.\n\n## Example\n\nThe following code produces this diagnostic because the annotation is on a\nsealed class:\n\n```dart\n@[!Deprecated.extend!]()\nsealed class C {}\n```\n\n## Common fixes\n\nRemove the annotation:\n\n```dart\nsealed class C {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_deprecated_implement_annotation",
    "description": "_The annotation '@Deprecated.implement' can only be applied to implementable classes._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the `@Deprecated.implement`\nannotation is applied to a declaration that isn't an implementable class\nor mixin. An implementable class or mixin is one that isn't declared with\nthe base, final, or sealed keywords.\n\n## Example\n\nThe following code produces this diagnostic because the annotation is on a\nsealed class:\n\n```dart\n@[!Deprecated.implement!]()\nsealed class C {}\n```\n\n## Common fixes\n\nRemove the annotation:\n\n```dart\nsealed class C {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_deprecated_instantiate_annotation",
    "description": "_The annotation '@Deprecated.instantiate' can only be applied to classes._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the `@Deprecated.instantiate`\nannotation is applied to a declaration that isn't an instantiable class.\nAn instantiable class is one that isn't declared with the `abstract` or\n`sealed` keywords and has at least one public, generative constructor.\n\n## Example\n\nThe following code produces this diagnostic because the annotation is on a\nsealed class:\n\n```dart\n@[!Deprecated.instantiate!]()\nsealed class C {}\n```\n\n## Common fixes\n\nRemove the annotation:\n\n```dart\nsealed class C {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_deprecated_mixin_annotation",
    "description": "_The annotation '@Deprecated.mixin' can only be applied to classes._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the `@Deprecated.mixin`\nannotation is applied to a declaration that isn't a mixin class.\n\n## Example\n\nThe following code produces this diagnostic because the annotation is on a\nnon-mixin class:\n\n```dart\n@[!Deprecated.mixin!]()\nclass C {}\n```\n\n## Common fixes\n\nRemove the annotation:\n\n```dart\nclass C {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_deprecated_optional_annotation",
    "description": "_The annotation '@Deprecated.optional' can only be applied to optional parameters._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the `@Deprecated.optional`\nannotation is applied to a parameter that isn't an optional parameter. The\nannotation must not be used on a parameter in a local function, an\nanonymous function, a function-typed parameter, or a typedef. It is only\nvalid on optional parameters in a top-level function, a method, or a\nconstructor.\n\n## Example\n\nThe following code produces this diagnostic because the annotation is on a\nrequired parameter:\n\n```dart\nvoid f(@[!Deprecated.optional!]() int p) {}\n```\n\n## Common fixes\n\nRemove the annotation:\n\n```dart\nvoid f(int p) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_deprecated_subclass_annotation",
    "description": "_The annotation '@Deprecated.subclass' can only be applied to subclassable classes and mixins._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when anything other than a\nsubclassable class or mixin is annotated with\n`@Deprecated.subclass`. A subclassable\nclass is a class not declared with the `final` or `sealed` keywords. A\nsubclassable mixin is a mixin not declared with the `base` keyword.\n\n## Example\n\nThe following code produces this diagnostic because the annotation is on a\nsealed class:\n\n```dart\n@[!Deprecated.subclass!]()\nsealed class C {}\n```\n\n## Common fixes\n\nRemove the annotation:\n\n```dart\nsealed class C {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_exception_value",
    "description": "_The method {0} can't have an exceptional return value (the second argument) when the return type of the function is either 'void', 'Handle' or 'Pointer'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an invocation of the method\n`Pointer.fromFunction` or `NativeCallable.isolateLocal`\nhas a second argument (the exceptional return\nvalue) and the type to be returned from the invocation is either `void`,\n`Handle` or `Pointer`.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because a second argument is\nprovided when the return type of `f` is `void`:\n\n```dart\nimport 'dart:ffi';\n\ntypedef T = Void Function(Int8);\n\nvoid f(int i) {}\n\nvoid g() {\n  Pointer.fromFunction<T>(f, [!42!]);\n}\n```\n\n## Common fixes\n\nRemove the exception value:\n\n```dart\nimport 'dart:ffi';\n\ntypedef T = Void Function(Int8);\n\nvoid f(int i) {}\n\nvoid g() {\n  Pointer.fromFunction<T>(f);\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_export_of_internal_element",
    "description": "_The member '{0}' can't be exported as a part of a package's public API._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a [public library][] exports a\ndeclaration that is marked with the [`internal`][meta-internal]\nannotation.\n\n## Example\n\nGiven a file `a.dart` in the `src` directory that contains:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@internal class One {}\n```\n\nThe following code, when found in a [public library][] produces this\ndiagnostic because the `export` directive is exporting a name that is only\nintended to be used internally:\n\n```dart\n[!export 'src/a.dart';!]\n```\n\n## Common fixes\n\nIf the export is needed, then add a `hide` clause to hide the internal\nnames:\n\n```dart\nexport 'src/a.dart' hide One;\n```\n\nIf the export isn't needed, then remove it.\n\n[meta-internal]: https://pub.dev/documentation/meta/latest/meta/internal-constant.html\n[public library]: /resources/glossary#public-library\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_export_of_internal_element_indirectly",
    "description": "_The member '{0}' can't be exported as a part of a package's public API, but is indirectly exported as part of the signature of '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a [public library][] exports a\ntop-level function  with a return type or at least one parameter type that\nis marked with the [`internal`][meta-internal] annotation.\n\n## Example\n\nGiven a file `a.dart` in the `src` directory that contains the\nfollowing:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@internal\ntypedef IntFunction = int Function();\n\nint f(IntFunction g) => g();\n```\n\nThe following code produces this diagnostic because the function `f` has a\nparameter of type `IntFunction`, and `IntFunction` is only intended to be\nused internally:\n\n```dart\n[!export 'src/a.dart' show f;!]\n```\n\n## Common fixes\n\nIf the function must be public, then make all the types in the function's\nsignature public types.\n\nIf the function doesn't need to be exported, then stop exporting it,\neither by removing it from the `show` clause, adding it to the `hide`\nclause, or by removing the export.\n\n[meta-internal]: https://pub.dev/documentation/meta/latest/meta/internal-constant.html\n[public library]: /resources/glossary#public-library\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_extension_argument_count",
    "description": "_Extension overrides must have exactly one argument: the value of 'this' in the extension method._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an extension override doesn't\nhave exactly one argument. The argument is the expression used to compute\nthe value of `this` within the extension method, so there must be one\nargument.\n\n## Examples\n\nThe following code produces this diagnostic because there are no arguments:\n\n```dart\nextension E on String {\n  String join(String other) => '$this $other';\n}\n\nvoid f() {\n  E[!()!].join('b');\n}\n```\n\nAnd, the following code produces this diagnostic because there's more than\none argument:\n\n```dart\nextension E on String {\n  String join(String other) => '$this $other';\n}\n\nvoid f() {\n  E[!('a', 'b')!].join('c');\n}\n```\n\n## Common fixes\n\nProvide one argument for the extension override:\n\n```dart\nextension E on String {\n  String join(String other) => '$this $other';\n}\n\nvoid f() {\n  E('a').join('b');\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_factory_method_decl",
    "description": "_Factory method '{0}' must have a return type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a method that is annotated with\nthe [`factory`][meta-factory] annotation has a return type of `void`.\n\n## Example\n\nThe following code produces this diagnostic because the method `createC`\nis annotated with the [`factory`][meta-factory] annotation but doesn't\nreturn any value:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass Factory {\n  @factory\n  void [!createC!]() {}\n}\n\nclass C {}\n```\n\n## Common fixes\n\nChange the return type to something other than `void`:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass Factory {\n  @factory\n  C createC() => C();\n}\n\nclass C {}\n```\n\n[meta-factory]: https://pub.dev/documentation/meta/latest/meta/factory-constant.html\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_factory_method_impl",
    "description": "_Factory method '{0}' doesn't return a newly allocated object._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a method that is annotated with\nthe [`factory`][meta-factory] annotation doesn't return a newly allocated\nobject.\n\n## Example\n\nThe following code produces this diagnostic because the method `createC`\nreturns the value of a field rather than a newly created instance of `C`:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass Factory {\n  C c = C();\n\n  @factory\n  C [!createC!]() => c;\n}\n\nclass C {}\n```\n\n## Common fixes\n\nChange the method to return a newly created instance of the return type:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass Factory {\n  @factory\n  C createC() => C();\n}\n\nclass C {}\n```\n\n[meta-factory]: https://pub.dev/documentation/meta/latest/meta/factory-constant.html\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_factory_name_not_a_class",
    "description": "_The name of a factory constructor must be the same as the name of the immediately enclosing class._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the name of a factory\nconstructor isn't the same as the name of the surrounding class.\n\n## Example\n\nThe following code produces this diagnostic because the name of the factory\nconstructor (`A`) isn't the same as the surrounding class (`C`):\n\n```dart\n// @dart = 3.10\nclass A {}\n\nclass C {\n  factory [!A!]() => throw 0;\n}\n```\n\n## Common fixes\n\nIf the factory returns an instance of the surrounding class, and you\nintend it to be an unnamed factory constructor, then rename the factory:\n\n```dart\nclass A {}\n\nclass C {\n  factory C() => throw 0;\n}\n```\n\nIf the factory returns an instance of the surrounding class, and you\nintend it to be a named factory constructor, then prefix the name of the\nfactory constructor with the name of the surrounding class:\n\n```dart\nclass A {}\n\nclass C {\n  factory C.a() => throw 0;\n}\n```\n\nIf the factory returns an instance of a different class, then move the\nfactory to that class:\n\n```dart\nclass A {\n  factory A() => throw 0;\n}\n\nclass C {}\n```\n\nIf the factory returns an instance of a different class, but you can't\nmodify that class or don't want to move the factory, then convert it to be\na static method:\n\n```dart\nclass A {}\n\nclass C {\n  static A a() => throw 0;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_field_name",
    "description": "_Record field names can't be a dollar sign followed by an integer when the integer is the index of a positional field._\n\n_Record field names can't be private._\n\n_Record field names can't be the same as a member from 'Object'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when either a record literal or a\nrecord type annotation has a field whose name is invalid. The name is\ninvalid if it is:\n- private (starts with `_`)\n- the same as one of the members defined on `Object`\n- the same as the name of a positional field (an exception is made if the\n  field is a positional field with the specified name)\n\n## Examples\n\nThe following code produces this diagnostic because the record literal has\na field named `toString`, which is a method defined on `Object`:\n\n```dart\nvar r = (a: 1, [!toString!]: 4);\n```\n\nThe following code produces this diagnostic because the record type\nannotation has a field named `hashCode`, which is a getter defined on\n`Object`:\n\n```dart\nvoid f(({int a, int [!hashCode!]}) r) {}\n```\n\nThe following code produces this diagnostic because the record literal has\na private field named `_a`:\n\n```dart\nvar r = ([!_a!]: 1, b: 2);\n```\n\nThe following code produces this diagnostic because the record type\nannotation has a private field named `_a`:\n\n```dart\nvoid f(({int [!_a!], int b}) r) {}\n```\n\nThe following code produces this diagnostic because the record literal has\na field named `$1`, which is also the name of a different positional\nparameter:\n\n```dart\nvar r = (2, [!$1!]: 1);\n```\n\nThe following code produces this diagnostic because the record type\nannotation has a field named `$1`, which is also the name of a different\npositional parameter:\n\n```dart\nvoid f((int, String, {int [!$1!]}) r) {}\n```\n\n## Common fixes\n\nRename the field:\n\n```dart\nvar r = (a: 1, d: 4);\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_field_type_in_struct",
    "description": "_Fields in struct classes can't have the type '{0}'. They can only be declared as 'int', 'double', 'Array', 'Pointer', or subtype of 'Struct' or 'Union'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a field in a subclass of\n`Struct` has a type other than `int`, `double`, `Array`, `Pointer`, or\nsubtype of `Struct` or `Union`.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the field `str` has\nthe type `String`, which isn't one of the allowed types for fields in a\nsubclass of `Struct`:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  external [!String!] s;\n\n  @Int32()\n  external int i;\n}\n```\n\n## Common fixes\n\nUse one of the allowed types for the field:\n\n```dart\nimport 'dart:ffi';\nimport 'package:ffi/ffi.dart';\n\nfinal class C extends Struct {\n  external Pointer<Utf8> s;\n\n  @Int32()\n  external int i;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_generic_function_type",
    "description": "_Invalid generic function type._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_hex_escape",
    "description": "_An escape sequence starting with '\\x' must be followed by 2 hexadecimal digits._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_implementation_override",
    "description": "_'{0}.{1}' ('{2}') isn't a valid concrete implementation of '{3}.{1}' ('{4}')._\n\n_The setter '{0}.{1}' ('{2}') isn't a valid concrete implementation of '{3}.{1}' ('{4}')._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when all of the following are true:\n\n- A class defines an abstract member.\n- There is a concrete implementation of that member in a superclass.\n- The concrete implementation isn't a valid implementation of the abstract\n  method.\n\nThe concrete implementation can be invalid because of incompatibilities in\neither the return type, the types of the method's parameters, or the type\nparameters.\n\n## Example\n\nThe following code produces this diagnostic because the method `A.add` has\na parameter of type `int`, and the overriding method `B.add` has a\ncorresponding parameter of type `num`:\n\n```dart\nclass A {\n  int add(int a) => a;\n}\nclass [!B!] extends A {\n  int add(num a);\n}\n```\n\nThis is a problem because in an invocation of `B.add` like the following:\n\n```dart\nvoid f(B b) {\n  b.add(3.4);\n}\n```\n\n`B.add` is expecting to be able to take, for example, a `double`, but when\nthe method `A.add` is executed (because it's the only concrete\nimplementation of `add`), a runtime exception will be thrown because a\n`double` can't be assigned to a parameter of type `int`.\n\n## Common fixes\n\nIf the method in the subclass can conform to the implementation in the\nsuperclass, then change the declaration in the subclass (or remove it if\nit's the same):\n\n```dart\nclass A {\n  int add(int a) => a;\n}\nclass B\textends A {\n  int add(int a);\n}\n```\n\nIf the method in the superclass can be generalized to be a valid\nimplementation of the method in the subclass, then change the superclass\nmethod:\n\n```dart\nclass A {\n  int add(num a) => a.floor();\n}\nclass B\textends A {\n  int add(num a);\n}\n```\n\nIf neither the method in the superclass nor the method in the subclass can\nbe changed, then provide a concrete implementation of the method in the\nsubclass:\n\n```dart\nclass A {\n  int add(int a) => a;\n}\nclass B\textends A {\n  int add(num a) => a.floor();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_initializer",
    "description": "_Not a valid initializer._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_inline_function_type",
    "description": "_Inline function types can't be used for parameters in a generic function type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a generic function type has a\nfunction-valued parameter that is written using the older inline function\ntype syntax.\n\n## Example\n\nThe following code produces this diagnostic because the parameter `f`, in\nthe generic function type used to define `F`, uses the inline function\ntype syntax:\n\n```dart\ntypedef F = int Function(int f[!(!]String s));\n```\n\n## Common fixes\n\nUse the generic function syntax for the parameter's type:\n\n```dart\ntypedef F = int Function(int Function(String));\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_inside_unary_pattern",
    "description": "_This pattern cannot appear inside a unary pattern (cast pattern, null check pattern, or null assert pattern) without parentheses._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_internal_annotation",
    "description": "_Only public elements in a package's private API can be annotated as being internal._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a declaration is annotated with\nthe [`internal`][meta-internal] annotation and that declaration is either\nin a [public library][] or has a private name.\n\n## Example\n\nThe following code, when in a [public library][], produces this diagnostic\nbecause the [`internal`][meta-internal] annotation can't be applied to\ndeclarations in a [public library][]:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@[!internal!]\nclass C {}\n```\n\nThe following code, whether in a public or internal library, produces this\ndiagnostic because the [`internal`][meta-internal] annotation can't be\napplied to declarations with private names:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@[!internal!]\nclass _C {}\n\nvoid f(_C c) {}\n```\n\n## Common fixes\n\nIf the declaration has a private name, then remove the annotation:\n\n```dart\nclass _C {}\n\nvoid f(_C c) {}\n```\n\nIf the declaration has a public name and is intended to be internal to the\npackage, then move the annotated declaration into an internal library (in\nother words, a library inside the `src` directory).\n\nOtherwise, remove the use of the annotation:\n\n```dart\nclass C {}\n```\n\n[meta-internal]: https://pub.dev/documentation/meta/latest/meta/internal-constant.html\n[public library]: /resources/glossary#public-library\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_language_version_override",
    "description": "_The Dart language version override comment can't be followed by any non-whitespace characters._\n\n_The Dart language version override comment must be specified with a version number, like '2.0', after the '=' character._\n\n_The Dart language version override comment must be specified with an '=' character._\n\n_The Dart language version override comment must be specified with exactly two slashes._\n\n_The Dart language version override comment must be specified with the word 'dart' in all lower case._\n\n_The Dart language version override number can't be prefixed with a letter._\n\n_The Dart language version override number must begin with '@dart'._\n\n_The language version override can't specify a version greater than the latest known language version: {0}.{1}._\n\n_The language version override must be specified before any declaration or directive._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a comment that appears to be an\nattempt to specify a language version override doesn't conform to the\nrequirements for such a comment. For more information, see\n[Per-library language version selection](https://dart.dev/resources/language/evolution#per-library-language-version-selection).\n\n## Example\n\nThe following code produces this diagnostic because the word `dart` must\nbe lowercase in such a comment and because there's no equal sign between\nthe word `dart` and the version number:\n\n```dart\n[!// @Dart 2.13!]\n```\n\n## Common fixes\n\nIf the comment is intended to be a language version override, then change\nthe comment to follow the correct format:\n\n```dart\n// @dart = 2.13\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_literal_annotation",
    "description": "_Only const constructors can have the `@literal` annotation._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the [`literal`][meta-literal]\nannotation is applied to anything other than a const constructor.\n\n## Examples\n\nThe following code produces this diagnostic because the constructor isn't\na `const` constructor:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass C {\n  @[!literal!]\n  C();\n}\n```\n\nThe following code produces this diagnostic because `x` isn't a\nconstructor:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@[!literal!]\nvar x;\n```\n\n## Common fixes\n\nIf the annotation is on a constructor and the constructor should always be\ninvoked with `const`, when possible, then mark the constructor with the\n`const` keyword:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass C {\n  @literal\n  const C();\n}\n```\n\nIf the constructor can't be marked as `const`, then remove the annotation.\n\nIf the annotation is on anything other than a constructor, then remove the\nannotation:\n\n```dart\nvar x;\n```\n\n[meta-literal]: https://pub.dev/documentation/meta/latest/meta/literal-constant.html\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_literal_in_configuration",
    "description": "_The literal in a configuration can't contain interpolation._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_modifier_on_constructor",
    "description": "_The modifier '{0}' can't be applied to the body of a constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the body of a constructor is\nprefixed by one of the following modifiers: `async`, `async*`, or `sync*`.\nConstructor bodies must be synchronous.\n\n## Example\n\nThe following code produces this diagnostic because the body of the\nconstructor for `C` is marked as being `async`:\n\n```dart\nclass C {\n  C() [!async!] {}\n}\n```\n\n## Common fixes\n\nIf the constructor can be synchronous, then remove the modifier:\n\n```dart\nclass C {\n  C();\n}\n```\n\nIf the constructor can't be synchronous, then use a static method to create\nthe instance instead:\n\n```dart\nclass C {\n  C();\n  static Future<C> c() async {\n    return C();\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_modifier_on_setter",
    "description": "_Setters can't use 'async', 'async*', or 'sync*'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the body of a setter is prefixed\nby one of the following modifiers: `async`, `async*`, or `sync*`. Setter\nbodies must be synchronous.\n\n## Example\n\nThe following code produces this diagnostic because the body of the setter\n`x` is marked as being `async`:\n\n```dart\nclass C {\n  set x(int i) [!async!] {}\n}\n```\n\n## Common fixes\n\nIf the setter can be synchronous, then remove the modifier:\n\n```dart\nclass C {\n  set x(int i) {}\n}\n```\n\nIf the setter can't be synchronous, then use a method to set the value\ninstead:\n\n```dart\nclass C {\n  void x(int i) async {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_non_virtual_annotation",
    "description": "_The annotation '@nonVirtual' can only be applied to a concrete instance member._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the `nonVirtual` annotation is\nfound on a declaration other than a member of a class, mixin, or enum, or\nif the member isn't a concrete instance member.\n\n## Examples\n\nThe following code produces this diagnostic because the annotation is on a\nclass declaration rather than a member inside the class:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@[!nonVirtual!]\nclass C {}\n```\n\nThe following code produces this diagnostic because the method `m` is an\nabstract method:\n\n```dart\nimport 'package:meta/meta.dart';\n\nabstract class C {\n  @[!nonVirtual!]\n  void m();\n}\n```\n\nThe following code produces this diagnostic because the method `m` is a\nstatic method:\n\n```dart\nimport 'package:meta/meta.dart';\n\nabstract class C {\n  @[!nonVirtual!]\n  static void m() {}\n}\n```\n\n## Common fixes\n\nIf the declaration isn't a member of a class, mixin, or enum, then remove\nthe annotation:\n\n```dart\nclass C {}\n```\n\nIf the member is intended to be a concrete instance member, then make it\nso:\n\n```dart\nimport 'package:meta/meta.dart';\n\nabstract class C {\n  @nonVirtual\n  void m() {}\n}\n```\n\nIf the member is not intended to be a concrete instance member, then\nremove the annotation:\n\n```dart\nabstract class C {\n  static void m() {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_null_aware_operator",
    "description": "_The element can't be null, so the null-aware operator '?' is unnecessary._\n\n_The map entry key can't be null, so the null-aware operator '?' is unnecessary._\n\n_The map entry value can't be null, so the null-aware operator '?' is unnecessary._\n\n_The receiver can't be 'null' because of short-circuiting, so the null-aware operator '{0}' can't be used._\n\n_The receiver can't be null, so the null-aware operator '{0}' is unnecessary._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a null-aware operator (`?.`,\n`?..`, `?[`, `?..[`, or `...?`) is used on a receiver that's known to be\nnon-nullable.\n\n## Examples\n\nThe following code produces this diagnostic because `s` can't be `null`:\n\n```dart\nint? getLength(String s) {\n  return s[!?.!]length;\n}\n```\n\nThe following code produces this diagnostic because `a` can't be `null`:\n\n```dart\nvar a = [];\nvar b = [[!...?!]a];\n```\n\nThe following code produces this diagnostic because `s?.length` can't\nreturn `null`:\n\n```dart\nvoid f(String? s) {\n  s?.length[!?.!]isEven;\n}\n```\n\nThe reason `s?.length` can't return `null` is because the null-aware\noperator following `s` short-circuits the evaluation of both `length` and\n`isEven` if `s` is `null`. In other words, if `s` is `null`, then neither\n`length` nor `isEven` will be invoked, and if `s` is non-`null`, then\n`length` can't return a `null` value. Either way, `isEven` can't be invoked\non a `null` value, so the null-aware operator isn't necessary. See\n[Understanding null safety](/null-safety/understanding-null-safety#smarter-null-aware-methods)\nfor more details.\n\nThe following code produces this diagnostic because `s` can't be `null`.\n\n```dart\nvoid f(Object? o) {\n  var s = o as String;\n  s[!?.!]length;\n}\n```\n\nThe reason `s` can't be null, despite the fact that `o` can be `null`, is\nbecause of the cast to `String`, which is a non-nullable type. If `o` ever\nhas the value `null`, the cast will fail and the invocation of `length`\nwill not happen.\n\nThe following code produces this diagnostic because `s` can't be `null`:\n\n```dart\nList<String> makeSingletonList(String s) {\n  return <String>[[!?!]s];\n}\n```\n\n## Common fixes\n\nReplace the null-aware operator with a non-null-aware equivalent; for\nexample, change `?.` to  `.`:\n\n```dart\nint getLength(String s) {\n  return s.length;\n}\n```\n\n(Note that the return type was also changed to be non-nullable, which might\nnot be appropriate in some cases.)\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_operator",
    "description": "_The string '{0}' isn't a user-definable operator._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_operator_for_super",
    "description": "_The operator '{0}' can't be used with 'super'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_operator_questionmark_period_for_super",
    "description": "_The operator '?.' cannot be used with 'super' because 'super' cannot be null._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_option",
    "description": "_Invalid option specified for '{0}': {1}_",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an option is specified and the\nvalue of the option is invalid.\n\n## Example\n\nThe following code produces this diagnostic because `fail` isn't a valid\nseverity for a diagnostic:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nanalyzer:\n  errors:\n    dead_code: [!fail!]\n    prefer_single_quotes: warning\n```\n\n## Common fixes\n\nIf you specify the option, provide a valid value for it:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nanalyzer:\n  errors:\n    dead_code: error\n    prefer_single_quotes: warning\n```\n\nIf you don't need the option, remove it:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nanalyzer:\n  errors:\n    prefer_single_quotes: warning\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_override",
    "description": "_'{0}.{1}' ('{2}') isn't a valid override of '{3}.{1}' ('{4}')._\n\n_The setter '{0}.{1}' ('{2}') isn't a valid override of '{3}.{1}' ('{4}')._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a member of a class is found\nthat overrides a member from a supertype and the override isn't valid. An\noverride is valid if all of these are true:\n- It allows all of the arguments allowed by the overridden member.\n- It doesn't require any arguments that aren't required by the overridden\n  member.\n- The type of every parameter of the overridden member is assignable to the\n  corresponding parameter of the override.\n- The return type of the override is assignable to the return type of the\n  overridden member.\n\n## Example\n\nThe following code produces this diagnostic because the type of the\nparameter `s` (`String`) isn't assignable to the type of the parameter `i`\n(`int`):\n\n```dart\nclass A {\n  void m(int i) {}\n}\n\nclass B extends A {\n  void [!m!](String s) {}\n}\n```\n\n## Common fixes\n\nIf the invalid method is intended to override the method from the\nsuperclass, then change it to conform:\n\n```dart\nclass A {\n  void m(int i) {}\n}\n\nclass B extends A {\n  void m(int i) {}\n}\n```\n\nIf it isn't intended to override the method from the superclass, then\nrename it:\n\n```dart\nclass A {\n  void m(int i) {}\n}\n\nclass B extends A {\n  void m2(String s) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_override_of_non_virtual_member",
    "description": "_The member '{0}' is declared non-virtual in '{1}' and can't be overridden in subclasses._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a member of a class, mixin, or\nenum overrides a member that has the `@nonVirtual` annotation on it.\n\n## Example\n\nThe following code produces this diagnostic because the method `m` in `B`\noverrides the method `m` in `A`, and the method `m` in `A` is annotated\nwith the `@nonVirtual` annotation:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass A {\n  @nonVirtual\n  void m() {}\n}\n\nclass B extends A {\n  @override\n  void [!m!]() {}\n}\n```\n\n## Common fixes\n\nIf the annotation on the method in the superclass is correct (the method\nin the superclass is not intended to be overridden), then remove or rename\nthe overriding method:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass A {\n  @nonVirtual\n  void m() {}\n}\n\nclass B extends A {}\n```\n\nIf the method in the superclass is intended to be overridden, then remove\nthe `@nonVirtual` annotation:\n\n```dart\nclass A {\n  void m() {}\n}\n\nclass B extends A {\n  @override\n  void m() {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_pattern_variable_in_shared_case_scope",
    "description": "_The variable '{0}' doesn't have the same type and/or finality in all cases that share this body._\n\n_The variable '{0}' is available in some, but not all cases that share this body._\n\n_The variable '{0}' is not available because there is a label or 'default' case._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when multiple case clauses in a\nswitch statement share a body, and at least one of them declares a\nvariable that is referenced in the shared statements, but the variable is\neither not declared in all of the case clauses or it is declared in\ninconsistent ways.\n\nIf the variable isn't declared in all of the case clauses, then it won't\nhave a value if one of the clauses that doesn't declare the variable is\nthe one that matches and executes the body. This includes the situation\nwhere one of the case clauses is the `default` clause.\n\nIf the variable is declared in inconsistent ways, either being `final` in\nsome cases and not `final` in others or having a different type in\ndifferent cases, then the semantics of what the type or finality of the\nvariable should be are not defined.\n\n## Examples\n\nThe following code produces this diagnostic because the variable `a` is\nonly declared in one of the case clauses, and won't have a value if the\nsecond clause is the one that matched `x`:\n\n```dart\nvoid f(Object? x) {\n  switch (x) {\n    case int a when a > 0:\n    case 0:\n      [!a!];\n  }\n}\n```\n\nThe following code produces this diagnostic because the variable `a` isn't\ndeclared in the `default` clause, and won't have a value if the body is\nexecuted because none of the other clauses matched `x`:\n\n```dart\nvoid f(Object? x) {\n  switch (x) {\n    case int a when a > 0:\n    default:\n      [!a!];\n  }\n}\n```\n\nThe following code produces this diagnostic because the variable `a` won't\nhave a value if the body is executed because a different group of cases\ncaused control to continue at the label:\n\n```dart\nvoid f(Object? x) {\n  switch (x) {\n    someLabel:\n    case int a when a > 0:\n      [!a!];\n    case int b when b < 0:\n      continue someLabel;\n  }\n}\n```\n\nThe following code produces this diagnostic because the variable `a`,\nwhile being assigned in all of the case clauses, doesn't have then same\ntype associated with it in every clause:\n\n```dart\nvoid f(Object? x) {\n  switch (x) {\n    case int a when a < 0:\n    case num a when a > 0:\n      [!a!];\n  }\n}\n```\n\nThe following code produces this diagnostic because the variable `a` is\n`final` in the first case clause and isn't `final` in the second case\nclause:\n\n```dart\nvoid f(Object? x) {\n  switch (x) {\n    case final int a when a < 0:\n    case int a when a > 0:\n      [!a!];\n  }\n}\n```\n\n## Common fixes\n\nIf the variable isn't declared in all of the cases, and you need to\nreference it in the statements, then declare it in the other cases:\n\n```dart\nvoid f(Object? x) {\n  switch (x) {\n    case int a when a > 0:\n    case int a when a == 0:\n      a;\n  }\n}\n```\n\nIf the variable isn't declared in all of the cases, and you don't need to\nreference it in the statements, then remove the references to it and\nremove the declarations from the other cases:\n\n```dart\nvoid f(int x) {\n  switch (x) {\n    case > 0:\n    case 0:\n  }\n}\n```\n\nIf the type of the variable is different, decide the type the variable\nshould have and make the cases consistent:\n\n```dart\nvoid f(Object? x) {\n  switch (x) {\n    case num a when a < 0:\n    case num a when a > 0:\n      a;\n  }\n}\n```\n\nIf the finality of the variable is different, decide whether it should be\n`final` or not `final` and make the cases consistent:\n\n```dart\nvoid f(Object? x) {\n  switch (x) {\n    case final int a when a < 0:\n    case final int a when a > 0:\n      a;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_platforms_field",
    "description": "_The 'platforms' field must be a map with platforms as keys._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a top-level `platforms`\nfield is specified, but its value is not a map with keys.\nTo learn more about specifying your package's supported platforms,\ncheck out the [documentation on platform declarations](https://dart.dev/tools/pub/pubspec#platforms).\n\n## Example\n\nThe following `pubspec.yaml` produces this diagnostic because `platforms`\nshould be a map.\n\n```yaml\nname: example\nplatforms:\n  [!- android!]\n  [!- web!]\n  [!- ios!]\n```\n\n## Common fixes\n\nIf you can rely on automatic platform detection, then omit the\ntop-level `platforms` field.\n\n```yaml\nname: example\n```\n\nIf you need to manually specify the list of supported platforms, then\nwrite the `platforms` field as a map with platform names as keys.\n\n```yaml\nname: example\nplatforms:\n  android:\n  web:\n  ios:\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_reference_to_generative_enum_constructor",
    "description": "_Generative enum constructors can only be used to create an enum constant._\n\n_Generative enum constructors can't be torn off._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a generative constructor\ndefined on an enum is used anywhere other than to create one of the enum\nconstants or as the target of a redirection from another constructor in\nthe same enum.\n\n## Example\n\nThe following code produces this diagnostic because the constructor for\n`E` is being used to create an instance in the function `f`:\n\n```dart\nenum E {\n  a(0);\n\n  const E(int x);\n}\n\nE f() => const [!E!](2);\n```\n\n## Common fixes\n\nIf there's an enum value with the same value, or if you add such a\nconstant, then reference the constant directly:\n\n```dart\nenum E {\n  a(0), b(2);\n\n  const E(int x);\n}\n\nE f() => E.b;\n```\n\nIf you need to use a constructor invocation, then use a factory\nconstructor:\n\n```dart\nenum E {\n  a(0);\n\n  const E(int x);\n\n  factory E.c(int x) => a;\n}\n\nE f() => E.c(2);\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_reference_to_this",
    "description": "_Invalid reference to 'this' expression._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when `this` is used outside of an\ninstance method or a generative constructor. The reserved word `this` is\nonly defined in the context of an instance method, a generative\nconstructor, or the initializer of a late instance field declaration.\n\n## Example\n\nThe following code produces this diagnostic because `v` is a top-level\nvariable:\n\n```dart\nC f() => [!this!];\n\nclass C {}\n```\n\n## Common fixes\n\nUse a variable of the appropriate type in place of `this`, declaring it if\nnecessary:\n\n```dart\nC f(C c) => c;\n\nclass C {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_reopen_annotation",
    "description": "_The annotation '@reopen' can only be applied to a class that opens capabilities that the supertype intentionally disallows._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `@reopen` annotation has been\nplaced on a class or mixin that does not remove restrictions placed on the\nsuperclass.\n\n## Example\n\nThe following code produces this diagnostic because the class `B` is\nannotated with `@reopen` even though it doesn't expand the ability of `A`\nto be subclassed:\n\n```dart\nimport 'package:meta/meta.dart';\n\nsealed class A {}\n\n@[!reopen!]\nclass B extends A {}\n```\n\n## Common fixes\n\nIf the superclass should be restricted in a way that the subclass would\nchange, then modify the superclass to reflect those restrictions:\n\n```dart\nimport 'package:meta/meta.dart';\n\ninterface class A {}\n\n@reopen\nclass B extends A {}\n```\n\nIf the superclass is correct, then remove the annotation:\n\n```dart\nsealed class A {}\n\nclass B extends A {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_return_type_for_catch_error",
    "description": "_A value of type '{0}' can't be returned by the 'onError' handler because it must be assignable to '{1}'._\n\n_The return type '{0}' isn't assignable to '{1}', as required by 'Future.catchError'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an invocation of\n`Future.catchError` has an argument whose return type isn't compatible with\nthe type returned by the instance of `Future`. At runtime, the method\n`catchError` attempts to return the value from the callback as the result\nof the future, which results in another exception being thrown.\n\n## Examples\n\nThe following code produces this diagnostic because `future` is declared to\nreturn an `int` while `callback` is declared to return a `String`, and\n`String` isn't a subtype of `int`:\n\n```dart\nvoid f(Future<int> future, String Function(dynamic, StackTrace) callback) {\n  future.catchError([!callback!]);\n}\n```\n\nThe following code produces this diagnostic because the closure being\npassed to `catchError` returns an `int` while `future` is declared to\nreturn a `String`:\n\n```dart\nvoid f(Future<String> future) {\n  future.catchError((error, stackTrace) => [!3!]);\n}\n```\n\n## Common fixes\n\nIf the instance of `Future` is declared correctly, then change the callback\nto match:\n\n```dart\nvoid f(Future<int> future, int Function(dynamic, StackTrace) callback) {\n  future.catchError(callback);\n}\n```\n\nIf the declaration of the instance of `Future` is wrong, then change it to\nmatch the callback:\n\n```dart\nvoid f(Future<String> future, String Function(dynamic, StackTrace) callback) {\n  future.catchError(callback);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_sealed_annotation",
    "description": "_The annotation '@sealed' can only be applied to classes._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a declaration other than a\nclass declaration has the `@sealed` annotation on it.\n\n## Example\n\nThe following code produces this diagnostic because the `@sealed`\nannotation is on a method declaration:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass A {\n  @[!sealed!]\n  void m() {}\n}\n```\n\n## Common fixes\n\nRemove the annotation:\n\n```dart\nclass A {\n  void m() {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_section_format",
    "description": "_Invalid format for the '{0}' section._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an analysis options file\ncontains a configuration section (key) whose content is not in the\nexpected data structure or format. For example, this occurs when the\nconfiguration requires a map but is provided a list.\n\n## Example\n\nThe following code produces this diagnostic because the `errors` section\nexpects to have a map as its value:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nanalyzer:\n  errors:\n    - dead_code\n```\n\n## Common fixes\n\nChange the value to be of the appropriate format:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nanalyzer:\n  errors:\n    dead_code: error\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_star_after_async",
    "description": "_The modifier 'async*' isn't allowed for an expression function body._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_super_formal_parameter_location",
    "description": "_Super parameters can only be used in non-redirecting generative constructors._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a super parameter is used\nanywhere other than a non-redirecting generative constructor.\n\n## Examples\n\nThe following code produces this diagnostic because the super parameter\n`x` is in a redirecting generative constructor:\n\n```dart\nclass A {\n  A(int x);\n}\n\nclass B extends A {\n  B.b([!super!].x) : this._();\n  B._() : super(0);\n}\n```\n\nThe following code produces this diagnostic because the super parameter\n`x` isn't in a generative constructor:\n\n```dart\nclass A {\n  A(int x);\n}\n\nclass C extends A {\n  factory C.c([!super!].x) => C._();\n  C._() : super(0);\n}\n```\n\nThe following code produces this diagnostic because the super parameter\n`x` is in a method:\n\n```dart\nclass A {\n  A(int x);\n}\n\nclass D extends A {\n  D() : super(0);\n\n  void m([!super!].x) {}\n}\n```\n\n## Common fixes\n\nIf the function containing the super parameter can be changed to be a\nnon-redirecting generative constructor, then do so:\n\n```dart\nclass A {\n  A(int x);\n}\n\nclass B extends A {\n  B.b(super.x);\n}\n```\n\nIf the function containing the super parameter can't be changed to be a\nnon-redirecting generative constructor, then remove the `super`:\n\n```dart\nclass A {\n  A(int x);\n}\n\nclass D extends A {\n  D() : super(0);\n\n  void m(int x) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_super_in_initializer",
    "description": "_Can only use 'super' in an initializer for calling the superclass constructor (e.g. 'super()' or 'super.namedConstructor()')_",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_sync",
    "description": "_The modifier 'sync' isn't allowed for an expression function body._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_this_in_initializer",
    "description": "_Can only use 'this' in an initializer for field initialization (e.g. 'this.x = something') and constructor redirection (e.g. 'this()' or 'this.namedConstructor())_",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_type_argument_in_const_literal",
    "description": "_Constant list literals can't use a type parameter in a type argument, such as '{0}'._\n\n_Constant map literals can't use a type parameter in a type argument, such as '{0}'._\n\n_Constant set literals can't use a type parameter in a type argument, such as '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a type parameter is used in a\ntype argument in a list, map, or set literal that is prefixed by `const`.\nThis isn't allowed because the value of the type parameter (the actual type\nthat will be used at runtime) can't be known at compile time.\n\n## Examples\n\nThe following code produces this diagnostic because the type parameter `T`\nis being used as a type argument when creating a constant list:\n\n```dart\nList<T> newList<T>() => const <[!T!]>[];\n```\n\nThe following code produces this diagnostic because the type parameter `T`\nis being used as a type argument when creating a constant map:\n\n```dart\nMap<String, T> newSet<T>() => const <String, [!T!]>{};\n```\n\nThe following code produces this diagnostic because the type parameter `T`\nis being used as a type argument when creating a constant set:\n\n```dart\nSet<T> newSet<T>() => const <[!T!]>{};\n```\n\n## Common fixes\n\nIf the type that will be used for the type parameter can be known at\ncompile time, then remove the type parameter:\n\n```dart\nList<int> newList() => const <int>[];\n```\n\nIf the type that will be used for the type parameter can't be known until\nruntime, then remove the keyword `const`:\n\n```dart\nList<T> newList<T>() => <T>[];\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_unicode_escape_started",
    "description": "_The string '\\' can't stand alone._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_unicode_escape_u_bracket",
    "description": "_An escape sequence starting with '\\u{' must be followed by 1 to 6 hexadecimal digits followed by a '}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_unicode_escape_u_no_bracket",
    "description": "_An escape sequence starting with '\\u' must be followed by 4 hexadecimal digits._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_unicode_escape_u_started",
    "description": "_An escape sequence starting with '\\u' must be followed by 4 hexadecimal digits or from 1 to 6 digits between '{' and '}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_uri",
    "description": "_Invalid URI syntax: '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a URI in a directive doesn't\nconform to the syntax of a valid URI.\n\n## Example\n\nThe following code produces this diagnostic because `'#'` isn't a valid\nURI:\n\n```dart\nimport [!'#'!];\n```\n\n## Common fixes\n\nReplace the invalid URI with a valid URI.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_use_of_covariant",
    "description": "_The 'covariant' keyword can only be used for parameters in instance methods or before non-final instance fields._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_use_of_covariant_in_extension",
    "description": "_Can't have modifier '{0}' in an extension._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a member declared inside an\nextension uses the keyword `covariant` in the declaration of a parameter.\nExtensions aren't classes and don't have subclasses, so the keyword serves\nno purpose.\n\n## Example\n\nThe following code produces this diagnostic because `i` is marked as being\ncovariant:\n\n```dart\nextension E on String {\n  void a([!covariant!] int i) {}\n}\n```\n\n## Common fixes\n\nRemove the `covariant` keyword:\n\n```dart\nextension E on String {\n  void a(int i) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_use_of_do_not_submit_member",
    "description": "_Uses of '{0}' should not be submitted to source control._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a member that is annotated with\n[`@doNotSubmit`][meta-doNotSubmit] is referenced outside of a member\ndeclaration that is also annotated with `@doNotSubmit`.\n\n## Example\n\nGiven a file `a.dart` containing the following declaration:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@doNotSubmit\nvoid emulateCrash() { /* ... */ }\n```\n\nThe following code produces this diagnostic because the declaration is\nbeing referenced outside of a member that is also annotated with\n`@doNotSubmit`:\n\n```dart\nimport 'a.dart';\n\nvoid f() {\n  [!emulateCrash!]();\n}\n```\n\n## Common fixes\n\nMost commonly, when complete with local testing, the reference to the\nmember should be removed.\n\nIf building additional functionality on top of the member, annotate the\nnewly added member with `@doNotSubmit` as well:\n\n```dart\nimport 'package:meta/meta.dart';\n\nimport 'a.dart';\n\n@doNotSubmit\nvoid emulateCrashWithOtherFunctionality() {\n  emulateCrash();\n  // do other things.\n}\n```\n\n[meta-doNotSubmit]: https://pub.dev/documentation/meta/latest/meta/doNotSubmit-constant.html\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_use_of_identifier_augmented",
    "description": "_The identifier 'augmented' can only be used to reference the augmented declaration inside an augmentation._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_use_of_internal_member",
    "description": "_The member '{0}' can only be used within its package._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a reference to a declaration\nthat is annotated with the [`internal`][meta-internal] annotation is found\noutside the package containing the declaration.\n\n## Example\n\nGiven a package `p` that defines a library containing a declaration marked\nwith the [`internal`][meta-internal] annotation:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@internal\nclass C {}\n```\n\nThe following code produces this diagnostic because it's referencing the\nclass `C`, which isn't intended to be used outside the package `p`:\n\n```dart\nimport 'package:p/src/p.dart';\n\nvoid f([!C!] c) {}\n```\n\n## Common fixes\n\nRemove the reference to the internal declaration.\n\n[meta-internal]: https://pub.dev/documentation/meta/latest/meta/internal-constant.html\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_use_of_null_value",
    "description": "_An expression whose value is always 'null' can't be dereferenced._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an expression whose value will\nalways be `null` is dereferenced.\n\n## Example\n\nThe following code produces this diagnostic because `x` will always be\n`null`:\n\n```dart\nint f(Null x) {\n  return x.[!length!];\n}\n```\n\n## Common fixes\n\nIf the value is allowed to be something other than `null`, then change the\ntype of the expression:\n\n```dart\nint f(String? x) {\n  return x!.length;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_use_of_protected_member",
    "description": "_The member '{0}' can only be used within instance members of subclasses of '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a getter, setter, field, or\nmethod that has been annotated with `@protected` is referenced anywhere\nother than in the library in which it is declared or in a subclass of the\nclass in which it is declared.\n\n## Example\n\nGiven a file `a.dart` that contains the following:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass A {\n  @protected\n  void a() {}\n}\n```\n\nThe following code produces this diagnostic because the method `a` is\nbeing invoked in code that isn't in a subclass of `A`:\n\n```dart\nimport 'a.dart';\n\nvoid b(A a) {\n  a.[!a!]();\n}\n```\n\n## Common fixes\n\nIf it's reasonable for the member to be marked as `@protected`, then\nremove the reference to the protected member, replacing it with some\nequivalent code.\n\nIf it isn't reasonable for the member to be marked as `@protected`, and\nyou have the ability to do so, remove the annotation.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_use_of_type_outside_library",
    "description": "_The class '{0}' can't be extended outside of its library because it's a final class._\n\n_The class '{0}' can't be extended outside of its library because it's an interface class._\n\n_The class '{0}' can't be extended, implemented, or mixed in outside of its library because it's a sealed class._\n\n_The class '{0}' can't be implemented outside of its library because it's a base class._\n\n_The class '{0}' can't be implemented outside of its library because it's a final class._\n\n_The class '{0}' can't be used as a mixin superclass constraint outside of its library because it's a final class._\n\n_The mixin '{0}' can't be implemented outside of its library because it's a base mixin._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an `extends`, `implements`,\n`with`, or `on` clause uses a class or mixin in a way that isn't allowed\ngiven the modifiers on that class or mixin's declaration.\n\nThe message specifies how the declaration is being used and why it isn't\nallowed.\n\n## Example\n\nGiven a file `a.dart` that defines a base class `A`:\n\n```dart\nbase class A {}\n```\n\nThe following code produces this diagnostic because the class `B`\nimplements the class `A`, but the `base` modifier prevents `A` from being\nimplemented outside of the library where it's defined:\n\n```dart\nimport 'a.dart';\n\nfinal class B implements [!A!] {}\n```\n\n## Common fixes\n\nUse of this type is restricted outside of its declaring library. If a\ndifferent, unrestricted type is available that can provide similar\nfunctionality, then replace the type:\n\n```dart\nclass B implements C {}\nclass C {}\n```\n\nIf there isn't a different type that would be appropriate, then remove the\ntype, and possibly the whole clause:\n\n```dart\nclass B {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_use_of_visible_for_overriding_member",
    "description": "_The member '{0}' can only be used for overriding._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an instance member that is\nannotated with [`visibleForOverriding`][meta-visibleForOverriding] is\nreferenced outside the library in which it's declared for any reason other\nthan to override it.\n\n## Example\n\nGiven a file `a.dart` containing the following declaration:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass A {\n  @visibleForOverriding\n  void a() {}\n}\n```\n\nThe following code produces this diagnostic because the method `m` is being\ninvoked even though the only reason it's public is to allow it to be\noverridden:\n\n```dart\nimport 'a.dart';\n\nclass B extends A {\n  void b() {\n    [!a!]();\n  }\n}\n```\n\n## Common fixes\n\nRemove the invalid use of the member.\n\n[meta-visibleForOverriding]: https://pub.dev/documentation/meta/latest/meta/visibleForOverriding-constant.html\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_use_of_visible_for_template_member",
    "description": "_The member '{0}' can only be used within '{1}' or a template library._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_use_of_visible_for_testing_member",
    "description": "_The member '{0}' can only be used within '{1}' or a test._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a member annotated with\n`@visibleForTesting` is referenced anywhere other than the library in\nwhich it is declared or in a library in the `test` directory.\n\n## Example\n\nGiven a file `c.dart` that contains the following:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass C {\n  @visibleForTesting\n  void m() {}\n}\n```\n\nThe following code, when not inside the `test` directory, produces this\ndiagnostic because the method `m` is marked as being visible only for\ntests:\n\n```dart\nimport 'c.dart';\n\nvoid f(C c) {\n  c.[!m!]();\n}\n```\n\n## Common fixes\n\nIf the annotated member should not be referenced outside of tests, then\nremove the reference:\n\n```dart\nimport 'c.dart';\n\nvoid f(C c) {}\n```\n\nIf it's OK to reference the annotated member outside of tests, then remove\nthe annotation:\n\n```dart\nclass C {\n  void m() {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_visibility_annotation",
    "description": "_The member '{0}' is annotated with '{1}', but this annotation is only meaningful on declarations of public members._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when either the `visibleForTemplate`\nor [`visibleForTesting`][meta-visibleForTesting] annotation is applied to\na non-public declaration.\n\n## Example\n\nThe following code produces this diagnostic:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@[!visibleForTesting!]\nvoid _someFunction() {}\n\nvoid f() => _someFunction();\n```\n\n## Common fixes\n\nIf the declaration doesn't need to be used by test code, then remove the\nannotation:\n\n```dart\nvoid _someFunction() {}\n\nvoid f() => _someFunction();\n```\n\nIf it does, then make it public:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@visibleForTesting\nvoid someFunction() {}\n\nvoid f() => someFunction();\n```\n\n[meta-visibleForTesting]: https://pub.dev/documentation/meta/latest/meta/visibleForTesting-constant.html\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_visible_for_overriding_annotation",
    "description": "_The annotation 'visibleForOverriding' can only be applied to a public instance member that can be overridden._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when anything other than a public\ninstance member of a class is annotated with\n[`visibleForOverriding`][meta-visibleForOverriding]. Because only public\ninstance members can be overridden outside the defining library, there's\nno value to annotating any other declarations.\n\n## Example\n\nThe following code produces this diagnostic because the annotation is on a\nclass, and classes can't be overridden:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@[!visibleForOverriding!]\nclass C {}\n```\n\n## Common fixes\n\nRemove the annotation:\n\n```dart\nclass C {}\n```\n\n[meta-visibleForOverriding]: https://pub.dev/documentation/meta/latest/meta/visibleForOverriding-constant.html\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_visible_outside_template_annotation",
    "description": "_The annotation 'visibleOutsideTemplate' can only be applied to a member of a class, enum, or mixin that is annotated with 'visibleForTemplate'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the `@visibleOutsideTemplate`\nannotation is used incorrectly. This annotation is only meant to annotate\nmembers of a class, enum, or mixin that has the `@visibleForTemplate`\nannotation, to opt those members out of the visibility restrictions that\n`@visibleForTemplate` imposes.\n\n## Examples\n\nThe following code produces this diagnostic because there is no\n`@visibleForTemplate` annotation at the class level:\n\n```dart\nimport 'package:angular_meta/angular_meta.dart';\n\nclass C {\n  @[!visibleOutsideTemplate!]\n  int m() {\n    return 1;\n  }\n}\n```\n\nThe following code produces this diagnostic because the annotation is on\na class declaration, not a member of a class, enum, or mixin:\n\n```dart\nimport 'package:angular_meta/angular_meta.dart';\n\n@[!visibleOutsideTemplate!]\nclass C {}\n```\n\n## Common fixes\n\nIf the class is only visible so that templates can reference it, then add\nthe `@visibleForTemplate` annotation to the class:\n\n```dart\nimport 'package:angular_meta/angular_meta.dart';\n\n@visibleForTemplate\nclass C {\n  @visibleOutsideTemplate\n  int m() {\n    return 1;\n  }\n}\n```\n\nIf the `@visibleOutsideTemplate` annotation is on anything other than a\nmember of a class, enum, or mixin with the `@visibleForTemplate`\nannotation, remove the annotation:\n\n```dart\nclass C {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_widget_preview_application",
    "description": "_The '@Preview(...)' annotation can only be applied to public, statically accessible constructors and functions._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `@Preview(...)` annotation\nis applied to an invalid widget preview target. Widget previews can only\nbe applied to public, statically accessible, explicitly defined\nconstructors and functions.\n\n## Examples\n\nThe following code produces this diagnostic because `_myPrivatePreview`\nis private:\n\n```dart\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter/widget_previews.dart';\n\n// Invalid application to private top-level function.\n@[!Preview!]()\n// ignore: unused_element\nWidget _myPrivatePreview() => Text('Foo');\n```\n\nThe following code produces this diagnostic because `myExternalPreview`\nis `external`:\n\n```dart\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter/widget_previews.dart';\n\n\n// Invalid application to an external function.\n@[!Preview!]()\nexternal Widget myExternalPreview();\n```\n\nThe following code produces this diagnostic because `PublicWidget._()` is\nprivate:\n\n```dart\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter/widget_previews.dart';\n\nclass PublicWidget extends StatelessWidget {\n  // Invalid application to a private constructor.\n  @[!Preview!]()\n  PublicWidget._();\n\n  @override\n  Widget build(BuildContext) => Text('Foo');\n}\n```\n\nThe following code produces this diagnostic because `instancePreview` is\nan instance method:\n\n```dart\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter/widget_previews.dart';\n\nclass PublicWidget extends StatelessWidget {\n  // Invalid application to a instance member.\n  @[!Preview!]()\n  Widget instancePreview() => PublicWidget();\n\n  @override\n  Widget build(BuildContext context) => Text('Foo');\n}\n```\n\nThe following code produces this diagnostic because `_PrivateWidget` is\nprivate:\n\n```dart\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter/widget_previews.dart';\n\n// ignore: unused_element\nclass _PrivateWidget extends StatelessWidget {\n  // Invalid application to a constructor of a private class.\n  @[!Preview!]()\n  _PrivateWidget();\n\n  @override\n  Widget build(BuildContext context) => Text('Foo');\n}\n```\n\nThe following code produces this diagnostic because `_PrivateWidget` is\nprivate:\n\n```dart\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter/widget_previews.dart';\n\n// ignore: unused_element\nclass _PrivateWidget extends StatelessWidget {\n  // Invalid application to a static method of a private class.\n  @[!Preview!]()\n  Widget privateStatic() => _PrivateWidget();\n\n  @override\n  Widget build(BuildContext context) => Text('Foo');\n}\n```\n\nThe following code produces this diagnostic because `AbstractWidget` is\nan `abstract` class:\n\n```dart\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter/widget_previews.dart';\n\nabstract class AbstractWidget extends StatelessWidget {\n  // Invalid application to a constructor of an abstract class.\n  @[!Preview!]()\n  AbstractWidget();\n\n  @override\n  Widget build(BuildContext context) => Text('Foo');\n}\n```\n\n## Common fixes\n\nCreate a dedicated public, statically accessible, and explicitly defined\nconstructor, top-level function, or class member for use as a preview:\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_widget_preview_private_argument",
    "description": "_'@Preview(...)' can only accept arguments that consist of literals and public symbols._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the `Preview` constructor is\ninvoked with arguments that contain references to private symbols.\n\n## Example\n\nThe following code produces this diagnostic because the constant variable\n`_name` is private to the current library:\n\n```dart\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter/widget_previews.dart';\n\nconst String _name = 'My Foo Preview';\n\n@Preview([!name: _name!])\nWidget myPreview() => Text('Foo');\n```\n\n## Common fixes\n\nIf appropriate, the private symbol should be made public:\n\n```dart\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter/widget_previews.dart';\n\nconst String name = 'My Foo Preview';\n\n@Preview(name: name)\nWidget myPreview() => Text('Foo');\n```\n\nOtherwise, a different public constant symbol should be used:\n\n```dart\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter/widget_previews.dart';\n\n@Preview(name: 'My Foo Preview')\nWidget myPreview() => Text('Foo');\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invocation_of_extension_without_call",
    "description": "_The extension '{0}' doesn't define a 'call' method so the override can't be used in an invocation._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an extension override is used to\ninvoke a function but the extension doesn't declare a `call` method.\n\n## Example\n\nThe following code produces this diagnostic because the extension `E`\ndoesn't define a `call` method:\n\n```dart\nextension E on String {}\n\nvoid f() {\n  [!E('')!]();\n}\n```\n\n## Common fixes\n\nIf the extension is intended to define a `call` method, then declare it:\n\n```dart\nextension E on String {\n  int call() => 0;\n}\n\nvoid f() {\n  E('')();\n}\n```\n\nIf the extended type defines a `call` method, then remove the extension\noverride.\n\nIf the `call` method isn't defined, then rewrite the code so that it\ndoesn't invoke the `call` method.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invocation_of_non_function",
    "description": "_'{0}' isn't a function._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it finds a function invocation,\nbut the name of the function being invoked is defined to be something other\nthan a function.\n\n## Example\n\nThe following code produces this diagnostic because `Binary` is the name of\na function type, not a function:\n\n```dart\ntypedef Binary = int Function(int, int);\n\nint f() {\n  return [!Binary!](1, 2);\n}\n```\n\n## Common fixes\n\nReplace the name with the name of a function.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invocation_of_non_function_expression",
    "description": "_The expression doesn't evaluate to a function, so it can't be invoked._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a function invocation is found,\nbut the name being referenced isn't the name of a function, or when the\nexpression computing the function doesn't compute a function.\n\n## Examples\n\nThe following code produces this diagnostic because `x` isn't a function:\n\n```dart\nint x = 0;\n\nint f() => x;\n\nvar y = [!x!]();\n```\n\nThe following code produces this diagnostic because `f()` doesn't return a\nfunction:\n\n```dart\nint x = 0;\n\nint f() => x;\n\nvar y = [!f()!]();\n```\n\n## Common fixes\n\nIf you need to invoke a function, then replace the code before the argument\nlist with the name of a function or with an expression that computes a\nfunction:\n\n```dart\nint x = 0;\n\nint f() => x;\n\nvar y = f();\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "label_in_outer_scope",
    "description": "_Can't reference label '{0}' declared in an outer method._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `break` or `continue`\nstatement references a label that is declared in a method or function\ncontaining the function in which the `break` or `continue` statement\nappears. The `break` and `continue` statements can't be used to transfer\ncontrol outside the function that contains them.\n\n## Example\n\nThe following code produces this diagnostic because the label `loop` is\ndeclared outside the local function `g`:\n\n```dart\nvoid f() {\n  loop:\n  while (true) {\n    void g() {\n      break [!loop!];\n    }\n\n    g();\n  }\n}\n```\n\n## Common fixes\n\nTry rewriting the code so that it isn't necessary to transfer control\noutside the local function, possibly by inlining the local function:\n\n```dart\nvoid f() {\n  loop:\n  while (true) {\n    break loop;\n  }\n}\n```\n\nIf that isn't possible, then try rewriting the local function so that a\nvalue returned by the function can be used to determine whether control is\ntransferred:\n\n```dart\nvoid f() {\n  loop:\n  while (true) {\n    bool g() {\n      return true;\n    }\n\n    if (g()) {\n      break loop;\n    }\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "label_undefined",
    "description": "_Can't reference an undefined label '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it finds a reference to a label\nthat isn't defined in the scope of the `break` or `continue` statement that\nis referencing it.\n\n## Example\n\nThe following code produces this diagnostic because the label `loop` isn't\ndefined anywhere:\n\n```dart\nvoid f() {\n  for (int i = 0; i < 10; i++) {\n    for (int j = 0; j < 10; j++) {\n      if (j != 0) {\n        break [!loop!];\n      }\n    }\n  }\n}\n```\n\n## Common fixes\n\nIf the label should be on the innermost enclosing `do`, `for`, `switch`, or\n`while` statement, then remove the label:\n\n```dart\nvoid f() {\n  for (int i = 0; i < 10; i++) {\n    for (int j = 0; j < 10; j++) {\n      if (j != 0) {\n        break;\n      }\n    }\n  }\n}\n```\n\nIf the label should be on some other statement, then add the label:\n\n```dart\nvoid f() {\n  loop: for (int i = 0; i < 10; i++) {\n    for (int j = 0; j < 10; j++) {\n      if (j != 0) {\n        break loop;\n      }\n    }\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "late_final_field_with_const_constructor",
    "description": "_Can't have a late final field in a class with a generative const constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class that has at least one\n`const` constructor also has a field marked both `late` and `final`.\n\n## Example\n\nThe following code produces this diagnostic because the class `A` has a\n`const` constructor and the `final` field `f` is marked as `late`:\n\n```dart\nclass A {\n  [!late!] final int f;\n\n  const A();\n}\n```\n\n## Common fixes\n\nIf the field doesn't need to be marked `late`, then remove the `late`\nmodifier from the field:\n\n```dart\nclass A {\n  final int f = 0;\n\n  const A();\n}\n```\n\nIf the field must be marked `late`, then remove the `const` modifier from\nthe constructors:\n\n```dart\nclass A {\n  late final int f;\n\n  A();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "late_final_local_already_assigned",
    "description": "_The late final local variable is already assigned._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the analyzer can prove that a\nlocal variable marked as both `late` and `final` was already assigned a\nvalue at the point where another assignment occurs.\n\nBecause `final` variables can only be assigned once, subsequent assignments\nare guaranteed to fail, so they're flagged.\n\n## Example\n\nThe following code produces this diagnostic because the `final` variable\n`v` is assigned a value in two places:\n\n```dart\nint f() {\n  late final int v;\n  v = 0;\n  [!v!] += 1;\n  return v;\n}\n```\n\n## Common fixes\n\nIf you need to be able to reassign the variable, then remove the `final`\nkeyword:\n\n```dart\nint f() {\n  late int v;\n  v = 0;\n  v += 1;\n  return v;\n}\n```\n\nIf you don't need to reassign the variable, then remove all except the\nfirst of the assignments:\n\n```dart\nint f() {\n  late final int v;\n  v = 0;\n  return v;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "late_pattern_variable_declaration",
    "description": "_A pattern variable declaration may not use the `late` keyword._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "leaf_call_must_not_return_handle",
    "description": "_FFI leaf call can't return a 'Handle'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the value of the `isLeaf`\nargument in an invocation of either `Pointer.asFunction` or\n`DynamicLibrary.lookupFunction` is `true` and the function that would be\nreturned would have a return type of `Handle`.\n\nThe analyzer also produces this diagnostic when the value of the `isLeaf`\nargument in an `Native` annotation is `true` and the type argument on\nthe annotation is a function type whose return type is `Handle`.\n\nIn all of these cases, leaf calls are only supported for the types `bool`,\n`int`, `float`, `double`, and, as a return type `void`.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the function `p`\nreturns a `Handle`, but the `isLeaf` argument is `true`:\n\n```dart\nimport 'dart:ffi';\n\nvoid f(Pointer<NativeFunction<Handle Function()>> p) {\n  p.[!asFunction!]<Object Function()>(isLeaf: true);\n}\n```\n\n## Common fixes\n\nIf the function returns a handle, then remove the `isLeaf` argument:\n\n```dart\nimport 'dart:ffi';\n\nvoid f(Pointer<NativeFunction<Handle Function()>> p) {\n  p.asFunction<Object Function()>();\n}\n```\n\nIf the function returns one of the supported types, then correct the type\ninformation:\n\n```dart\nimport 'dart:ffi';\n\nvoid f(Pointer<NativeFunction<Int32 Function()>> p) {\n  p.asFunction<int Function()>(isLeaf: true);\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "leaf_call_must_not_take_handle",
    "description": "_FFI leaf call can't take arguments of type 'Handle'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the value of the `isLeaf`\nargument in an invocation of either `Pointer.asFunction` or\n`DynamicLibrary.lookupFunction` is `true` and the function that would be\nreturned would have a parameter of type `Handle`.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the function `p` has a\nparameter of type `Handle`, but the `isLeaf` argument is `true`:\n\n```dart\nimport 'dart:ffi';\n\nvoid f(Pointer<NativeFunction<Void Function(Handle)>> p) {\n  p.[!asFunction!]<void Function(Object)>(isLeaf: true);\n}\n```\n\n## Common fixes\n\nIf the function has at least one parameter of type `Handle`, then remove\nthe `isLeaf` argument:\n\n```dart\nimport 'dart:ffi';\n\nvoid f(Pointer<NativeFunction<Void Function(Handle)>> p) {\n  p.asFunction<void Function(Object)>();\n}\n```\n\nIf none of the function's parameters are `Handle`s, then correct the type\ninformation:\n\n```dart\nimport 'dart:ffi';\n\nvoid f(Pointer<NativeFunction<Void Function(Int8)>> p) {\n  p.asFunction<void Function(int)>(isLeaf: true);\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "library_directive_not_first",
    "description": "_The library directive must appear before all other directives._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "list_element_type_not_assignable",
    "description": "_The element type '{0}' can't be assigned to the list type '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the type of an element in a list\nliteral isn't assignable to the element type of the list.\n\n## Example\n\nThe following code produces this diagnostic because `2.5` is a double, and\nthe list can hold only integers:\n\n```dart\nList<int> x = [1, [!2.5!], 3];\n```\n\n## Common fixes\n\nIf you intended to add a different object to the list, then replace the\nelement with an expression that computes the intended object:\n\n```dart\nList<int> x = [1, 2, 3];\n```\n\nIf the object shouldn't be in the list, then remove the element:\n\n```dart\nList<int> x = [1, 3];\n```\n\nIf the object being computed is correct, then widen the element type of the\nlist to allow all of the different types of objects it needs to contain:\n\n```dart\nList<num> x = [1, 2.5, 3];\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "literal_with_class",
    "description": "_A {0} literal can't be prefixed by '{1}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "literal_with_class_and_new",
    "description": "_A {0} literal can't be prefixed by 'new {1}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "literal_with_new",
    "description": "_A literal can't be prefixed by 'new'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "local_function_declaration_modifier",
    "description": "_Local function declarations can't specify any modifiers._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "main_first_positional_parameter_type",
    "description": "_The type of the first positional parameter of the 'main' function must be a supertype of 'List<String>'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the first positional parameter\nof a function named `main` isn't a supertype of `List<String>`.\n\n## Example\n\nThe following code produces this diagnostic because `List<int>` isn't a\nsupertype of `List<String>`:\n\n```dart\nvoid main([!List<int>!] args) {}\n```\n\n## Common fixes\n\nIf the function is an entry point, then change the type of the first\npositional parameter to be a supertype of `List<String>`:\n\n```dart\nvoid main(List<String> args) {}\n```\n\nIf the function isn't an entry point, then change the name of the function:\n\n```dart\nvoid f(List<int> args) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "main_has_required_named_parameters",
    "description": "_The function 'main' can't have any required named parameters._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a function named `main` has one\nor more required named parameters.\n\n## Example\n\nThe following code produces this diagnostic because the function named\n`main` has a required named parameter (`x`):\n\n```dart\nvoid [!main!]({required int x}) {}\n```\n\n## Common fixes\n\nIf the function is an entry point, then remove the `required` keyword:\n\n```dart\nvoid main({int? x}) {}\n```\n\nIf the function isn't an entry point, then change the name of the function:\n\n```dart\nvoid f({required int x}) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "main_has_too_many_required_positional_parameters",
    "description": "_The function 'main' can't have more than two required positional parameters._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a function named `main` has more\nthan two required positional parameters.\n\n## Example\n\nThe following code produces this diagnostic because the function `main` has\nthree required positional parameters:\n\n```dart\nvoid [!main!](List<String> args, int x, int y) {}\n```\n\n## Common fixes\n\nIf the function is an entry point and the extra parameters aren't used,\nthen remove them:\n\n```dart\nvoid main(List<String> args, int x) {}\n```\n\nIf the function is an entry point, but the extra parameters used are for\nwhen the function isn't being used as an entry point, then make the extra\nparameters optional:\n\n```dart\nvoid main(List<String> args, int x, [int y = 0]) {}\n```\n\nIf the function isn't an entry point, then change the name of the function:\n\n```dart\nvoid f(List<String> args, int x, int y) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "main_is_not_function",
    "description": "_The declaration named 'main' must be a function._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a library contains a declaration\nof the name `main` that isn't the declaration of a top-level function.\n\n## Example\n\nThe following code produces this diagnostic because the name `main` is\nbeing used to declare a top-level variable:\n\n```dart\nvar [!main!] = 3;\n```\n\n## Common fixes\n\nUse a different name for the declaration:\n\n```dart\nvar mainIndex = 3;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "map_entry_not_in_map",
    "description": "_Map entries can only be used in a map literal._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a map entry (a key/value pair)\nis found in a set literal.\n\n## Example\n\nThe following code produces this diagnostic because the literal has a map\nentry even though it's a set literal:\n\n```dart\nvar collection = <String>{[!'a' : 'b'!]};\n```\n\n## Common fixes\n\nIf you intended for the collection to be a map, then change the code so\nthat it is a map. In the previous example, you could do this by adding\nanother type argument:\n\n```dart\nvar collection = <String, String>{'a' : 'b'};\n```\n\nIn other cases, you might need to change the explicit type from `Set` to\n`Map`.\n\nIf you intended for the collection to be a set, then remove the map entry,\npossibly by replacing the colon with a comma if both values should be\nincluded in the set:\n\n```dart\nvar collection = <String>{'a', 'b'};\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "map_key_type_not_assignable",
    "description": "_The element type '{0}' can't be assigned to the map key type '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a key of a key-value pair in a\nmap literal has a type that isn't assignable to the key type of the map.\n\n## Example\n\nThe following code produces this diagnostic because `2` is an `int`, but\nthe keys of the map are required to be `String`s:\n\n```dart\nvar m = <String, String>{[!2!] : 'a'};\n```\n\n## Common fixes\n\nIf the type of the map is correct, then change the key to have the correct\ntype:\n\n```dart\nvar m = <String, String>{'2' : 'a'};\n```\n\nIf the type of the key is correct, then change the key type of the map:\n\n```dart\nvar m = <int, String>{2 : 'a'};\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "map_value_type_not_assignable",
    "description": "_The element type '{0}' can't be assigned to the map value type '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a value of a key-value pair in a\nmap literal has a type that isn't assignable to the value type of the\nmap.\n\n## Example\n\nThe following code produces this diagnostic because `2` is an `int`, but/\nthe values of the map are required to be `String`s:\n\n```dart\nvar m = <String, String>{'a' : [!2!]};\n```\n\n## Common fixes\n\nIf the type of the map is correct, then change the value to have the\ncorrect type:\n\n```dart\nvar m = <String, String>{'a' : '2'};\n```\n\nIf the type of the value is correct, then change the value type of the map:\n\n```dart\nvar m = <String, int>{'a' : 2};\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "member_with_class_name",
    "description": "_A class member can't have the same name as the enclosing class._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "mismatched_annotation_on_struct_field",
    "description": "_The annotation doesn't match the declared type of the field._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the annotation on a field in a\nsubclass of `Struct` or `Union` doesn't match the Dart type of the field.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the annotation\n`Double` doesn't match the Dart type `int`:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  [!@Double()!]\n  external int x;\n}\n```\n\n## Common fixes\n\nIf the type of the field is correct, then change the annotation to match:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Int32()\n  external int x;\n}\n```\n\nIf the annotation is correct, then change the type of the field to match:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Double()\n  external double x;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_annotation_on_struct_field",
    "description": "_Fields of type '{0}' in a subclass of '{1}' must have an annotation indicating the native type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a field in a subclass of\n`Struct` or `Union` whose type requires an annotation doesn't have one.\nThe Dart types `int`, `double`, and `Array` are used to represent multiple\nC types, and the annotation specifies which of the compatible C types the\nfield represents.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the field `x` doesn't\nhave an annotation indicating the underlying width of the integer value:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  external [!int!] x;\n}\n```\n\n## Common fixes\n\nAdd an appropriate annotation to the field:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Int64()\n  external int x;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_assignable_selector",
    "description": "_Missing selector such as '.identifier' or '[0]'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_assignment_in_initializer",
    "description": "_Expected an assignment after the field name._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_catch_or_finally",
    "description": "_A try block must be followed by an 'on', 'catch', or 'finally' clause._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_closing_parenthesis",
    "description": "_The closing parenthesis is missing._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_const_final_var_or_type",
    "description": "_Variables must be declared using the keywords 'const', 'final', 'var' or a type name._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_const_in_list_literal",
    "description": "_Seeing this message constitutes a bug. Please report it._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_const_in_map_literal",
    "description": "_Seeing this message constitutes a bug. Please report it._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_const_in_set_literal",
    "description": "_Seeing this message constitutes a bug. Please report it._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_dart_library",
    "description": "_Required library '{0}' is missing._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when either the Dart or Flutter SDK\nisn't installed correctly, and, as a result, one of the `dart:` libraries\ncan't be found.\n\n## Common fixes\n\nReinstall the Dart or Flutter SDK.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_default_value_for_parameter",
    "description": "_The parameter '{0}' can't have a value of 'null' because of its type, but the implicit default value is 'null'._\n\n_With null safety, use the 'required' keyword, not the '@required' annotation._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an optional parameter, whether\npositional or named, has a [potentially non-nullable][] type and doesn't\nspecify a default value. Optional parameters that have no explicit default\nvalue have an implicit default value of `null`. If the type of the\nparameter doesn't allow the parameter to have a value of `null`, then the\nimplicit default value isn't valid.\n\n## Examples\n\nThe following code produces this diagnostic because `x` can't be `null`,\nand no non-`null` default value is specified:\n\n```dart\nvoid f([int [!x!]]) {}\n```\n\nAs does this:\n\n```dart\nvoid g({int [!x!]}) {}\n```\n\n## Common fixes\n\nIf you want to use `null` to indicate that no value was provided, then you\nneed to make the type nullable:\n\n```dart\nvoid f([int? x]) {}\nvoid g({int? x}) {}\n```\n\nIf the parameter can't be null, then either provide a default value:\n\n```dart\nvoid f([int x = 1]) {}\nvoid g({int x = 2}) {}\n```\n\nor make the parameter a required parameter:\n\n```dart\nvoid f(int x) {}\nvoid g({required int x}) {}\n```\n\n[potentially non-nullable]: /resources/glossary#potentially-non-nullable\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_dependency",
    "description": "_Missing a dependency on imported package '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when there's a package that has been\nimported in the source but is not listed as a dependency of the\nimporting package.\n\n## Example\n\nThe following code produces this diagnostic because the package `path` is\nnot listed as a dependency, while there is an import statement\nwith package `path` in the source code of package `example`:\n\n```yaml\nname: example\ndependencies:\n  meta: ^1.0.2\n```\n\n## Common fixes\n\nAdd the missing package `path` to the `dependencies` field:\n\n```yaml\nname: example\ndependencies:\n  meta: ^1.0.2\n  path: any\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_digit",
    "description": "_Decimal digit expected._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_enum_body",
    "description": "_An enum definition must have a body with at least one constant name._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_enum_constant_in_switch",
    "description": "_Missing case clause for '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `switch` statement for an enum\ndoesn't include an option for one of the values in the enum.\n\nNote that `null` is always a possible value for an enum and therefore also\nmust be handled.\n\n## Example\n\nThe following code produces this diagnostic because the enum value `e2`\nisn't handled:\n\n```dart\nenum E { e1, e2 }\n\nvoid f(E e) {\n  [!switch (e)!] {\n    case E.e1:\n      break;\n  }\n}\n```\n\n## Common fixes\n\nIf there's special handling for the missing values, then add a `case`\nclause for each of the missing values:\n\n```dart\nenum E { e1, e2 }\n\nvoid f(E e) {\n  switch (e) {\n    case E.e1:\n      break;\n    case E.e2:\n      break;\n  }\n}\n```\n\nIf the missing values should be handled the same way, then add a `default`\nclause:\n\n```dart\nenum E { e1, e2 }\n\nvoid f(E e) {\n  switch (e) {\n    case E.e1:\n      break;\n    default:\n      break;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_exception_value",
    "description": "_The method {0} must have an exceptional return value (the second argument) when the return type of the function is neither 'void', 'Handle', nor 'Pointer'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an invocation of the method\n`Pointer.fromFunction` or `NativeCallable.isolateLocal`\ndoesn't have a second argument (the exceptional\nreturn value) when the type to be returned from the invocation is neither\n`void`, `Handle`, nor `Pointer`.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the type returned by\n`f` is expected to be an 8-bit integer but the call to `fromFunction`\ndoesn't include an exceptional return argument:\n\n```dart\nimport 'dart:ffi';\n\nint f(int i) => i * 2;\n\nvoid g() {\n  Pointer.[!fromFunction!]<Int8 Function(Int8)>(f);\n}\n```\n\n## Common fixes\n\nAdd an exceptional return type:\n\n```dart\nimport 'dart:ffi';\n\nint f(int i) => i * 2;\n\nvoid g() {\n  Pointer.fromFunction<Int8 Function(Int8)>(f, 0);\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_expression_in_initializer",
    "description": "_Expected an expression after the assignment operator._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_expression_in_throw",
    "description": "_Missing expression after 'throw'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_field_type_in_struct",
    "description": "_Fields in struct classes must have an explicitly declared type of 'int', 'double' or 'Pointer'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a field in a subclass of\n`Struct` or `Union` doesn't have a type annotation. Every field must have\nan explicit type, and the type must either be `int`, `double`, `Pointer`,\nor a subclass of either `Struct` or `Union`.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the field `str`\ndoesn't have a type annotation:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  external var [!str!];\n\n  @Int32()\n  external int i;\n}\n```\n\n## Common fixes\n\nExplicitly specify the type of the field:\n\n```dart\nimport 'dart:ffi';\nimport 'package:ffi/ffi.dart';\n\nfinal class C extends Struct {\n  external Pointer<Utf8> str;\n\n  @Int32()\n  external int i;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_function_body",
    "description": "_A function body must be provided._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_function_keyword",
    "description": "_Function types must have the keyword 'Function' before the parameter list._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_function_parameters",
    "description": "_Functions must have an explicit list of parameters._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_get",
    "description": "_Getters must have the keyword 'get' before the getter name._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_hex_digit",
    "description": "_Hexadecimal digit expected._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_identifier",
    "description": "_Expected an identifier._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_initializer",
    "description": "_Expected an initializer._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_keyword_operator",
    "description": "_Operator declarations must be preceded by the keyword 'operator'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_method_parameters",
    "description": "_Methods must have an explicit list of parameters._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_name",
    "description": "_The 'name' field is required but missing._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when there's no top-level `name` key.\nThe `name` key provides the name of the package, which is required.\n\n## Example\n\nThe following code produces this diagnostic because the package doesn't\nhave a name:\n\n```yaml\ndependencies:\n  meta: ^1.0.2\n```\n\n## Common fixes\n\nAdd the top-level key `name` with a value that's the name of the package:\n\n```yaml\nname: example\ndependencies:\n  meta: ^1.0.2\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_named_pattern_field_name",
    "description": "_The getter name is not specified explicitly, and the pattern is not a variable._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when, within an object pattern, the\nspecification of a property and the pattern used to match the property's\nvalue doesn't have either:\n\n- a getter name before the colon\n- a variable pattern from which the getter name can be inferred\n\n## Example\n\nThe following code produces this diagnostic because there is no getter\nname before the colon and no variable pattern after the colon in the\nobject pattern (`C(:0)`):\n\n```dart\nabstract class C {\n  int get f;\n}\n\nvoid f(C c) {\n  switch (c) {\n    case C([!:0!]):\n      break;\n  }\n}\n```\n\n## Common fixes\n\nIf you need to use the actual value of the property within the pattern's\nscope, then add a variable pattern where the name of the variable is the\nsame as the name of the property being matched:\n\n```dart\nabstract class C {\n  int get f;\n}\n\nvoid f(C c) {\n  switch (c) {\n    case C(:var f) when f == 0:\n      print(f);\n  }\n}\n```\n\nIf you don't need to use the actual value of the property within the\npattern's scope, then add the name of the property being matched before\nthe colon:\n\n```dart\nabstract class C {\n  int get f;\n}\n\nvoid f(C c) {\n  switch (c) {\n    case C(f: 0):\n      break;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_name_for_named_parameter",
    "description": "_Named parameters in a function type must have a name_",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_name_in_library_directive",
    "description": "_Library directives must include a library name._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_name_in_part_of_directive",
    "description": "_Part-of directives must include a library name._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_override_of_must_be_overridden",
    "description": "_Missing a required override of '{0}' and '{1}'._\n\n_Missing a required override of '{0}', '{1}', and {2} more._\n\n_Missing a required override of '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an instance member that has the\n`@mustBeOverridden` annotation isn't overridden in a subclass.\n\n## Example\n\nThe following code produces this diagnostic because the class `B` doesn't\nhave an override of the inherited method `A.m` when `A.m` is annotated\nwith `@mustBeOverridden`:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass A {\n  @mustBeOverridden\n  void m() {}\n}\n\nclass [!B!] extends A {}\n```\n\n## Common fixes\n\nIf the annotation is appropriate for the member, then override the member\nin the subclass:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass A {\n  @mustBeOverridden\n  void m() {}\n}\n\nclass B extends A {\n  @override\n  void m() {}\n}\n```\n\nIf the annotation isn't appropriate for the member, then remove the\nannotation:\n\n```dart\nclass A {\n  void m() {}\n}\n\nclass B extends A {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_prefix_in_deferred_import",
    "description": "_Deferred imports should have a prefix._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_primary_constructor",
    "description": "_An extension type declaration must have a primary constructor declaration._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_primary_constructor_parameters",
    "description": "_A primary constructor declaration must have formal parameters._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_quote",
    "description": "_Expected quote (' or \")._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_required_argument",
    "description": "_The named parameter '{0}' is required, but there's no corresponding argument._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an invocation of a function is\nmissing a required named parameter.\n\n## Example\n\nThe following code produces this diagnostic because the invocation of `f`\ndoesn't include a value for the required named parameter `end`:\n\n```dart\nvoid f(int start, {required int end}) {}\nvoid g() {\n  [!f!](3);\n}\n```\n\n## Common fixes\n\nAdd a named argument corresponding to the missing required parameter:\n\n```dart\nvoid f(int start, {required int end}) {}\nvoid g() {\n  f(3, end: 5);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_required_param",
    "description": "_The parameter '{0}' is required._\n\n_The parameter '{0}' is required. {1}._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a method or function with a\nnamed parameter that is annotated as being required is invoked without\nproviding a value for the parameter.\n\n## Example\n\nThe following code produces this diagnostic because the named parameter `x`\nis required:\n\n```dart\nimport 'package:meta/meta.dart';\n\n// ignore: deprecated_member_use\nvoid f({@required int? x}) {}\n\nvoid g() {\n  [!f!]();\n}\n```\n\n## Common fixes\n\nProvide the required value:\n\n```dart\nimport 'package:meta/meta.dart';\n\n// ignore: deprecated_member_use\nvoid f({@required int? x}) {}\n\nvoid g() {\n  f(x: 2);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_return",
    "description": "_This function has a return type of '{0}', but doesn't end with a return statement._",
    "documentation": "## Description\n\nAny function or method that doesn't end with either an explicit return or a\nthrow implicitly returns `null`. This is rarely the desired behavior. The\nanalyzer produces this diagnostic when it finds an implicit return.\n\n## Example\n\nThe following code produces this diagnostic because `f` doesn't end with a\nreturn:\n\n```dart\nint [!f!](int x) {\n  if (x < 0) {\n    return 0;\n  }\n}\n```\n\n## Common fixes\n\nAdd a `return` statement that makes the return value explicit, even if\n`null` is the appropriate value.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_size_annotation_carray",
    "description": "_Fields of type 'Array' must have exactly one 'Array' annotation._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a field in a subclass of either\n`Struct` or `Union` has a type of `Array` but doesn't have a single\n`Array` annotation indicating the dimensions of the array.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the field `a0` doesn't\nhave an `Array` annotation:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  external [!Array<Uint8>!] a0;\n}\n```\n\n## Common fixes\n\nEnsure that there's exactly one `Array` annotation on the field:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Array(8)\n  external Array<Uint8> a0;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_star_after_sync",
    "description": "_The modifier 'sync' must be followed by a star ('*')._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_statement",
    "description": "_Expected a statement._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_terminator_for_parameter_group",
    "description": "_There is no '{0}' to close the parameter group._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_typedef_parameters",
    "description": "_Typedefs must have an explicit list of parameters._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_variable_in_for_each",
    "description": "_A loop variable must be declared in a for-each loop before the 'in', but none was found._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_variable_pattern",
    "description": "_Variable pattern '{0}' is missing in this branch of the logical-or pattern._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when one branch of a logical-or\npattern doesn't declare a variable that is declared on the other branch of\nthe same pattern.\n\n## Example\n\nThe following code produces this diagnostic because the right-hand side of\nthe logical-or pattern doesn't declare the variable `a`:\n\n```dart\nvoid f((int, int) r) {\n  if (r case (var a, 0) || [!(0, _)!]) {\n    print(a);\n  }\n}\n```\n\n## Common fixes\n\nIf the variable needs to be referenced in the controlled statements, then\nadd a declaration of the variable to every branch of the logical-or\npattern:\n\n```dart\nvoid f((int, int) r) {\n  if (r case (var a, 0) || (0, var a)) {\n    print(a);\n  }\n}\n```\n\nIf the variable doesn't need to be referenced in the controlled\nstatements, then remove the declaration of the variable from every branch\nof the logical-or pattern:\n\n```dart\nvoid f((int, int) r) {\n  if (r case (_, 0) || (0, _)) {\n    print('found a zero');\n  }\n}\n```\n\nIf the variable needs to be referenced if one branch of the pattern\nmatches but not when the other matches, then break the pattern into two\npieces:\n\n```dart\nvoid f((int, int) r) {\n  switch (r) {\n    case (var a, 0):\n      print(a);\n    case (0, _):\n      print('found a zero');\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "mixed_parameter_groups",
    "description": "_Can't have both positional and named parameters in a single parameter list._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "mixin_application_concrete_super_invoked_member_type",
    "description": "_The super-invoked member '{0}' has the type '{1}', and the concrete member in the class has the type '{2}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a mixin that invokes a method\nusing `super` is used in a class where the concrete implementation of that\nmethod has a different signature than the signature defined for that method\nby the mixin's `on` type. The reason this is an error is because the\ninvocation in the mixin might invoke the method in a way that's\nincompatible with the method that will actually be executed.\n\n## Example\n\nThe following code produces this diagnostic because the class `C` uses the\nmixin `M`, the mixin `M` invokes `foo` using `super`, and the abstract\nversion of `foo` declared in `I` (the mixin's `on` type) doesn't have the\nsame signature as the concrete version of `foo` declared in `A`:\n\n```dart\nclass I {\n  void foo([int? p]) {}\n}\n\nclass A {\n  void foo(int p) {}\n}\n\nabstract class B extends A implements I {\n  @override\n  void foo([int? p]);\n}\n\nmixin M on I {\n  void bar() {\n    super.foo(42);\n  }\n}\n\nabstract class C extends B with [!M!] {}\n```\n\n## Common fixes\n\nIf the class doesn't need to use the mixin, then remove it from the `with`\nclause:\n\n```dart\nclass I {\n  void foo([int? p]) {}\n}\n\nclass A {\n  void foo(int? p) {}\n}\n\nabstract class B extends A implements I {\n  @override\n  void foo([int? p]);\n}\n\nmixin M on I {\n  void bar() {\n    super.foo(42);\n  }\n}\n\nabstract class C extends B {}\n```\n\nIf the class needs to use the mixin, then ensure that there's a concrete\nimplementation of the method that conforms to the signature expected by the\nmixin:\n\n```dart\nclass I {\n  void foo([int? p]) {}\n}\n\nclass A {\n  void foo(int? p) {}\n}\n\nabstract class B extends A implements I {\n  @override\n  void foo([int? p]) {\n    super.foo(p);\n  }\n}\n\nmixin M on I {\n  void bar() {\n    super.foo(42);\n  }\n}\n\nabstract class C extends B with M {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "mixin_application_not_implemented_interface",
    "description": "_'{0}' can't be mixed onto '{1}' because '{1}' doesn't implement '{2}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a mixin that has a superclass\nconstraint is used in a [mixin application][] with a superclass that\ndoesn't implement the required constraint.\n\n## Example\n\nThe following code produces this diagnostic because the mixin `M` requires\nthat the class to which it's applied be a subclass of `A`, but `Object`\nisn't a subclass of `A`:\n\n```dart\nclass A {}\n\nmixin M on A {}\n\nclass X = Object with [!M!];\n```\n\n## Common fixes\n\nIf you need to use the mixin, then change the superclass to be either the\nsame as or a subclass of the superclass constraint:\n\n```dart\nclass A {}\n\nmixin M on A {}\n\nclass X = A with M;\n```\n\n[mixin application]: /resources/glossary#mixin-application\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "mixin_application_no_concrete_super_invoked_member",
    "description": "_The class doesn't have a concrete implementation of the super-invoked member '{0}'._\n\n_The class doesn't have a concrete implementation of the super-invoked setter '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a [mixin application][] contains\nan invocation of a member from its superclass, and there's no concrete\nmember of that name in the mixin application's superclass.\n\n## Example\n\nThe following code produces this diagnostic because the mixin `M` contains\nthe invocation `super.m()`, and the class `A`, which is the superclass of\nthe [mixin application][] `A+M`, doesn't define a concrete implementation\nof `m`:\n\n```dart\nabstract class A {\n  void m();\n}\n\nmixin M on A {\n  void bar() {\n    super.m();\n  }\n}\n\nabstract class B extends A with [!M!] {}\n```\n\n## Common fixes\n\nIf you intended to apply the mixin `M` to a different class, one that has a\nconcrete implementation of `m`, then change the superclass of `B` to that\nclass:\n\n```dart\nabstract class A {\n  void m();\n}\n\nmixin M on A {\n  void bar() {\n    super.m();\n  }\n}\n\nclass C implements A {\n  void m() {}\n}\n\nabstract class B extends C with M {}\n```\n\nIf you need to make `B` a subclass of `A`, then add a concrete\nimplementation of `m` in `A`:\n\n```dart\nabstract class A {\n  void m() {}\n}\n\nmixin M on A {\n  void bar() {\n    super.m();\n  }\n}\n\nabstract class B extends A with M {}\n```\n\n[mixin application]: /resources/glossary#mixin-application\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "mixin_class_declaration_extends_not_object",
    "description": "_The class '{0}' can't be declared a mixin because it extends a class other than 'Object'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class that is marked with\nthe `mixin` modifier extends a class other than `Object`. A mixin class\ncan't have a superclass other than `Object`.\n\n## Example\n\nThe following code produces this diagnostic because the class `B`, which\nhas the modifier `mixin`, extends `A`:\n\n```dart\nclass A {}\n\nmixin class B extends [!A!] {}\n```\n\n## Common fixes\n\nIf you want the class to be used as a mixin, then change the superclass to\n`Object`, either explicitly or by removing the extends clause:\n\n```dart\nclass A {}\n\nmixin class B {}\n```\n\nIf the class needs to have a superclass other than `Object`, then remove\nthe `mixin` modifier:\n\n```dart\nclass A {}\n\nclass B extends A {}\n```\n\nIf you need both a mixin and a subclass of a class other than `Object`,\nthen move the members of the subclass to a new mixin, remove the `mixin`\nmodifier from the subclass, and apply the new mixin to the subclass:\n\n```dart\nclass A {}\n\nclass B extends A with M {}\n\nmixin M {}\n```\n\nDepending on the members of the subclass this might require adding an `on`\nclause to the mixin.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "mixin_class_declares_constructor",
    "description": "_The class '{0}' can't be used as a mixin because it declares a constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class is used as a mixin and\nthe mixed-in class defines a constructor.\n\n## Example\n\nThe following code produces this diagnostic because the class `A`, which\ndefines a constructor, is being used as a mixin:\n\n```dart\n//@dart=2.19\nclass A {\n  A();\n}\n\nclass B with [!A!] {}\n```\n\n## Common fixes\n\nIf it's possible to convert the class to a mixin, then do so:\n\n```dart\nmixin A {\n}\n\nclass B with A {}\n```\n\nIf the class can't be a mixin and it's possible to remove the constructor,\nthen do so:\n\n```dart\n//@dart=2.19\nclass A {\n}\n\nclass B with A {}\n```\n\nIf the class can't be a mixin and you can't remove the constructor, then\ntry extending or implementing the class rather than mixing it in:\n\n```dart\nclass A {\n  A();\n}\n\nclass B extends A {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "mixin_declares_constructor",
    "description": "_Mixins can't declare constructors._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "mixin_inherits_from_not_object",
    "description": "_The class '{0}' can't be used as a mixin because it extends a class other than 'Object'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class that extends a class\nother than `Object` is used as a mixin.\n\n## Example\n\nThe following code produces this diagnostic because the class `B`, which\nextends `A`, is being used as a mixin by `C`:\n\n```dart\n//@dart=2.19\nclass A {}\n\nclass B extends A {}\n\nclass C with [!B!] {}\n```\n\n## Common fixes\n\nIf the class being used as a mixin can be changed to extend `Object`, then\nchange it:\n\n```dart\n//@dart=2.19\nclass A {}\n\nclass B {}\n\nclass C with B {}\n```\n\nIf the class being used as a mixin can't be changed and the class that's\nusing it extends `Object`, then extend the class being used as a mixin:\n\n```dart\nclass A {}\n\nclass B extends A {}\n\nclass C extends B {}\n```\n\nIf the class doesn't extend `Object` or if you want to be able to mix in\nthe behavior from `B` in other places, then create a real mixin:\n\n```dart\nclass A {}\n\nmixin M on A {}\n\nclass B extends A with M {}\n\nclass C extends A with M {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "mixin_instantiate",
    "description": "_Mixins can't be instantiated._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a mixin is instantiated.\n\n## Example\n\nThe following code produces this diagnostic because the mixin `M` is being\ninstantiated:\n\n```dart\nmixin M {}\n\nvar m = [!M!]();\n```\n\n## Common fixes\n\nIf you intend to use an instance of a class, then use the name of that\nclass in place of the name of the mixin.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "mixin_of_non_class",
    "description": "_Classes can only mix in mixins and classes._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a name in a `with` clause is\ndefined to be something other than a mixin or a class.\n\n## Example\n\nThe following code produces this diagnostic because `F` is defined to be a\nfunction type:\n\n```dart\ntypedef F = int Function(String);\n\nclass C with [!F!] {}\n```\n\n## Common fixes\n\nRemove the invalid name from the list, possibly replacing it with the name\nof the intended mixin or class:\n\n```dart\ntypedef F = int Function(String);\n\nclass C {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "mixin_on_sealed_class",
    "description": "_The class '{0}' shouldn't be used as a mixin constraint because it is sealed, and any class mixing in this mixin must have '{0}' as a superclass._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the superclass constraint of a\nmixin is a class from a different package that was marked as\n[`sealed`][meta-sealed]. Classes that are sealed can't be extended,\nimplemented, mixed in, or used as a superclass constraint.\n\n## Example\n\nIf the package `p` defines a sealed class:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@sealed\nclass C {}\n```\n\nThen, the following code, when in a package other than `p`, produces this\ndiagnostic:\n\n```dart\nimport 'package:p/p.dart';\n\n[!mixin M on C {}!]\n```\n\n## Common fixes\n\nIf the classes that use the mixin don't need to be subclasses of the sealed\nclass, then consider adding a field and delegating to the wrapped instance\nof the sealed class.\n\n[meta-sealed]: https://pub.dev/documentation/meta/latest/meta/sealed-constant.html\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "mixin_super_class_constraint_deferred_class",
    "description": "_Deferred classes can't be used as superclass constraints._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a superclass constraint of a\nmixin is imported from a deferred library.\n\n## Example\n\nThe following code produces this diagnostic because the superclass\nconstraint of `math.Random` is imported from a deferred library:\n\n```dart\nimport 'dart:async' deferred as async;\n\nmixin M<T> on [!async.Stream<T>!] {}\n```\n\n## Common fixes\n\nIf the import doesn't need to be deferred, then remove the `deferred`\nkeyword:\n\n```dart\nimport 'dart:async' as async;\n\nmixin M<T> on async.Stream<T> {}\n```\n\nIf the import does need to be deferred, then remove the superclass\nconstraint:\n\n```dart\nmixin M<T> {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "mixin_super_class_constraint_non_interface",
    "description": "_Only classes and mixins can be used as superclass constraints._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a type following the `on`\nkeyword in a mixin declaration is neither a class nor a mixin.\n\n## Example\n\nThe following code produces this diagnostic because `F` is neither a class\nnor a mixin:\n\n```dart\ntypedef F = void Function();\n\nmixin M on [!F!] {}\n```\n\n## Common fixes\n\nIf the type was intended to be a class but was mistyped, then replace the\nname.\n\nOtherwise, remove the type from the `on` clause.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "mixin_with_clause",
    "description": "_A mixin can't have a with clause._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "mixin_with_non_class_superclass",
    "description": "_Mixin can only be applied to class._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "modifier_out_of_order",
    "description": "_The modifier '{0}' should be before the modifier '{1}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "multiple_clauses",
    "description": "_Each '{0}' definition can have at most one '{1}' clause._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "multiple_combinators",
    "description": "_Using multiple 'hide' or 'show' combinators is never necessary and often produces surprising results._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an import or export directive\ncontains more than one combinator.\n\n## Examples\n\nThe following code produces this diagnostic because the second `show`\ncombinator hides `List` and `int`:\n\n```dart\nimport 'dart:core' [!show Future, List, int show Future!];\n\nvar x = Future.value(1);\n```\n\nThe following code produces this diagnostic because\nthe second `hide` combinator is redundant:\n\n```dart\nimport 'dart:math' [!hide Random, max, min hide min!];\n\nvar x = pi;\n```\n\nThe following codes produce this diagnostic because\nthe `hide` combinator is redundant:\n\n```dart\nimport 'dart:math' [!show Random, max hide min!];\n\nvar x = max(0, 1);\nvar r = Random();\n```\n\nThe following code produces this diagnostic because\nthe `show` combinator already hides `Random` and `max`,\nso the `hide` combinator is redundant:\n\n```dart\nimport 'dart:math' [!hide Random, max show min!];\n\nvar x = min(0, 1);\n```\n\n## Common fixes\n\nIf you prefer to list the names that should be visible,\nthen use a single `show` combinator:\n\n```dart\nimport 'dart:math' show min;\n\nvar x = min(0, 1);\n```\n\nIf you prefer to list the names that should be hidden,\nthen use a single `hide` combinator:\n\n```dart\nimport 'dart:math' hide Random, max, min;\n\nvar x = pi;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "multiple_extends_clauses",
    "description": "_Each class definition can have at most one extends clause._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "multiple_implements_clauses",
    "description": "_Each class or mixin definition can have at most one implements clause._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "multiple_library_directives",
    "description": "_Only one library directive may be declared in a file._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "multiple_named_parameter_groups",
    "description": "_Can't have multiple groups of named parameters in a single parameter list._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "multiple_on_clauses",
    "description": "_Each mixin definition can have at most one on clause._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "multiple_part_of_directives",
    "description": "_Only one part-of directive may be declared in a file._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "multiple_plugins",
    "description": "_Multiple plugins can't be enabled._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "multiple_positional_parameter_groups",
    "description": "_Can't have multiple groups of positional parameters in a single parameter list._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "multiple_redirecting_constructor_invocations",
    "description": "_Constructors can have only one 'this' redirection, at most._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor redirects to more\nthan one other constructor in the same class (using `this`).\n\n## Example\n\nThe following code produces this diagnostic because the unnamed\nconstructor in `C` is redirecting to both `this.a` and `this.b`:\n\n```dart\nclass C {\n  C() : this.a(), [!this.b()!];\n  C.a();\n  C.b();\n}\n```\n\n## Common fixes\n\nRemove all but one of the redirections:\n\n```dart\nclass C {\n  C() : this.a();\n  C.a();\n  C.b();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "multiple_representation_fields",
    "description": "_Each extension type should have exactly one representation field._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "multiple_super_initializers",
    "description": "_A constructor can have at most one 'super' initializer._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the initializer list of a\nconstructor contains more than one invocation of a constructor from the\nsuperclass. The initializer list is required to have exactly one such call,\nwhich can either be explicit or implicit.\n\n## Example\n\nThe following code produces this diagnostic because the initializer list\nfor `B`'s constructor invokes both the constructor `one` and the\nconstructor `two` from the superclass `A`:\n\n```dart\nclass A {\n  int? x;\n  String? s;\n  A.one(this.x);\n  A.two(this.s);\n}\n\nclass B extends A {\n  B() : super.one(0), [!super.two('')!];\n}\n```\n\n## Common fixes\n\nIf one of the super constructors will initialize the instance fully, then\nremove the other:\n\n```dart\nclass A {\n  int? x;\n  String? s;\n  A.one(this.x);\n  A.two(this.s);\n}\n\nclass B extends A {\n  B() : super.one(0);\n}\n```\n\nIf the initialization achieved by one of the super constructors can be\nperformed in the body of the constructor, then remove its super invocation\nand perform the initialization in the body:\n\n```dart\nclass A {\n  int? x;\n  String? s;\n  A.one(this.x);\n  A.two(this.s);\n}\n\nclass B extends A {\n  B() : super.one(0) {\n    s = '';\n  }\n}\n```\n\nIf the initialization can only be performed in a constructor in the\nsuperclass, then either add a new constructor or modify one of the existing\nconstructors so there's a constructor that allows all the required\ninitialization to occur in a single call:\n\n```dart\nclass A {\n  int? x;\n  String? s;\n  A.one(this.x);\n  A.two(this.s);\n  A.three(this.x, this.s);\n}\n\nclass B extends A {\n  B() : super.three(0, '');\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "multiple_variables_in_for_each",
    "description": "_A single loop variable must be declared in a for-each loop before the 'in', but {0} were found._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "multiple_variance_modifiers",
    "description": "_Each type parameter can have at most one variance modifier._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "multiple_with_clauses",
    "description": "_Each class definition can have at most one with clause._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "must_be_a_native_function_type",
    "description": "_The type '{0}' given to '{1}' must be a valid 'dart:ffi' native function type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an invocation of either\n`Pointer.fromFunction`, `DynamicLibrary.lookupFunction`,\nor a `NativeCallable` constructor, has a type\nargument(whether explicit or inferred) that isn't a native function type.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the type `T` can be\nany subclass of `Function` but the type argument for `fromFunction` is\nrequired to be a native function type:\n\n```dart\nimport 'dart:ffi';\n\nint f(int i) => i * 2;\n\nclass C<T extends Function> {\n  void g() {\n    Pointer.fromFunction<[!T!]>(f, 0);\n  }\n}\n```\n\n## Common fixes\n\nUse a native function type as the type argument to the invocation:\n\n```dart\nimport 'dart:ffi';\n\nint f(int i) => i * 2;\n\nclass C<T extends Function> {\n  void g() {\n    Pointer.fromFunction<Int32 Function(Int32)>(f, 0);\n  }\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "must_be_a_subtype",
    "description": "_The type '{0}' must be a subtype of '{1}' for '{2}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic in two cases:\n- In an invocation of `Pointer.fromFunction`, or a\n  `NativeCallable` constructor where the type argument\n  (whether explicit or inferred) isn't a supertype of the type of the\n  function passed as the first argument to the method.\n- In an invocation of `DynamicLibrary.lookupFunction` where the first type\n  argument isn't a supertype of the second type argument.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the type of the\nfunction `f` (`String Function(int)`) isn't a subtype of the type\nargument `T` (`Int8 Function(Int8)`):\n\n```dart\nimport 'dart:ffi';\n\ntypedef T = Int8 Function(Int8);\n\ndouble f(double i) => i;\n\nvoid g() {\n  Pointer.fromFunction<T>([!f!], 5.0);\n}\n```\n\n## Common fixes\n\nIf the function is correct, then change the type argument to match:\n\n```dart\nimport 'dart:ffi';\n\ntypedef T = Float Function(Float);\n\ndouble f(double i) => i;\n\nvoid g() {\n  Pointer.fromFunction<T>(f, 5.0);\n}\n```\n\nIf the type argument is correct, then change the function to match:\n\n```dart\nimport 'dart:ffi';\n\ntypedef T = Int8 Function(Int8);\n\nint f(int i) => i;\n\nvoid g() {\n  Pointer.fromFunction<T>(f, 5);\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "must_be_immutable",
    "description": "_This class (or a class that this class inherits from) is marked as '@immutable', but one or more of its instance fields aren't final: {0}_",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an immutable class defines one\nor more instance fields that aren't final. A class is immutable if it's\nmarked as being immutable using the annotation\n[`immutable`][meta-immutable] or if it's a subclass of an immutable class.\n\n## Example\n\nThe following code produces this diagnostic because the field `x` isn't\nfinal:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@immutable\nclass [!C!] {\n  int x;\n\n  C(this.x);\n}\n```\n\n## Common fixes\n\nIf instances of the class should be immutable, then add the keyword `final`\nto all non-final field declarations:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@immutable\nclass C {\n  final int x;\n\n  C(this.x);\n}\n```\n\nIf the instances of the class should be mutable, then remove the\nannotation, or choose a different superclass if the annotation is\ninherited:\n\n```dart\nclass C {\n  int x;\n\n  C(this.x);\n}\n```\n\n[meta-immutable]: https://pub.dev/documentation/meta/latest/meta/immutable-constant.html\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "must_call_super",
    "description": "_This method overrides a method annotated as '@mustCallSuper' in '{0}', but doesn't invoke the overridden method._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a method that overrides a method\nthat is annotated as [`mustCallSuper`][meta-mustCallSuper] doesn't invoke\nthe overridden method as required.\n\n## Example\n\nThe following code produces this diagnostic because the method `m` in `B`\ndoesn't invoke the overridden method `m` in `A`:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass A {\n  @mustCallSuper\n  m() {}\n}\n\nclass B extends A {\n  @override\n  [!m!]() {}\n}\n```\n\n## Common fixes\n\nAdd an invocation of the overridden method in the overriding method:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass A {\n  @mustCallSuper\n  m() {}\n}\n\nclass B extends A {\n  @override\n  m() {\n    super.m();\n  }\n}\n```\n\n[meta-mustCallSuper]: https://pub.dev/documentation/meta/latest/meta/mustCallSuper-constant.html\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "must_return_void",
    "description": "_The return type of the function passed to 'NativeCallable.listener' must be 'void' rather than '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when you pass a function\nthat doesn't return `void` to the `NativeCallable.listener` constructor.\n\n`NativeCallable.listener` creates a native callable that can be invoked\nfrom any thread. The native code that invokes the callable sends a message\nback to the isolate that created the callable, and doesn't wait for a\nresponse. So it isn't possible to return a result from the callable.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the function\n`f` returns `int` rather than `void`.\n\n```dart\nimport 'dart:ffi';\n\nint f(int i) => i * 2;\n\nvoid g() {\n  NativeCallable<Int32 Function(Int32)>.listener([!f!]);\n}\n```\n\n## Common fixes\n\nChange the return type of the function to `void`.\n\n```dart\nimport 'dart:ffi';\n\nvoid f(int i) => print(i * 2);\n\nvoid g() {\n  NativeCallable<Void Function(Int32)>.listener(f);\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "named_function_expression",
    "description": "_Function expressions can't be named._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "named_function_type",
    "description": "_Function types can't be named._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "named_parameter_outside_group",
    "description": "_Named parameters must be enclosed in curly braces ('{' and '}')._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "name_not_string",
    "description": "_The value of the 'name' field is required to be a string._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the top-level `name` key has a\nvalue that isn't a string.\n\n## Example\n\nThe following code produces this diagnostic because the value following the\n`name` key is a list:\n\n```yaml\nname:\n  [!- example!]\n```\n\n## Common fixes\n\nReplace the value with a string:\n\n```yaml\nname: example\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "native_clause_in_non_sdk_code",
    "description": "_Native clause can only be used in the SDK and code that is loaded through native extensions._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "native_clause_should_be_annotation",
    "description": "_Native clause in this form is deprecated._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "native_field_invalid_type",
    "description": "_'{0}' is an unsupported type for native fields. Native fields only support pointers, arrays or numeric and compound types._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an `@Native`-annotated field\nhas a type not supported for native fields.\n\nNative fields support pointers, arrays, numeric types and subtypes of\n`Compound` (i.e., structs or unions). Other subtypes of `NativeType`,\nsuch as `Handle` or `NativeFunction` are not allowed as native fields.\n\nNative functions should be used with external functions instead of\nexternal fields.\n\nHandles are unsupported because there is no way to transparently load and\nstore Dart objects into pointers.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the field `free` uses\nan unsupported native type, `NativeFunction`:\n\n```dart\nimport 'dart:ffi';\n\n@Native<NativeFunction<Void Function()>>()\nexternal void Function() [!free!];\n```\n\n## Common fixes\n\nIf you meant to bind to an existing native function with a\n`NativeFunction` field, use `@Native` methods instead:\n\n```dart\nimport 'dart:ffi';\n\n@Native<Void Function(Pointer<Void>)>()\nexternal void free(Pointer<Void> ptr);\n```\n\nTo bind to a field storing a function pointer in C, use a pointer type\nfor the Dart field:\n\n```dart\nimport 'dart:ffi';\n\n@Native()\nexternal Pointer<NativeFunction<Void Function(Pointer<Void>)>> free;\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "native_field_missing_type",
    "description": "_The native type of this field could not be inferred and must be specified in the annotation._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an `@Native`-annotated field\nrequires a type hint on the annotation to infer the native type.\n\nDart types like `int` and `double` have multiple possible native\nrepresentations. Since the native type needs to be known at compile time\nto generate the correct load and stores when accessing the field, an\nexplicit type must be given.\n\n## Example\n\nThe following code produces this diagnostic because the field `f` has\nthe type `int` (for which multiple native representations exist), but no\nexplicit type parameter on the `Native` annotation:\n\n```dart\nimport 'dart:ffi';\n\n@Native()\nexternal int [!f!];\n```\n\n## Common fixes\n\nTo fix this diagnostic, find out the correct native representation from\nthe native declaration of the field. Then, add the corresponding type to\nthe annotation. For instance, if `f` was declared as an `uint8_t` in C,\nthe Dart field should be declared as:\n\n```dart\nimport 'dart:ffi';\n\n@Native<Uint8>()\nexternal int f;\n```\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "native_field_not_static",
    "description": "_Native fields must be static._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an instance field in a class\nhas been annotated with `@Native`.\nNative fields refer to global variables in C, C++ or other native\nlanguages, whereas instance fields in Dart are specific to an instance of\nthat class. Hence, native fields must be static.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the field `f` in the\nclass `C` is `@Native`, but not `static`:\n\n```dart\nimport 'dart:ffi';\n\nclass C {\n  @Native<Int>()\n  external int [!f!];\n}\n```\n\n## Common fixes\n\nEither make the field static:\n\n```dart\nimport 'dart:ffi';\n\nclass C {\n  @Native<Int>()\n  external static int f;\n}\n```\n\nOr move it out of a class, in which case no explicit `static` modifier is\nrequired:\n\n```dart\nimport 'dart:ffi';\n\nclass C {\n}\n\n@Native<Int>()\nexternal int f;\n```\n\nIf you meant to annotate an instance field that should be part of a\nstruct, omit the `@Native` annotation:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Int()\n  external int f;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "native_function_body_in_non_sdk_code",
    "description": "_Native functions can only be declared in the SDK and code that is loaded through native extensions._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "native_function_missing_type",
    "description": "_The native type of this function couldn't be inferred so it must be specified in the annotation._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `@Native`-annotated function\nrequires a type hint on the annotation to infer the native function type.\n\nDart types like `int` and `double` have multiple possible native\nrepresentations. Since the native type needs to be known at compile time\nto generate correct bindings and call instructions for the function, an\nexplicit type must be given.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the function `f()` has\nthe return type `int`, but doesn't have an explicit type parameter on the\n`Native` annotation:\n\n```dart\nimport 'dart:ffi';\n\n@Native()\nexternal int [!f!]();\n```\n\n## Common fixes\n\nAdd the corresponding type to the annotation. For instance, if `f()` was\ndeclared to return an `int32_t` in C, the Dart function should be declared\nas:\n\n```dart\nimport 'dart:ffi';\n\n@Native<Int32 Function()>()\nexternal int f();\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "negative_variable_dimension",
    "description": "_The variable dimension of a variable-length array must be non-negative._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic in two cases.\n\nThe first is when the variable dimension given in an\n`Array.variableWithVariableDimension` annotation is negative. The variable\ndimension is the first argument in the annotation.\n\nThe second is when the variable dimension given in an\n`Array.variableMulti` annotation is negative. The variable dimension is\nspecified in the `variableDimension` argument of the annotation.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Examples\n\nThe following code produces this diagnostic because a variable dimension\nof `-1` was provided in the `Array.variableWithVariableDimension`\nannotation:\n\n```dart\nimport 'dart:ffi';\n\nfinal class MyStruct extends Struct {\n  @Array.variableWithVariableDimension([!-1!])\n  external Array<Uint8> a0;\n}\n```\n\nThe following code produces this diagnostic because a variable dimension\nof `-1` was provided in the `Array.variableMulti` annotation:\n\n```dart\nimport 'dart:ffi';\n\nfinal class MyStruct2 extends Struct {\n  @Array.variableMulti(variableDimension: [!-1!], [1, 2])\n  external Array<Array<Array<Uint8>>> a0;\n}\n```\n\n## Common fixes\n\nChange the variable dimension with zero (`0`) or a positive number:\n\n```dart\nimport 'dart:ffi';\n\nfinal class MyStruct extends Struct {\n  @Array.variableWithVariableDimension(1)\n  external Array<Uint8> a0;\n}\n```\n\nChange the variable dimension with zero (`0`) or a positive number:\n\n```dart\nimport 'dart:ffi';\n\nfinal class MyStruct2 extends Struct {\n  @Array.variableMulti(variableDimension: 1, [1, 2])\n  external Array<Array<Array<Uint8>>> a0;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "new_constructor_new_name",
    "description": "_Constructors declared with the 'new' keyword can't be named 'new'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "new_constructor_qualified_name",
    "description": "_Constructors declared with the 'new' keyword can't have qualified names._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "new_with_undefined_constructor",
    "description": "_The class '{0}' doesn't have a constructor named '{1}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "new_with_undefined_constructor_default",
    "description": "_The class '{0}' doesn't have an unnamed constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an unnamed constructor is\ninvoked on a class that defines named constructors but the class doesn't\nhave an unnamed constructor.\n\n## Example\n\nThe following code produces this diagnostic because `A` doesn't define an\nunnamed constructor:\n\n```dart\nclass A {\n  A.a();\n}\n\nA f() => [!A!]();\n```\n\n## Common fixes\n\nIf one of the named constructors does what you need, then use it:\n\n```dart\nclass A {\n  A.a();\n}\n\nA f() => A.a();\n```\n\nIf none of the named constructors does what you need, and you're able to\nadd an unnamed constructor, then add the constructor:\n\n```dart\nclass A {\n  A();\n  A.a();\n}\n\nA f() => A();\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_abstract_class_inherits_abstract_member",
    "description": "_Missing concrete implementation of '{0}'._\n\n_Missing concrete implementations of '{0}' and '{1}'._\n\n_Missing concrete implementations of '{0}', '{1}', '{2}', '{3}', and {4} more._\n\n_Missing concrete implementations of '{0}', '{1}', '{2}', and '{3}'._\n\n_Missing concrete implementations of '{0}', '{1}', and '{2}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a concrete class inherits one or\nmore abstract members, and doesn't provide or inherit an implementation for\nat least one of those abstract members.\n\n## Example\n\nThe following code produces this diagnostic because the class `B` doesn't\nhave a concrete implementation of `m`:\n\n```dart\nabstract class A {\n  void m();\n}\n\nclass [!B!] extends A {}\n```\n\n## Common fixes\n\nIf the subclass can provide a concrete implementation for some or all of\nthe abstract inherited members, then add the concrete implementations:\n\n```dart\nabstract class A {\n  void m();\n}\n\nclass B extends A {\n  void m() {}\n}\n```\n\nIf there is a mixin that provides an implementation of the inherited\nmethods, then apply the mixin to the subclass:\n\n```dart\nabstract class A {\n  void m();\n}\n\nclass B extends A with M {}\n\nmixin M {\n  void m() {}\n}\n```\n\nIf the subclass can't provide a concrete implementation for all of the\nabstract inherited members, then mark the subclass as being abstract:\n\n```dart\nabstract class A {\n  void m();\n}\n\nabstract class B extends A {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_bool_condition",
    "description": "_Conditions must have a static type of 'bool'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a condition, such as an `if` or\n`while` loop, doesn't have the static type `bool`.\n\n## Example\n\nThe following code produces this diagnostic because `x` has the static type\n`int`:\n\n```dart\nvoid f(int x) {\n  if ([!x!]) {\n    // ...\n  }\n}\n```\n\n## Common fixes\n\nChange the condition so that it produces a Boolean value:\n\n```dart\nvoid f(int x) {\n  if (x == 0) {\n    // ...\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_bool_expression",
    "description": "_The expression in an assert must be of type 'bool'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the first expression in an\nassert has a type other than `bool`.\n\n## Example\n\nThe following code produces this diagnostic because the type of `p` is\n`int`, but a `bool` is required:\n\n```dart\nvoid f(int p) {\n  assert([!p!]);\n}\n```\n\n## Common fixes\n\nChange the expression so that it has the type `bool`:\n\n```dart\nvoid f(int p) {\n  assert(p > 0);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_bool_negation_expression",
    "description": "_A negation operand must have a static type of 'bool'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the operand of the unary\nnegation operator (`!`) doesn't have the type `bool`.\n\n## Example\n\nThe following code produces this diagnostic because `x` is an `int` when it\nmust be a `bool`:\n\n```dart\nint x = 0;\nbool y = ![!x!];\n```\n\n## Common fixes\n\nReplace the operand with an expression that has the type `bool`:\n\n```dart\nint x = 0;\nbool y = !(x > 0);\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_bool_operand",
    "description": "_The operands of the operator '{0}' must be assignable to 'bool'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when one of the operands of either\nthe `&&` or `||` operator doesn't have the type `bool`.\n\n## Example\n\nThe following code produces this diagnostic because `a` isn't a Boolean\nvalue:\n\n```dart\nint a = 3;\nbool b = [!a!] || a > 1;\n```\n\n## Common fixes\n\nChange the operand to a Boolean value:\n\n```dart\nint a = 3;\nbool b = a == 0 || a > 1;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_constant_annotation_constructor",
    "description": "_Annotation creation can only call a const constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an annotation is the invocation\nof an existing constructor even though the invoked constructor isn't a\nconst constructor.\n\n## Example\n\nThe following code produces this diagnostic because the constructor for `C`\nisn't a const constructor:\n\n```dart\n[!@C()!]\nvoid f() {\n}\n\nclass C {\n  C();\n}\n```\n\n## Common fixes\n\nIf it's valid for the class to have a const constructor, then create a\nconst constructor that can be used for the annotation:\n\n```dart\n@C()\nvoid f() {\n}\n\nclass C {\n  const C();\n}\n```\n\nIf it isn't valid for the class to have a const constructor, then either\nremove the annotation or use a different class for the annotation.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_constant_case_expression",
    "description": "_Case expressions must be constant._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the expression in a `case`\nclause isn't a constant expression.\n\n## Example\n\nThe following code produces this diagnostic because `j` isn't a constant:\n\n```dart\nvoid f(int i, int j) {\n  switch (i) {\n    case [!j!]:\n      // ...\n      break;\n  }\n}\n```\n\n## Common fixes\n\nEither make the expression a constant expression, or rewrite the `switch`\nstatement as a sequence of `if` statements:\n\n```dart\nvoid f(int i, int j) {\n  if (i == j) {\n    // ...\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_constant_case_expression_from_deferred_library",
    "description": "_Constant values from a deferred library can't be used as a case expression._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the expression in a case clause\nreferences a constant from a library that is imported using a deferred\nimport. In order for switch statements to be compiled efficiently, the\nconstants referenced in case clauses need to be available at compile time,\nand constants from deferred libraries aren't available at compile time.\n\nFor more information, check out\n[Lazily loading a library](https://dart.dev/language/libraries#lazily-loading-a-library).\n\n## Example\n\nGiven a file `a.dart` that defines the constant `zero`:\n\n```dart\nconst zero = 0;\n```\n\nThe following code produces this diagnostic because the library `a.dart` is\nimported using a `deferred` import, and the constant `a.zero`, declared in\nthe imported library, is used in a case clause:\n\n```dart\nimport 'a.dart' deferred as a;\n\nvoid f(int x) {\n  switch (x) {\n    case a.[!zero!]:\n      // ...\n      break;\n  }\n}\n```\n\n## Common fixes\n\nIf you need to reference the constant from the imported library, then\nremove the `deferred` keyword:\n\n```dart\nimport 'a.dart' as a;\n\nvoid f(int x) {\n  switch (x) {\n    case a.zero:\n      // ...\n      break;\n  }\n}\n```\n\nIf you need to reference the constant from the imported library and also\nneed the imported library to be deferred, then rewrite the switch statement\nas a sequence of `if` statements:\n\n```dart\nimport 'a.dart' deferred as a;\n\nvoid f(int x) {\n  if (x == a.zero) {\n    // ...\n  }\n}\n```\n\nIf you don't need to reference the constant, then replace the case\nexpression:\n\n```dart\nvoid f(int x) {\n  switch (x) {\n    case 0:\n      // ...\n      break;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_constant_default_value",
    "description": "_The default value of an optional parameter must be constant._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an optional parameter, either\nnamed or positional, has a default value that isn't a compile-time\nconstant.\n\n## Example\n\nThe following code produces this diagnostic:\n\n```dart\nvar defaultValue = 3;\n\nvoid f([int value = [!defaultValue!]]) {}\n```\n\n## Common fixes\n\nIf the default value can be converted to be a constant, then convert it:\n\n```dart\nconst defaultValue = 3;\n\nvoid f([int value = defaultValue]) {}\n```\n\nIf the default value needs to change over time, then apply the default\nvalue inside the function:\n\n```dart\nvar defaultValue = 3;\n\nvoid f([int? value]) {\n  value ??= defaultValue;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_constant_default_value_from_deferred_library",
    "description": "_Constant values from a deferred library can't be used as a default parameter value._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the default value of an optional\nparameter uses a constant from a library imported using a deferred import.\nDefault values need to be available at compile time, and constants from\ndeferred libraries aren't available at compile time.\n\nFor more information, check out\n[Lazily loading a library](https://dart.dev/language/libraries#lazily-loading-a-library).\n\n## Example\n\nGiven a file `a.dart` that defines the constant `zero`:\n\n```dart\nconst zero = 0;\n```\n\nThe following code produces this diagnostic because `zero` is declared in a\nlibrary imported using a deferred import:\n\n```dart\nimport 'a.dart' deferred as a;\n\nvoid f({int x = a.[!zero!]}) {}\n```\n\n## Common fixes\n\nIf you need to reference the constant from the imported library, then\nremove the `deferred` keyword:\n\n```dart\nimport 'a.dart' as a;\n\nvoid f({int x = a.zero}) {}\n```\n\nIf you don't need to reference the constant, then replace the default\nvalue:\n\n```dart\nvoid f({int x = 0}) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_constant_list_element",
    "description": "_The values in a const list literal must be constants._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an element in a constant list\nliteral isn't a constant value. The list literal can be constant either\nexplicitly (because it's prefixed by the `const` keyword) or implicitly\n(because it appears in a [constant context][]).\n\n## Example\n\nThe following code produces this diagnostic because `x` isn't a constant,\neven though it appears in an implicitly constant list literal:\n\n```dart\nvar x = 2;\nvar y = const <int>[0, 1, [!x!]];\n```\n\n## Common fixes\n\nIf the list needs to be a constant list, then convert the element to be a\nconstant. In the example above, you might add the `const` keyword to the\ndeclaration of `x`:\n\n```dart\nconst x = 2;\nvar y = const <int>[0, 1, x];\n```\n\nIf the expression can't be made a constant, then the list can't be a\nconstant either, so you must change the code so that the list isn't a\nconstant. In the example above this means removing the `const` keyword\nbefore the list literal:\n\n```dart\nvar x = 2;\nvar y = <int>[0, 1, x];\n```\n\n[constant context]: /resources/glossary#constant-context\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_constant_map_element",
    "description": "_The elements in a const map literal must be constant._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an `if` element or a spread\nelement in a constant map isn't a constant element.\n\n## Examples\n\nThe following code produces this diagnostic because it's attempting to\nspread a non-constant map:\n\n```dart\nvar notConst = <int, int>{};\nvar map = const <int, int>{...[!notConst!]};\n```\n\nSimilarly, the following code produces this diagnostic because the\ncondition in the `if` element isn't a constant expression:\n\n```dart\nbool notConst = true;\nvar map = const <int, int>{if ([!notConst!]) 1 : 2};\n```\n\n## Common fixes\n\nIf the map needs to be a constant map, then make the elements constants.\nIn the spread example, you might do that by making the collection being\nspread a constant:\n\n```dart\nconst notConst = <int, int>{};\nvar map = const <int, int>{...notConst};\n```\n\nIf the map doesn't need to be a constant map, then remove the `const`\nkeyword:\n\n```dart\nbool notConst = true;\nvar map = <int, int>{if (notConst) 1 : 2};\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_constant_map_key",
    "description": "_The keys in a const map literal must be constant._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a key in a constant map literal\nisn't a constant value.\n\n## Example\n\nThe following code produces this diagnostic because `a` isn't a constant:\n\n```dart\nvar a = 'a';\nvar m = const {[!a!]: 0};\n```\n\n## Common fixes\n\nIf the map needs to be a constant map, then make the key a constant:\n\n```dart\nconst a = 'a';\nvar m = const {a: 0};\n```\n\nIf the map doesn't need to be a constant map, then remove the `const`\nkeyword:\n\n```dart\nvar a = 'a';\nvar m = {a: 0};\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_constant_map_pattern_key",
    "description": "_Key expressions in map patterns must be constants._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a key in a map pattern isn't a\nconstant expression.\n\n## Example\n\nThe following code produces this diagnostic because the key `A()` isn't a\nconstant:\n\n```dart\nvoid f(Object x) {\n  if (x case {[!A()!]: 0}) {}\n}\n\nclass A {\n  const A();\n}\n```\n\n## Common fixes\n\nUse a constant for the key:\n\n```dart\nvoid f(Object x) {\n  if (x case {const A(): 0}) {}\n}\n\nclass A {\n  const A();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_constant_map_value",
    "description": "_The values in a const map literal must be constant._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a value in a constant map\nliteral isn't a constant value.\n\n## Example\n\nThe following code produces this diagnostic because `a` isn't a constant:\n\n```dart\nvar a = 'a';\nvar m = const {0: [!a!]};\n```\n\n## Common fixes\n\nIf the map needs to be a constant map, then make the key a constant:\n\n```dart\nconst a = 'a';\nvar m = const {0: a};\n```\n\nIf the map doesn't need to be a constant map, then remove the `const`\nkeyword:\n\n```dart\nvar a = 'a';\nvar m = {0: a};\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_constant_record_field",
    "description": "_The fields in a const record literal must be constants._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_constant_record_field_from_deferred_library",
    "description": "_Constant values from a deferred library can't be used as fields in a 'const' record literal._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_constant_relational_pattern_expression",
    "description": "_The relational pattern expression must be a constant._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the value in a relational\npattern expression isn't a constant expression.\n\n## Example\n\nThe following code produces this diagnostic because the operand of the `>`\noperator, `a`, isn't a constant:\n\n```dart\nfinal a = 0;\n\nvoid f(int x) {\n  if (x case > [!a!]) {}\n}\n```\n\n## Common fixes\n\nReplace the value with a constant expression:\n\n```dart\nconst a = 0;\n\nvoid f(int x) {\n  if (x case > a) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_constant_set_element",
    "description": "_The values in a const set literal must be constants._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constant set literal contains\nan element that isn't a compile-time constant.\n\n## Example\n\nThe following code produces this diagnostic because `i` isn't a constant:\n\n```dart\nvar i = 0;\n\nvar s = const {[!i!]};\n```\n\n## Common fixes\n\nIf the element can be changed to be a constant, then change it:\n\n```dart\nconst i = 0;\n\nvar s = const {i};\n```\n\nIf the element can't be a constant, then remove the keyword `const`:\n\n```dart\nvar i = 0;\n\nvar s = {i};\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_constant_type_argument",
    "description": "_The type arguments to '{0}' must be known at compile time, so they can't be type parameters._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the type arguments to a method\nare required to be known at compile time, but a type parameter, whose\nvalue can't be known at compile time, is used as a type argument.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the type argument to\n`Pointer.asFunction` must be known at compile time, but the type parameter\n`R`, which isn't known at compile time, is being used as the type\nargument:\n\n```dart\nimport 'dart:ffi';\n\ntypedef T = int Function(int);\n\nclass C<R extends T> {\n  void m(Pointer<NativeFunction<T>> p) {\n    p.asFunction<[!R!]>();\n  }\n}\n```\n\n## Common fixes\n\nRemove any uses of type parameters:\n\n```dart\nimport 'dart:ffi';\n\nclass C {\n  void m(Pointer<NativeFunction<Int64 Function(Int64)>> p) {\n    p.asFunction<int Function(int)>();\n  }\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_constructor_factory",
    "description": "_Only a constructor can be declared to be a factory._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_const_argument_for_const_parameter",
    "description": "_Argument '{0}' must be a constant._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a parameter is\nannotated with the [`mustBeConst`][meta-mustBeConst] annotation and\nthe corresponding argument is not a constant expression.\n\n## Example\n\nThe following code produces this diagnostic on the invocation of\nthe function `f` because the value of the argument passed to the\nfunction `g` isn't a constant:\n\n```dart\nimport 'package:meta/meta.dart' show mustBeConst;\n\nint f(int value) => g([!value!]);\n\nint g(@mustBeConst int value) => value + 1;\n```\n\n## Common fixes\n\nIf a suitable constant is available to use, then replace the argument\nwith a constant:\n\n```dart\nimport 'package:meta/meta.dart' show mustBeConst;\n\nconst v = 3;\n\nint f() => g(v);\n\nint g(@mustBeConst int value) => value + 1;\n```\n\n[meta-mustBeConst]: https://pub.dev/documentation/meta/latest/meta/mustBeConst-constant.html\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_const_call_to_literal_constructor",
    "description": "_This instance creation must be 'const', because the {0} constructor is marked as '@literal'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor that has the\n[`literal`][meta-literal] annotation is invoked without using the `const`\nkeyword, but all of the arguments to the constructor are constants. The\nannotation indicates that the constructor should be used to create a\nconstant value whenever possible.\n\n## Example\n\nThe following code produces this diagnostic:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass C {\n  @literal\n  const C();\n}\n\nC f() => [!C()!];\n```\n\n## Common fixes\n\nAdd the keyword `const` before the constructor invocation:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass C {\n  @literal\n  const C();\n}\n\nvoid f() => const C();\n```\n\n[meta-literal]: https://pub.dev/documentation/meta/latest/meta/literal-constant.html\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_const_generative_enum_constructor",
    "description": "_Generative enum constructors must be 'const'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an enum declaration contains a\ngenerative constructor that isn't marked as `const`.\n\n## Example\n\nThe following code produces this diagnostic because the constructor in `E`\nisn't marked as being `const`:\n\n```dart\nenum E {\n  e;\n\n  [!E!]();\n}\n```\n\n## Common fixes\n\nAdd the `const` keyword before the constructor:\n\n```dart\nenum E {\n  e;\n\n  const E();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_const_map_as_expression_statement",
    "description": "_A non-constant map or set literal without type arguments can't be used as an expression statement._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_covariant_type_parameter_position_in_representation_type",
    "description": "_An extension type parameter can't be used in a non-covariant position of its representation type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a type parameter of an\nextension type is used in a non-covariant position in the representation\ntype of that extension type.\n\n## Example\n\nThe following code produces this diagnostic because the type parameter `T`\nis used as a parameter type in the function type `void Function(T)`, and\nparameters are not covariant:\n\n```dart\nextension type A<[!T!]>(void Function(T) f) {}\n```\n\n## Common fixes\n\nRemove the use of the type parameter:\n\n```dart\nextension type A(void Function(String) f) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_exhaustive_switch_expression",
    "description": "_The enum '{0}' isn't exhaustively matched by the switch cases because some of the enum constants are private._\n\n_The type '{0}' isn't exhaustively matched by the switch cases since it doesn't match the pattern '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `switch` expression is\nmissing a case for one or more of the possible values that could flow\nthrough it.\n\n## Example\n\nThe following code produces this diagnostic because the switch expression\ndoesn't have a case for the value `E.three`:\n\n```dart\nenum E { one, two, three }\n\nString f(E e) => [!switch!] (e) {\n    E.one => 'one',\n    E.two => 'two',\n  };\n```\n\n## Common fixes\n\nIf the missing values are distinctly meaningful to the switch expression,\nthen add a case for each of the values missing a match:\n\n```dart\nenum E { one, two, three }\n\nString f(E e) => switch (e) {\n    E.one => 'one',\n    E.two => 'two',\n    E.three => 'three',\n  };\n```\n\nIf the missing values don't need to be matched, then add a wildcard\npattern that returns a simple default:\n\n```dart\nenum E { one, two, three }\n\nString f(E e) => switch (e) {\n    E.one => 'one',\n    E.two => 'two',\n    _ => 'unknown',\n  };\n```\n\nBe aware that a wildcard pattern will handle any values added to the type\nin the future. You will lose the ability to have the compiler warn you if\nthe `switch` needs to be updated to account for newly added types.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_exhaustive_switch_statement",
    "description": "_The enum '{0}' isn't exhaustively matched by the switch cases because some of the enum constants are private._\n\n_The type '{0}' isn't exhaustively matched by the switch cases since it doesn't match the pattern '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `switch` statement switching\nover an exhaustive type is missing a case for one or more of the possible\nvalues that could flow through it.\n\n## Example\n\nThe following code produces this diagnostic because the switch statement\ndoesn't have a case for the value `E.three`, and `E` is an exhaustive\ntype:\n\n```dart\nenum E { one, two, three }\n\nvoid f(E e) {\n  [!switch!] (e) {\n    case E.one:\n    case E.two:\n  }\n}\n```\n\n## Common fixes\n\nAdd a case for each of the constants that aren't currently being matched:\n\n```dart\nenum E { one, two, three }\n\nvoid f(E e) {\n  switch (e) {\n    case E.one:\n    case E.two:\n      break;\n    case E.three:\n  }\n}\n```\n\nIf the missing values don't need to be matched, then add a `default`\nclause or a wildcard pattern:\n\n```dart\nenum E { one, two, three }\n\nvoid f(E e) {\n  switch (e) {\n    case E.one:\n    case E.two:\n      break;\n    default:\n  }\n}\n```\n\nBut be aware that adding a `default` clause or wildcard pattern will cause\nany future values of the exhaustive type to also be handled, so you will\nhave lost the ability for the compiler to warn you if the `switch` needs\nto be updated.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_final_field_in_enum",
    "description": "_Enums can only declare final fields._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an instance field in an enum\nisn't marked as `final`.\n\n## Example\n\nThe following code produces this diagnostic because the field `f` isn't a\nfinal field:\n\n```dart\nenum E {\n  c;\n\n  int [!f!] = 0;\n}\n```\n\n## Common fixes\n\nIf the field must be defined for the enum, then mark the field as being\n`final`:\n\n```dart\nenum E {\n  c;\n\n  final int f = 0;\n}\n```\n\nIf the field can be removed, then remove it:\n\n```dart\nenum E {\n  c\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_generative_constructor",
    "description": "_The generative constructor '{0}' is expected, but a factory was found._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the initializer list of a\nconstructor invokes a constructor from the superclass, and the invoked\nconstructor is a factory constructor. Only a generative constructor can be\ninvoked in the initializer list.\n\n## Example\n\nThe following code produces this diagnostic because the invocation of the\nconstructor `super.one()` is invoking a factory constructor:\n\n```dart\nclass A {\n  factory A.one() = B;\n  A.two();\n}\n\nclass B extends A {\n  B() : [!super.one()!];\n}\n```\n\n## Common fixes\n\nChange the super invocation to invoke a generative constructor:\n\n```dart\nclass A {\n  factory A.one() = B;\n  A.two();\n}\n\nclass B extends A {\n  B() : super.two();\n}\n```\n\nIf the generative constructor is the unnamed constructor, and if there are\nno arguments being passed to it, then you can remove the super invocation.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_generative_implicit_constructor",
    "description": "_The unnamed constructor of superclass '{0}' (called by the default constructor of '{1}') must be a generative constructor, but factory found._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class has an implicit\ngenerative constructor and the superclass has an explicit unnamed factory\nconstructor. The implicit constructor in the subclass implicitly invokes\nthe unnamed constructor in the superclass, but generative constructors can\nonly invoke another generative constructor, not a factory constructor.\n\n## Example\n\nThe following code produces this diagnostic because the implicit\nconstructor in `B` invokes the unnamed constructor in `A`, but the\nconstructor in `A` is a factory constructor, when a generative constructor\nis required:\n\n```dart\nclass A {\n  factory A() => throw 0;\n  A.named();\n}\n\nclass [!B!] extends A {}\n```\n\n## Common fixes\n\nIf the unnamed constructor in the superclass can be a generative\nconstructor, then change it to be a generative constructor:\n\n```dart\nclass A {\n  A();\n  A.named();\n}\n\nclass B extends A { }\n```\n\nIf the unnamed constructor can't be a generative constructor and there are\nother generative constructors in the superclass, then explicitly invoke\none of them:\n\n```dart\nclass A {\n  factory A() => throw 0;\n  A.named();\n}\n\nclass B extends A {\n  B() : super.named();\n}\n```\n\nIf there are no generative constructors that can be used and none can be\nadded, then implement the superclass rather than extending it:\n\n```dart\nclass A {\n  factory A() => throw 0;\n  A.named();\n}\n\nclass B implements A {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_identifier_library_name",
    "description": "_The name of a library must be an identifier._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_native_function_type_argument_to_pointer",
    "description": "_Can't invoke 'asFunction' because the function signature '{0}' for the pointer isn't a valid C function signature._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the method `asFunction` is\ninvoked on a pointer to a native function, but the signature of the native\nfunction isn't a valid C function signature.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because function signature\nassociated with the pointer `p` (`FNative`) isn't a valid C function\nsignature:\n\n```dart\nimport 'dart:ffi';\n\ntypedef FNative = int Function(int);\ntypedef F = int Function(int);\n\nclass C {\n  void f(Pointer<NativeFunction<FNative>> p) {\n    p.asFunction<[!F!]>();\n  }\n}\n```\n\n## Common fixes\n\nMake the `NativeFunction` signature a valid C signature:\n\n```dart\nimport 'dart:ffi';\n\ntypedef FNative = Int8 Function(Int8);\ntypedef F = int Function(int);\n\nclass C {\n  void f(Pointer<NativeFunction<FNative>> p) {\n    p.asFunction<F>();\n  }\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_nullable_equals_parameter",
    "description": "_The parameter type of '==' operators should be non-nullable._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an override of the operator\n`==` has a parameter whose type is nullable. The language spec makes it\nimpossible for the argument of the method to be `null`, and the\nparameter's type should reflect that.\n\n## Example\n\nThe following code produces this diagnostic because the implementation of\nthe operator `==` in `C` :\n\n```dart\nclass C {\n  @override\n  bool operator [!==!](Object? other) => false;\n}\n```\n\n## Common fixes\n\nMake the parameter type be non-nullable:\n\n```dart\nclass C {\n  @override\n  bool operator ==(Object other) => false;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_part_of_directive_in_part",
    "description": "_The part-of directive must be the only directive in a part._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_positive_array_dimension",
    "description": "_Array dimensions must be positive numbers._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a dimension given in an `Array`\nannotation is less than or equal to zero (`0`).\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because an array dimension of\n`-8` was provided:\n\n```dart\nimport 'dart:ffi';\n\nfinal class MyStruct extends Struct {\n  @Array([!-8!])\n  external Array<Uint8> a0;\n}\n```\n\n## Common fixes\n\nChange the dimension to be a positive integer:\n\n```dart\nimport 'dart:ffi';\n\nfinal class MyStruct extends Struct {\n  @Array(8)\n  external Array<Uint8> a0;\n}\n```\n\nIf this is a variable length inline array, change the annotation to\n`Array.variable()`:\n\n```dart\nimport 'dart:ffi';\n\nfinal class MyStruct extends Struct {\n  @Array.variable()\n  external Array<Uint8> a0;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_redirecting_generative_constructor_with_primary",
    "description": "_Classes with primary constructors can't have non-redirecting generative constructors._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_resizable_activity",
    "description": "_The `<activity>` element should be allowed to be resized to allow users to take advantage of the multi-window environment on Chrome OS_",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_sized_type_argument",
    "description": "_The type '{0}' isn't a valid type argument for '{1}'. The type argument must be a native integer, 'Float', 'Double', 'Pointer', or subtype of 'Struct', 'Union', or 'AbiSpecificInteger'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the type argument for the class\n`Array` isn't one of the valid types: either a native integer, `Float`,\n`Double`, `Pointer`, or subtype of `Struct`, `Union`, or\n`AbiSpecificInteger`.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the type argument to\n`Array` is `Void`, and `Void` isn't one of the valid types:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Array(8)\n  external Array<[!Void!]> a0;\n}\n```\n\n## Common fixes\n\nChange the type argument to one of the valid types:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Array(8)\n  external Array<Uint8> a0;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_string_literal_as_uri",
    "description": "_The URI must be a string literal._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_sync_factory",
    "description": "_Factory bodies can't use 'async', 'async*', or 'sync*'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the body of a factory\nconstructor is marked with `async`, `async*`, or `sync*`. All constructors,\nincluding factory constructors, are required to return an instance of the\nclass in which they're declared, not a `Future`, `Stream`, or `Iterator`.\n\n## Example\n\nThe following code produces this diagnostic because the body of the factory\nconstructor is marked with `async`:\n\n```dart\nclass C {\n  factory C() [!async!] {\n    return C._();\n  }\n  C._();\n}\n```\n\n## Common fixes\n\nIf the member must be declared as a factory constructor, then remove the\nkeyword appearing before the body:\n\n```dart\nclass C {\n  factory C() {\n    return C._();\n  }\n  C._();\n}\n```\n\nIf the member must return something other than an instance of the enclosing\nclass, then make the member a static method:\n\n```dart\nclass C {\n  static Future<C> m() async {\n    return C._();\n  }\n  C._();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_type_as_type_argument",
    "description": "_The name '{0}' isn't a type, so it can't be used as a type argument._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an identifier that isn't a type\nis used as a type argument.\n\n## Example\n\nThe following code produces this diagnostic because `x` is a variable, not\na type:\n\n```dart\nvar x = 0;\nList<[!x!]> xList = [];\n```\n\n## Common fixes\n\nChange the type argument to be a type:\n\n```dart\nvar x = 0;\nList<int> xList = [];\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_type_in_catch_clause",
    "description": "_The name '{0}' isn't a type and can't be used in an on-catch clause._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the identifier following the\n`on` in a `catch` clause is defined to be something other than a type.\n\n## Example\n\nThe following code produces this diagnostic because `f` is a function, not\na type:\n\n```dart\nvoid f() {\n  try {\n    // ...\n  } on [!f!] {\n    // ...\n  }\n}\n```\n\n## Common fixes\n\nChange the name to the type of object that should be caught:\n\n```dart\nvoid f() {\n  try {\n    // ...\n  } on FormatException {\n    // ...\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_user_definable_operator",
    "description": "_The operator '{0}' isn't user definable._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_void_return_for_operator",
    "description": "_The return type of the operator []= must be 'void'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a declaration of the operator\n`[]=` has a return type other than `void`.\n\n## Example\n\nThe following code produces this diagnostic because the declaration of the\noperator `[]=` has a return type of `int`:\n\n```dart\nclass C {\n  [!int!] operator []=(int index, int value) => 0;\n}\n```\n\n## Common fixes\n\nChange the return type to `void`:\n\n```dart\nclass C {\n  void operator []=(int index, int value) => 0;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "non_void_return_for_setter",
    "description": "_The return type of the setter must be 'void' or absent._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a setter is defined with a\nreturn type other than `void`.\n\n## Example\n\nThe following code produces this diagnostic because the setter `p` has a\nreturn type of `int`:\n\n```dart\nclass C {\n  [!int!] set p(int i) => 0;\n}\n```\n\n## Common fixes\n\nChange the return type to `void` or omit the return type:\n\n```dart\nclass C {\n  set p(int i) => 0;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "normal_before_optional_parameters",
    "description": "_Normal parameters must occur before optional parameters._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "not_assigned_potentially_non_nullable_local_variable",
    "description": "_The non-nullable local variable '{0}' must be assigned before it can be used._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a local variable is referenced\nand has all these characteristics:\n- Has a type that's [potentially non-nullable][].\n- Doesn't have an initializer.\n- Isn't marked as `late`.\n- The analyzer can't prove that the local variable will be assigned before\n  the reference based on the specification of [definite assignment][].\n\n## Examples\n\nThe following code produces this diagnostic because `x` can't have a value\nof `null`, but is referenced before a value was assigned to it:\n\n```dart\nString f() {\n  int x;\n  return [!x!].toString();\n}\n```\n\nThe following code produces this diagnostic because the assignment to `x`\nmight not be executed, so it might have a value of `null`:\n\n```dart\nint g(bool b) {\n  int x;\n  if (b) {\n    x = 1;\n  }\n  return [!x!] * 2;\n}\n```\n\nThe following code produces this diagnostic because the analyzer can't\nprove, based on definite assignment analysis, that `x` won't be referenced\nwithout having a value assigned to it:\n\n```dart\nint h(bool b) {\n  int x;\n  if (b) {\n    x = 1;\n  }\n  if (b) {\n    return [!x!] * 2;\n  }\n  return 0;\n}\n```\n\n## Common fixes\n\nIf `null` is a valid value, then make the variable nullable:\n\n```dart\nString f() {\n  int? x;\n  return x!.toString();\n}\n```\n\nIf `null` isn't a valid value, and there's a reasonable default value, then\nadd an initializer:\n\n```dart\nint g(bool b) {\n  int x = 2;\n  if (b) {\n    x = 1;\n  }\n  return x * 2;\n}\n```\n\nOtherwise, ensure that a value was assigned on every possible code path\nbefore the value is accessed:\n\n```dart\nint g(bool b) {\n  int x;\n  if (b) {\n    x = 1;\n  } else {\n    x = 2;\n  }\n  return x * 2;\n}\n```\n\nYou can also mark the variable as `late`, which removes the diagnostic, but\nif the variable isn't assigned a value before it's accessed, then it\nresults in an exception being thrown at runtime. This approach should only\nbe used if you're sure that the variable will always be assigned, even\nthough the analyzer can't prove it based on definite assignment analysis.\n\n```dart\nint h(bool b) {\n  late int x;\n  if (b) {\n    x = 1;\n  }\n  if (b) {\n    return x * 2;\n  }\n  return 0;\n}\n```\n\n[definite assignment]: /resources/glossary#definite-assignment\n[potentially non-nullable]: /resources/glossary#potentially-non-nullable\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "not_a_type",
    "description": "_{0} isn't a type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a name is used as a type but\ndeclared to be something other than a type.\n\n## Example\n\nThe following code produces this diagnostic because `f` is a function:\n\n```dart\nf() {}\ng([!f!] v) {}\n```\n\n## Common fixes\n\nReplace the name with the name of a type.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "not_binary_operator",
    "description": "_'{0}' isn't a binary operator._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an operator that can only be\nused as a unary operator is used as a binary operator.\n\n## Example\n\nThe following code produces this diagnostic because the operator `~` can\nonly be used as a unary operator:\n\n```dart\nvar a = 5 [!~!] 3;\n```\n\n## Common fixes\n\nReplace the operator with the correct binary operator:\n\n```dart\nvar a = 5 - 3;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "not_enough_positional_arguments",
    "description": "_1 positional argument expected by '{0}', but 0 found._\n\n_1 positional argument expected, but 0 found._\n\n_{0} positional arguments expected by '{1}', but {2} found._\n\n_{0} positional arguments expected, but {1} found._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a method or function invocation\nhas fewer positional arguments than the number of required positional\nparameters.\n\n## Example\n\nThe following code produces this diagnostic because `f` declares two\nrequired parameters, but only one argument is provided:\n\n```dart\nvoid f(int a, int b) {}\nvoid g() {\n  f(0[!)!];\n}\n```\n\n## Common fixes\n\nAdd arguments corresponding to the remaining parameters:\n\n```dart\nvoid f(int a, int b) {}\nvoid g() {\n  f(0, 1);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "not_initialized_non_nullable_instance_field",
    "description": "_Non-nullable instance field '{0}' must be initialized._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a field is declared and has all\nthese characteristics:\n- Has a type that's [potentially non-nullable][]\n- Doesn't have an initializer\n- Isn't marked as `late`\n\n## Examples\n\nThe following code produces this diagnostic because `x` is implicitly\ninitialized to `null` when it isn't allowed to be `null`:\n\n```dart\nclass C {\n  int [!x!];\n}\n```\n\nSimilarly, the following code produces this diagnostic because `x` is\nimplicitly initialized to `null`, when it isn't allowed to be `null`, by\none of the constructors, even though it's initialized by other\nconstructors:\n\n```dart\nclass C {\n  int x;\n\n  C(this.x);\n\n  [!C.n!]();\n}\n```\n\n## Common fixes\n\nIf there's a reasonable default value for the field that's the same for all\ninstances, then add an initializer expression:\n\n```dart\nclass C {\n  int x = 0;\n}\n```\n\nIf the value of the field should be provided when an instance is created,\nthen add a constructor that sets the value of the field or update an\nexisting constructor:\n\n```dart\nclass C {\n  int x;\n\n  C(this.x);\n}\n```\n\nYou can also mark the field as `late`, which removes the diagnostic, but if\nthe field isn't assigned a value before it's accessed, then it results in\nan exception being thrown at runtime. This approach should only be used if\nyou're sure that the field will always be assigned before it's referenced.\n\n```dart\nclass C {\n  late int x;\n}\n```\n\n[potentially non-nullable]: /resources/glossary#potentially-non-nullable\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "not_initialized_non_nullable_variable",
    "description": "_The non-nullable variable '{0}' must be initialized._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a static field or top-level\nvariable has a type that's non-nullable and doesn't have an initializer.\nFields and variables that don't have an initializer are normally\ninitialized to `null`, but the type of the field or variable doesn't allow\nit to be set to `null`, so an explicit initializer must be provided.\n\n## Examples\n\nThe following code produces this diagnostic because the field `f` can't be\ninitialized to `null`:\n\n```dart\nclass C {\n  static int [!f!];\n}\n```\n\nSimilarly, the following code produces this diagnostic because the\ntop-level variable `v` can't be initialized to `null`:\n\n```dart\nint [!v!];\n```\n\n## Common fixes\n\nIf the field or variable can't be initialized to `null`, then add an\ninitializer that sets it to a non-null value:\n\n```dart\nclass C {\n  static int f = 0;\n}\n```\n\nIf the field or variable should be initialized to `null`, then change the\ntype to be nullable:\n\n```dart\nint? v;\n```\n\nIf the field or variable can't be initialized in the declaration but will\nalways be initialized before it's referenced, then mark it as being `late`:\n\n```dart\nclass C {\n  static late int f;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "not_instantiated_bound",
    "description": "_Type parameter bound types must be instantiated._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "not_iterable_spread",
    "description": "_Spread elements in list or set literals must implement 'Iterable'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the static type of the\nexpression of a spread element that appears in either a list literal or a\nset literal doesn't implement the type `Iterable`.\n\n## Example\n\nThe following code produces this diagnostic:\n\n```dart\nvar m = <String, int>{'a': 0, 'b': 1};\nvar s = <String>{...[!m!]};\n```\n\n## Common fixes\n\nThe most common fix is to replace the expression with one that produces an\niterable object:\n\n```dart\nvar m = <String, int>{'a': 0, 'b': 1};\nvar s = <String>{...m.keys};\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "not_map_spread",
    "description": "_Spread elements in map literals must implement 'Map'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the static type of the\nexpression of a spread element that appears in a map literal doesn't\nimplement the type `Map`.\n\n## Example\n\nThe following code produces this diagnostic because `l` isn't a `Map`:\n\n```dart\nvar l =  <String>['a', 'b'];\nvar m = <int, String>{...[!l!]};\n```\n\n## Common fixes\n\nThe most common fix is to replace the expression with one that produces a\nmap:\n\n```dart\nvar l =  <String>['a', 'b'];\nvar m = <int, String>{...l.asMap()};\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "not_null_aware_null_spread",
    "description": "_The Null-typed expression can't be used with a non-null-aware spread._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "no_annotation_constructor_arguments",
    "description": "_Annotation creation must have arguments._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an annotation consists of a\nsingle identifier, but that identifier is the name of a class rather than a\nvariable. To create an instance of the class, the identifier must be\nfollowed by an argument list.\n\n## Example\n\nThe following code produces this diagnostic because `C` is a class, and a\nclass can't be used as an annotation without invoking a `const` constructor\nfrom the class:\n\n```dart\nclass C {\n  const C();\n}\n\n[!@C!]\nvar x;\n```\n\n## Common fixes\n\nAdd the missing argument list:\n\n```dart\nclass C {\n  const C();\n}\n\n@C()\nvar x;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "no_combined_super_signature",
    "description": "_Can't infer missing types in '{0}' from overridden methods: {1}._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when there is a method declaration\nfor which one or more types needs to be inferred, and those types can't be\ninferred because none of the overridden methods has a function type that is\na supertype of all the other overridden methods, as specified by\n[override inference][].\n\n## Example\n\nThe following code produces this diagnostic because the method `m` declared\nin the class `C` is missing both the return type and the type of the\nparameter `a`, and neither of the missing types can be inferred for it:\n\n```dart\nabstract class A {\n  A m(String a);\n}\n\nabstract class B {\n  B m(int a);\n}\n\nabstract class C implements A, B {\n  [!m!](a);\n}\n```\n\nIn this example, override inference can't be performed because the\noverridden methods are incompatible in these ways:\n- Neither parameter type (`String` and `int`) is a supertype of the other.\n- Neither return type is a subtype of the other.\n\n## Common fixes\n\nIf possible, add types to the method in the subclass that are consistent\nwith the types from all the overridden methods:\n\n```dart\nabstract class A {\n  A m(String a);\n}\n\nabstract class B {\n  B m(int a);\n}\n\nabstract class C implements A, B {\n  C m(Object a);\n}\n```\n\n[override inference]: /resources/glossary#override-inference\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "no_default_super_constructor",
    "description": "_The superclass '{0}' doesn't have a zero argument constructor._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "no_generative_constructors_in_superclass",
    "description": "_The class '{0}' can't extend '{1}' because '{1}' only has factory constructors (no generative constructors), and '{0}' has at least one generative constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class that has at least one\ngenerative constructor (whether explicit or implicit) has a superclass\nthat doesn't have any generative constructors. Every generative\nconstructor, except the one defined in `Object`, invokes, either\nexplicitly or implicitly, one of the generative constructors from its\nsuperclass.\n\n## Example\n\nThe following code produces this diagnostic because the class `B` has an\nimplicit generative constructor that can't invoke a generative constructor\nfrom `A` because `A` doesn't have any generative constructors:\n\n```dart\nclass A {\n  factory A.none() => throw '';\n}\n\nclass B extends [!A!] {}\n```\n\n## Common fixes\n\nIf the superclass should have a generative constructor, then add one:\n\n```dart\nclass A {\n  A();\n  factory A.none() => throw '';\n}\n\nclass B extends A {}\n```\n\nIf the subclass shouldn't have a generative constructor, then remove it by\nadding a factory constructor:\n\n```dart\nclass A {\n  factory A.none() => throw '';\n}\n\nclass B extends A {\n  factory B.none() => throw '';\n}\n```\n\nIf the subclass must have a generative constructor but the superclass\ncan't have one, then implement the superclass instead:\n\n```dart\nclass A {\n  factory A.none() => throw '';\n}\n\nclass B implements A {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "no_touchscreen_feature",
    "description": "_The default \"android.hardware.touchscreen\" needs to be optional for Chrome OS._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "nullable_type_in_catch_clause",
    "description": "_A potentially nullable type can't be used in an 'on' clause because it isn't valid to throw a nullable expression._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the type following `on` in a\n`catch` clause is a nullable type. It isn't valid to specify a nullable\ntype because it isn't possible to catch `null` (because it's a runtime\nerror to throw `null`).\n\n## Example\n\nThe following code produces this diagnostic because the exception type is\nspecified to allow `null` when `null` can't be thrown:\n\n```dart\nvoid f() {\n  try {\n    // ...\n  } on [!FormatException?!] {\n  }\n}\n```\n\n## Common fixes\n\nRemove the question mark from the type:\n\n```dart\nvoid f() {\n  try {\n    // ...\n  } on FormatException {\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "nullable_type_in_extends_clause",
    "description": "_A class can't extend a nullable type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class declaration uses an\n`extends` clause to specify a superclass, and the superclass is followed by\na `?`.\n\nIt isn't valid to specify a nullable superclass because doing so would have\nno meaning; it wouldn't change either the interface or implementation being\ninherited by the class containing the `extends` clause.\n\nNote, however, that it _is_ valid to use a nullable type as a type argument\nto the superclass, such as `class A extends B<C?> {}`.\n\n## Example\n\nThe following code produces this diagnostic because `A?` is a nullable\ntype, and nullable types can't be used in an `extends` clause:\n\n```dart\nclass A {}\nclass B extends [!A?!] {}\n```\n\n## Common fixes\n\nRemove the question mark from the type:\n\n```dart\nclass A {}\nclass B extends A {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "nullable_type_in_implements_clause",
    "description": "_A class, mixin, or extension type can't implement a nullable type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class, mixin, or\nextension type declaration has an `implements` clause, and an\ninterface is followed by a `?`.\n\nIt isn't valid to specify a nullable interface because doing so would have\nno meaning; it wouldn't change the interface being inherited by the class\ncontaining the `implements` clause.\n\nNote, however, that it _is_ valid to use a nullable type as a type argument\nto the interface, such as `class A implements B<C?> {}`.\n\n\n## Example\n\nThe following code produces this diagnostic because `A?` is a nullable\ntype, and nullable types can't be used in an `implements` clause:\n\n```dart\nclass A {}\nclass B implements [!A?!] {}\n```\n\n## Common fixes\n\nRemove the question mark from the type:\n\n```dart\nclass A {}\nclass B implements A {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "nullable_type_in_on_clause",
    "description": "_A mixin can't have a nullable type as a superclass constraint._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a mixin declaration uses an `on`\nclause to specify a superclass constraint, and the class that's specified\nis followed by a `?`.\n\nIt isn't valid to specify a nullable superclass constraint because doing so\nwould have no meaning; it wouldn't change the interface being depended on\nby the mixin containing the `on` clause.\n\nNote, however, that it _is_ valid to use a nullable type as a type argument\nto the superclass constraint, such as `mixin A on B<C?> {}`.\n\n\n## Example\n\nThe following code produces this diagnostic because `A?` is a nullable type\nand nullable types can't be used in an `on` clause:\n\n```dart\nclass C {}\nmixin M on [!C?!] {}\n```\n\n## Common fixes\n\nRemove the question mark from the type:\n\n```dart\nclass C {}\nmixin M on C {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "nullable_type_in_with_clause",
    "description": "_A class or mixin can't mix in a nullable type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class or mixin declaration has\na `with` clause, and a mixin is followed by a `?`.\n\nIt isn't valid to specify a nullable mixin because doing so would have no\nmeaning; it wouldn't change either the interface or implementation being\ninherited by the class containing the `with` clause.\n\nNote, however, that it _is_ valid to use a nullable type as a type argument\nto the mixin, such as `class A with B<C?> {}`.\n\n## Example\n\nThe following code produces this diagnostic because `A?` is a nullable\ntype, and nullable types can't be used in a `with` clause:\n\n```dart\nmixin M {}\nclass C with [!M?!] {}\n```\n\n## Common fixes\n\nRemove the question mark from the type:\n\n```dart\nmixin M {}\nclass C with M {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "null_argument_to_non_null_type",
    "description": "_'{0}' shouldn't be called with a 'null' argument for the non-nullable type argument '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when `null` is passed to either the\nconstructor `Future.value` or the method `Completer.complete` when the type\nargument used to create the instance was non-nullable. Even though the type\nsystem can't express this restriction, passing in a `null` results in a\nruntime exception.\n\n## Example\n\nThe following code produces this diagnostic because `null` is being passed\nto the constructor `Future.value` even though the type argument is the\nnon-nullable type `String`:\n\n```dart\nFuture<String> f() {\n  return Future.value([!null!]);\n}\n```\n\n## Common fixes\n\nPass in a non-null value:\n\n```dart\nFuture<String> f() {\n  return Future.value('');\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "null_aware_cascade_out_of_order",
    "description": "_The '?..' cascade operator must be first in the cascade sequence._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "null_check_always_fails",
    "description": "_This null-check will always throw an exception because the expression will always evaluate to 'null'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the null check operator (`!`)\nis used on an expression whose value can only be `null`. In such a case\nthe operator always throws an exception, which likely isn't the intended\nbehavior.\n\n## Example\n\nThe following code produces this diagnostic because the function `g` will\nalways return `null`, which means that the null check in `f` will always\nthrow:\n\n```dart\nvoid f() {\n  [!g()!!];\n}\n\nNull g() => null;\n```\n\n## Common fixes\n\nIf you intend to always throw an exception, then replace the null check\nwith an explicit `throw` expression to make the intent more clear:\n\n```dart\nvoid f() {\n  g();\n  throw TypeError();\n}\n\nNull g() => null;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "object_cannot_extend_another_class",
    "description": "_The class 'Object' can't extend any other class._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "obsolete_colon_for_default_value",
    "description": "_Using a colon as the separator before a default value is no longer supported._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a colon (`:`) is used as the\nseparator before the default value of an optional named parameter.\nWhile this syntax used to be allowed, it was removed in favor of\nusing an equal sign (`=`).\n\n## Example\n\nThe following code produces this diagnostic because a colon is being used\nbefore the default value of the optional parameter `i`:\n\n```dart\nvoid f({int i [!:!] 0}) {}\n```\n\n## Common fixes\n\nReplace the colon with an equal sign:\n\n```dart\nvoid f({int i = 0}) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "on_repeated",
    "description": "_The type '{0}' can be included in the superclass constraints only once._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the same type is listed in the\nsuperclass constraints of a mixin multiple times.\n\n## Example\n\nThe following code produces this diagnostic because `A` is included twice\nin the superclass constraints for `M`:\n\n```dart\nmixin M on A, [!A!] {\n}\n\nclass A {}\nclass B {}\n```\n\n## Common fixes\n\nIf a different type should be included in the superclass constraints, then\nreplace one of the occurrences with the other type:\n\n```dart\nmixin M on A, B {\n}\n\nclass A {}\nclass B {}\n```\n\nIf no other type was intended, then remove the repeated type name:\n\n```dart\nmixin M on A {\n}\n\nclass A {}\nclass B {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "optional_parameter_in_operator",
    "description": "_Optional parameters aren't allowed when defining an operator._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when one or more of the parameters in\nan operator declaration are optional.\n\n## Example\n\nThe following code produces this diagnostic because the parameter `other`\nis an optional parameter:\n\n```dart\nclass C {\n  C operator +([[!C? other!]]) => this;\n}\n```\n\n## Common fixes\n\nMake all of the parameters be required parameters:\n\n```dart\nclass C {\n  C operator +(C other) => this;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "out_of_order_clauses",
    "description": "_The '{0}' clause must come before the '{1}' clause._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "override_on_non_overriding_member",
    "description": "_The field doesn't override an inherited getter or setter._\n\n_The getter doesn't override an inherited getter._\n\n_The method doesn't override an inherited method._\n\n_The setter doesn't override an inherited setter._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class member is annotated with\nthe `@override` annotation, but the member isn't declared in any of the\nsupertypes of the class.\n\n## Example\n\nThe following code produces this diagnostic because `m` isn't declared in\nany of the supertypes of `C`:\n\n```dart\nclass C {\n  @override\n  String [!m!]() => '';\n}\n```\n\n## Common fixes\n\nIf the member is intended to override a member with a different name, then\nupdate the member to have the same name:\n\n```dart\nclass C {\n  @override\n  String toString() => '';\n}\n```\n\nIf the member is intended to override a member that was removed from the\nsuperclass, then consider removing the member from the subclass.\n\nIf the member can't be removed, then remove the annotation.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "packed_annotation",
    "description": "_Structs must have at most one 'Packed' annotation._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a subclass of `Struct` has more\nthan one `Packed` annotation.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the class `C`, which\nis a subclass of `Struct`, has two `Packed` annotations:\n\n```dart\nimport 'dart:ffi';\n\n@Packed(1)\n[!@Packed(1)!]\nfinal class C extends Struct {\n  external Pointer<Uint8> notEmpty;\n}\n```\n\n## Common fixes\n\nRemove all but one of the annotations:\n\n```dart\nimport 'dart:ffi';\n\n@Packed(1)\nfinal class C extends Struct {\n  external Pointer<Uint8> notEmpty;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "packed_annotation_alignment",
    "description": "_Only packing to 1, 2, 4, 8, and 16 bytes is supported._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the argument to the `Packed`\nannotation isn't one of the allowed values: 1, 2, 4, 8, or 16.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the argument to the\n`Packed` annotation (`3`) isn't one of the allowed values:\n\n```dart\nimport 'dart:ffi';\n\n@Packed([!3!])\nfinal class C extends Struct {\n  external Pointer<Uint8> notEmpty;\n}\n```\n\n## Common fixes\n\nChange the alignment to be one of the allowed values:\n\n```dart\nimport 'dart:ffi';\n\n@Packed(4)\nfinal class C extends Struct {\n  external Pointer<Uint8> notEmpty;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "parse_error",
    "description": "_{0}_",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the contents of an analysis\noptions file isn't valid YAML.\n\n## Example\n\nThe following code produces this diagnostic because the `analyzer` section\nhas two `enable-experiment` keys:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nanalyzer:\n  enable-experiment:\n    - augmentations\n  [!enable-experiment!]:\n    - dot-shorthands\n```\n\n## Common fixes\n\nCorrect the file to be valid YAML:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nanalyzer:\n  enable-experiment:\n    - augmentations\n    - dot-shorthands\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "part_of_different_library",
    "description": "_Expected this library to be part of '{0}', not '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a library attempts to include a\nfile as a part of itself when the other file is a part of a different\nlibrary.\n\n## Example\n\nGiven a file `part.dart` containing\n\n```dart\npart of 'library.dart';\n```\n\nThe following code, in any file other than `library.dart`, produces this\ndiagnostic because it attempts to include `part.dart` as a part of itself\nwhen `part.dart` is a part of a different library:\n\n```dart\npart [!'package:a/part.dart'!];\n```\n\n## Common fixes\n\nIf the library should be using a different file as a part, then change the\nURI in the part directive to be the URI of the other file.\n\nIf the [part file][] should be a part of this library, then update the URI\n(or library name) in the part-of directive to be the URI (or name) of the\ncorrect library.\n\n[part file]: /resources/glossary#part-file\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "part_of_name",
    "description": "_The 'part of' directive can't use a name with the enhanced-parts feature._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "part_of_non_part",
    "description": "_The included part '{0}' must have a part-of directive._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a part directive is found and\nthe referenced file doesn't have a part-of directive.\n\n## Example\n\nGiven a file `a.dart` containing:\n\n```dart\nclass A {}\n```\n\nThe following code produces this diagnostic because `a.dart` doesn't\ncontain a part-of directive:\n\n```dart\npart [!'a.dart'!];\n```\n\n## Common fixes\n\nIf the referenced file is intended to be a part of another library, then\nadd a part-of directive to the file:\n\n```dart\npart of 'test.dart';\n\nclass A {}\n```\n\nIf the referenced file is intended to be a library, then replace the part\ndirective with an import directive:\n\n```dart\nimport 'a.dart';\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "part_of_unnamed_library",
    "description": "_The library is unnamed. A URI is expected, not a library name '{0}', in the part-of directive._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a library that doesn't have a\n`library` directive (and hence has no name) contains a `part` directive\nand the `part of` directive in the [part file][] uses a name to specify\nthe library that it's a part of.\n\n## Example\n\nGiven a [part file][] named `part_file.dart` containing the following\ncode:\n\n```dart\npart of lib;\n```\n\nThe following code produces this diagnostic because the library including\nthe [part file][] doesn't have a name even though the [part file][] uses a\nname to specify which library it's a part of:\n\n```dart\npart [!'part_file.dart'!];\n```\n\n## Common fixes\n\nChange the `part of` directive in the [part file][] to specify its library\nby URI:\n\n```dart\npart of 'test.dart';\n```\n\n[part file]: /resources/glossary#part-file\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "path_does_not_exist",
    "description": "_The path '{0}' doesn't exist._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a dependency has a `path` key\nreferencing a directory that doesn't exist.\n\n## Example\n\nAssuming that the directory `doesNotExist` doesn't exist, the following\ncode produces this diagnostic because it's listed as the path of a package:\n\n```yaml\nname: example\ndependencies:\n  local_package:\n    path: [!doesNotExist!]\n```\n\n## Common fixes\n\nIf the path is correct, then create a directory at that path.\n\nIf the path isn't correct, then change the path to match the path to the\nroot of the package.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "path_not_posix",
    "description": "_The path '{0}' isn't a POSIX-style path._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a dependency has a `path` key\nwhose value is a string, but isn't a POSIX-style path.\n\n## Example\n\nThe following code produces this diagnostic because the path following the\n`path` key is a Windows path:\n\n```yaml\nname: example\ndependencies:\n  local_package:\n    path: [!E:\\local_package!]\n```\n\n## Common fixes\n\nConvert the path to a POSIX path.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "path_pubspec_does_not_exist",
    "description": "_The directory '{0}' doesn't contain a pubspec._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a dependency has a `path` key\nthat references a directory that doesn't contain a `pubspec.yaml` file.\n\n## Example\n\nAssuming that the directory `local_package` doesn't contain a file\n`pubspec.yaml`, the following code produces this diagnostic because it's\nlisted as the path of a package:\n\n```yaml\nname: example\ndependencies:\n  local_package:\n    path: [!local_package!]\n```\n\n## Common fixes\n\nIf the path is intended to be the root of a package, then add a\n`pubspec.yaml` file in the directory:\n\n```yaml\nname: local_package\n```\n\nIf the path is wrong, then replace it with the correct path.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "pattern_assignment_declares_variable",
    "description": "_Variable '{0}' can't be declared in a pattern assignment._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "pattern_assignment_not_local_variable",
    "description": "_Only local variables can be assigned in pattern assignments._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a pattern assignment assigns a\nvalue to anything other than a local variable. Patterns can't assign to\nfields or top-level variables.\n\n## Example\n\nIf the code is cleaner when destructuring with a pattern, then rewrite the\ncode to assign the value to a local variable in a pattern declaration,\nassigning the non-local variable separately:\n\n```dart\nclass C {\n  var x = 0;\n\n  void f((int, int) r) {\n    ([!x!], _) = r;\n  }\n}\n```\n\n## Common fixes\n\nIf the code is cleaner when using a pattern assignment, then rewrite the\ncode to assign the value to a local variable, assigning the non-local\nvariable separately:\n\n```dart\nclass C {\n  var x = 0;\n\n  void f((int, int) r) {\n    var (a, _) = r;\n    x = a;\n  }\n}\n```\n\nIf the code is cleaner without using a pattern assignment, then rewrite\nthe code to not use a pattern assignment:\n\n```dart\nclass C {\n  var x = 0;\n\n  void f((int, int) r) {\n    x = r.$1;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "pattern_constant_from_deferred_library",
    "description": "_Constant values from a deferred library can't be used in patterns._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a pattern contains a value\ndeclared in a different library, and that library is imported using a\ndeferred import. Constants are evaluated at compile time, but values from\ndeferred libraries aren't available at compile time.\n\nFor more information, check out\n[Lazily loading a library](https://dart.dev/language/libraries#lazily-loading-a-library).\n\n## Example\n\nGiven a file `a.dart` that defines the constant `zero`:\n\n```dart\nconst zero = 0;\n```\n\nThe following code produces this diagnostic because the constant pattern\n`a.zero` is imported using a deferred import:\n\n```dart\nimport 'a.dart' deferred as a;\n\nvoid f(int x) {\n  switch (x) {\n    case a.[!zero!]:\n      // ...\n      break;\n  }\n}\n```\n\n## Common fixes\n\nIf you need to reference the constant from the imported library, then\nremove the `deferred` keyword:\n\n```dart\nimport 'a.dart' as a;\n\nvoid f(int x) {\n  switch (x) {\n    case a.zero:\n      // ...\n      break;\n  }\n}\n```\n\nIf you need to reference the constant from the imported library and also\nneed the imported library to be deferred, then rewrite the switch\nstatement as a sequence of `if` statements:\n\n```dart\nimport 'a.dart' deferred as a;\n\nvoid f(int x) {\n  if (x == a.zero) {\n    // ...\n  }\n}\n```\n\nIf you don't need to reference the constant, then replace the case\nexpression:\n\n```dart\nvoid f(int x) {\n  switch (x) {\n    case 0:\n      // ...\n      break;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "pattern_never_matches_value_type",
    "description": "_The matched value type '{0}' can never match the required type '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the object's type can't be\nmatched by the pattern.\n\n## Example\n\nThe following code produces this diagnostic because a `double` is matched\nby an `int` pattern, which can never succeed:\n\n```dart\nvoid f(String? s) {\n  if (s case [!int!] _) {}\n}\n```\n\n## Common fixes\n\nIf one of the types is wrong, then change one or both so the pattern match\ncan succeed:\n\n```dart\nvoid f(String? s) {\n  if (s case String _) {}\n}\n```\n\nIf the types are correct, then remove the pattern match:\n\n```dart\nvoid f(double x) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "pattern_type_mismatch_in_irrefutable_context",
    "description": "_The matched value of type '{0}' isn't assignable to the required type '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the type of the value on the\nright-hand side of a pattern assignment or pattern declaration doesn't\nmatch the type required by the pattern being used to match it.\n\n## Example\n\nThe following code produces this diagnostic because `x` might not be a\n`String` and hence might not match the object pattern:\n\n```dart\nvoid f(Object x) {\n  var [!String(length: a)!] = x;\n  print(a);\n}\n```\n\n## Common fixes\n\nChange the code so that the type of the expression on the right-hand side\nmatches the type required by the pattern:\n\n```dart\nvoid f(String x) {\n  var String(length: a) = x;\n  print(a);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "pattern_variable_assignment_inside_guard",
    "description": "_Pattern variables can't be assigned inside the guard of the enclosing guarded pattern._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a pattern variable is assigned\na value inside a guard (`when`) clause.\n\n## Example\n\nThe following code produces this diagnostic because the variable `a` is\nassigned a value inside the guard clause:\n\n```dart\nvoid f(int x) {\n  if (x case var a when ([!a!] = 1) > 0) {\n    print(a);\n  }\n}\n```\n\n## Common fixes\n\nIf there's a value you need to capture, then assign it to a different\nvariable:\n\n```dart\nvoid f(int x) {\n  var b;\n  if (x case var a when (b = 1) > 0) {\n    print(a + b);\n  }\n}\n```\n\nIf there isn't a value you need to capture, then remove the assignment:\n\n```dart\nvoid f(int x) {\n  if (x case var a when 1 > 0) {\n    print(a);\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "pattern_variable_declaration_outside_function_or_method",
    "description": "_A pattern variable declaration may not appear outside a function or method._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "permission_implies_unsupported_hardware",
    "description": "_Permission makes app incompatible for Chrome OS, consider adding optional {0} feature tag,_",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "platform_value_disallowed",
    "description": "_Keys in the `platforms` field can't have values._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a key in the `platforms` map\nhas a value.\nTo learn more about specifying your package's supported platforms,\ncheck out the [documentation on platform declarations](https://dart.dev/tools/pub/pubspec#platforms).\n\n## Example\n\nThe following `pubspec.yaml` produces this diagnostic because the key\n`web` has a value.\n\n```yaml\nname: example\nplatforms:\n  web: [!\"chrome\"!]\n```\n\n## Common fixes\n\nOmit the value and leave the key without a value:\n\n```yaml\nname: example\nplatforms:\n  web:\n```\n\nValues for keys in the `platforms` field are currently reserved for\npotential future behavior.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "plugins_in_inner_options",
    "description": "_Plugins can only be specified in the root of a pub workspace or the root of a package that isn't in a workspace._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when analyzer plugins are defined in\nan analysis options file other than the `analysis_options.yaml` at the\nroot of the package.\n\n## Example\n\nGiven an `analysis_options.yaml` file located in a subdirectory of the\npackage root, the following code produces this diagnostic because it\nattempts to define plugins there:\n\n```yaml\n// %uri=\"inner/analysis_options.yaml\"\n[!plugins!]:\n  one: ^1.0.0\n```\n\n## Common fixes\n\nRemove the list of plugins from the file.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "positional_after_named_argument",
    "description": "_Positional arguments must occur before named arguments._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "positional_field_in_object_pattern",
    "description": "_Object patterns can only use named fields._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an object pattern contains a\nfield without specifying the getter name. Object pattern fields match\nagainst values that the object's getters return. Without a getter name\nspecified, the pattern field can't access a value to attempt to match against.\n\n## Example\n\nThe following code produces this diagnostic because the object pattern\n`String(1)` doesn't specify which getter of `String` to access and compare\nwith the value `1`:\n\n```dart\nvoid f(Object o) {\n  if (o case String([!1!])) {}\n}\n```\n\n## Common fixes\n\nAdd the getter name to access the value, followed\nby a colon before the pattern to match against:\n\n```dart\nvoid f(Object o) {\n  if (o case String(length: 1)) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "positional_parameter_outside_group",
    "description": "_Positional parameters must be enclosed in square brackets ('[' and ']')._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "positional_super_formal_parameter_with_positional_argument",
    "description": "_Positional super parameters can't be used when the super constructor invocation has a positional argument._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when some, but not all, of the\npositional parameters provided to the constructor of the superclass are\nusing a super parameter.\n\nPositional super parameters are associated with positional parameters in\nthe super constructor by their index. That is, the first super parameter\nis associated with the first positional parameter in the super\nconstructor, the second with the second, and so on. The same is true for\npositional arguments. Having both positional super parameters and\npositional arguments means that there are two values associated with the\nsame parameter in the superclass's constructor, and hence isn't allowed.\n\n## Example\n\nThe following code produces this diagnostic because the constructor\n`B.new` is using a super parameter to pass one of the required positional\nparameters to the super constructor in `A`, but is explicitly passing the\nother in the super constructor invocation:\n\n```dart\nclass A {\n  A(int x, int y);\n}\n\nclass B extends A {\n  B(int x, super.[!y!]) : super(x);\n}\n```\n\n## Common fixes\n\nIf all the positional parameters can be super parameters, then convert the\nnormal positional parameters to be super parameters:\n\n```dart\nclass A {\n  A(int x, int y);\n}\n\nclass B extends A {\n  B(super.x, super.y);\n}\n```\n\nIf some positional parameters can't be super parameters, then convert the\nsuper parameters to be normal parameters:\n\n```dart\nclass A {\n  A(int x, int y);\n}\n\nclass B extends A {\n  B(int x, int y) : super(x, y);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "prefix_after_combinator",
    "description": "_The prefix ('as' clause) should come before any show/hide combinators._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "prefix_collides_with_top_level_member",
    "description": "_The name '{0}' is already used as an import prefix and can't be used to name a top-level element._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a name is used as both an import\nprefix and the name of a top-level declaration in the same library.\n\n## Example\n\nThe following code produces this diagnostic because `f` is used as both an\nimport prefix and the name of a function:\n\n```dart\nimport 'dart:math' as f;\n\nint [!f!]() => f.min(0, 1);\n```\n\n## Common fixes\n\nIf you want to use the name for the import prefix, then rename the\ntop-level declaration:\n\n```dart\nimport 'dart:math' as f;\n\nint g() => f.min(0, 1);\n```\n\nIf you want to use the name for the top-level declaration, then rename the\nimport prefix:\n\n```dart\nimport 'dart:math' as math;\n\nint f() => math.min(0, 1);\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "prefix_identifier_not_followed_by_dot",
    "description": "_The name '{0}' refers to an import prefix, so it must be followed by '.'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an import prefix is used by\nitself, without accessing any of the names declared in the libraries\nassociated with the prefix. Prefixes aren't variables, and therefore can't\nbe used as a value.\n\n## Example\n\nThe following code produces this diagnostic because the prefix `math` is\nbeing used as if it were a variable:\n\n```dart\nimport 'dart:math' as math;\n\nvoid f() {\n  print([!math!]);\n}\n```\n\n## Common fixes\n\nIf the code is incomplete, then reference something in one of the libraries\nassociated with the prefix:\n\n```dart\nimport 'dart:math' as math;\n\nvoid f() {\n  print(math.pi);\n}\n```\n\nIf the name is wrong, then correct the name.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "prefix_shadowed_by_local_declaration",
    "description": "_The prefix '{0}' can't be used here because it's shadowed by a local declaration._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an import prefix is used in a\ncontext where it isn't visible because it was shadowed by a local\ndeclaration.\n\n## Example\n\nThe following code produces this diagnostic because the prefix `a` is\nbeing used to access the class `Future`, but isn't visible because it's\nshadowed by the parameter `a`:\n\n```dart\nimport 'dart:async' as a;\n\na.Future? f(int a) {\n  [!a!].Future? x;\n  return x;\n}\n```\n\n## Common fixes\n\nRename either the prefix:\n\n```dart\nimport 'dart:async' as p;\n\np.Future? f(int a) {\n  p.Future? x;\n  return x;\n}\n```\n\nOr rename the local variable:\n\n```dart\nimport 'dart:async' as a;\n\na.Future? f(int p) {\n  a.Future? x;\n  return x;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "private_collision_in_mixin_application",
    "description": "_The private name '{0}', defined by '{1}', conflicts with the same name defined by '{2}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when two mixins that define the same\nprivate member are used together in a single class in a library other than\nthe one that defines the mixins.\n\n## Example\n\nGiven a file `a.dart` containing the following code:\n\n```dart\nmixin A {\n  void _foo() {}\n}\n\nmixin B {\n  void _foo() {}\n}\n```\n\nThe following code produces this diagnostic because the mixins `A` and `B`\nboth define the method `_foo`:\n\n```dart\nimport 'a.dart';\n\nclass C extends Object with A, [!B!] {}\n```\n\n## Common fixes\n\nIf you don't need both of the mixins, then remove one of them from the\n`with` clause:\n\n```dart\nimport 'a.dart';\n\nclass C extends Object with A, [!B!] {}\n```\n\nIf you need both of the mixins, then rename the conflicting member in one\nof the two mixins.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "private_named_non_field_parameter",
    "description": "_Named parameters that don't refer to instance variables can't start with underscore._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a named parameter starts with\nan underscore, unless it's an initializing formal or field parameter.\n\n## Example\n\nThe following code produces this diagnostic because the named parameter\n`_x` starts with an underscore:\n\n```dart\nclass C {\n  C({int [!_x!] = 0});\n}\n```\n\n## Common fixes\n\nIf the parameter is intended to refer to a field, then add the missing\nfield:\n\n```dart\nclass C {\n  final int _x;\n  C({this._x = 0});\n  int get x => _x;\n}\n```\n\nIf the parameter isn't intended to refer to a field, then remove the\nunderscore:\n\n```dart\nclass C {\n  C({int x = 0});\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "private_named_parameter_duplicate_public_name",
    "description": "_The corresponding public name '{0}' is already the name of another parameter._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a private named parameter\n(leading `_`) has a corresponding public name that conflicts with an\nexisting parameter name in the same parameter list.\n\n## Example\n\nThe following code produces this diagnostic because the private named\nparameter `_x`'s public name is `x`, which conflicts with the existing\nparameter named `x`:\n\n```dart\nclass C {\n  int? _x;\n  C({int? x, this.[!_x!]});\n  int? get x => _x;\n}\n```\n\n## Common fixes\n\nRename one of the two parameters.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "private_named_parameter_without_public_name",
    "description": "_A private named parameter must be a public identifier after removing the leading underscore._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the name of a named parameter\nstarts with an underscore and the result of removing the underscore isn't\na valid public identifier.\n\n## Example\n\nThe following code produces this diagnostic because the named parameter\n`_2legit` without the `_` is `2legit`, which isn't a valid public\nidentifier:\n\n```dart\nclass C {\n  final int? _2legit;\n  C({this.[!_2legit!] = 0});\n  int? get twoLegit => _2legit;\n}\n```\n\n## Common fixes\n\nRename the parameter so that the character following the leading\nunderscore is a letter.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "private_optional_parameter",
    "description": "_Named parameters can't start with an underscore._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the name of a named parameter\nstarts with an underscore.\n\n## Example\n\nThe following code produces this diagnostic because the named parameter\n`_x` starts with an underscore:\n\n```dart\nclass C {\n  void m({int [!_x!] = 0}) {}\n}\n```\n\n## Common fixes\n\nRename the parameter so that it doesn't start with an underscore:\n\n```dart\nclass C {\n  void m({int x = 0}) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "private_setter",
    "description": "_The setter '{0}' is private and can't be accessed outside the library that declares it._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a private setter is used in a\nlibrary where it isn't visible.\n\n## Example\n\nGiven a file `a.dart` that contains the following:\n\n```dart\nclass A {\n  static int _f = 0;\n}\n```\n\nThe following code produces this diagnostic because it references the\nprivate setter `_f` even though the setter isn't visible:\n\n```dart\nimport 'a.dart';\n\nvoid f() {\n  A.[!_f!] = 0;\n}\n```\n\n## Common fixes\n\nIf you're able to make the setter public, then do so:\n\n```dart\nclass A {\n  static int f = 0;\n}\n```\n\nIf you aren't able to make the setter public, then find a different way to\nimplement the code.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "read_potentially_unassigned_final",
    "description": "_The final variable '{0}' can't be read because it's potentially unassigned at this point._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a final local variable that\nisn't initialized at the declaration site is read at a point where the\ncompiler can't prove that the variable is always initialized before it's\nreferenced.\n\n## Example\n\nThe following code produces this diagnostic because the final local\nvariable `x` is read (on line 3) when it's possible that it hasn't yet\nbeen initialized:\n\n```dart\nint f() {\n  final int x;\n  return [!x!];\n}\n```\n\n## Common fixes\n\nEnsure that the variable has been initialized before it's read:\n\n```dart\nint f(bool b) {\n  final int x;\n  if (b) {\n    x = 0;\n  } else {\n    x = 1;\n  }\n  return x;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "receiver_of_type_never",
    "description": "_The receiver is of type 'Never', and will never complete with a value._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "record_literal_one_positional_no_trailing_comma",
    "description": "_A record literal with exactly one positional field requires a trailing comma._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a record literal with a single\npositional field doesn't have a trailing comma after the field.\n\nIn some locations a record literal with a single positional field could\nalso be a parenthesized expression. A trailing comma is required to\ndisambiguate these two valid interpretations.\n\n## Example\n\nThe following code produces this diagnostic because the record literal has\none positional field but doesn't have a trailing comma:\n\n```dart\nvar r = const (1[!)!];\n```\n\n## Common fixes\n\nAdd a trailing comma:\n\n```dart\nvar r = const (1,);\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "record_type_one_positional_no_trailing_comma",
    "description": "_A record type with exactly one positional field requires a trailing comma._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a record type annotation with a\nsingle positional field doesn't have a trailing comma after the field.\n\nIn some locations a record type with a single positional field could also\nbe a parenthesized expression. A trailing comma is required to\ndisambiguate these two valid interpretations.\n\n## Example\n\nThe following code produces this diagnostic because the record type has\none positional field, but doesn't have a trailing comma:\n\n```dart\nvoid f((int[!)!] r) {}\n```\n\n## Common fixes\n\nAdd a trailing comma:\n\n```dart\nvoid f((int,) r) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "recursive_compile_time_constant",
    "description": "_The compile-time constant expression depends on itself._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the value of a compile-time\nconstant is defined in terms of itself, either directly or indirectly,\ncreating an infinite loop.\n\n## Example\n\nThe following code produces this diagnostic twice because both of the\nconstants are defined in terms of the other:\n\n```dart\nconst [!secondsPerHour!] = minutesPerHour * 60;\nconst [!minutesPerHour!] = secondsPerHour / 60;\n```\n\n## Common fixes\n\nBreak the cycle by finding an alternative way of defining at least one of\nthe constants:\n\n```dart\nconst secondsPerHour = minutesPerHour * 60;\nconst minutesPerHour = 60;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "recursive_constant_constructor",
    "description": "_The constant constructor depends on itself._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "recursive_constructor_redirect",
    "description": "_Constructors can't redirect to themselves either directly or indirectly._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor redirects to\nitself, either directly or indirectly, creating an infinite loop.\n\n## Examples\n\nThe following code produces this diagnostic because the generative\nconstructors `C.a` and `C.b` each redirect to the other:\n\n```dart\nclass C {\n  C.a() : [!this.b()!];\n  C.b() : [!this.a()!];\n}\n```\n\nThe following code produces this diagnostic because the factory\nconstructors `A` and `B` each redirect to the other:\n\n```dart\nabstract class A {\n  factory A() = [!B!];\n}\nclass B implements A {\n  factory B() = [!A!];\n  B.named();\n}\n```\n\n## Common fixes\n\nIn the case of generative constructors, break the cycle by finding defining\nat least one of the constructors to not redirect to another constructor:\n\n```dart\nclass C {\n  C.a() : this.b();\n  C.b();\n}\n```\n\nIn the case of factory constructors, break the cycle by defining at least\none of the factory constructors to do one of the following:\n\n- Redirect to a generative constructor:\n\n```dart\nabstract class A {\n  factory A() = B;\n}\nclass B implements A {\n  factory B() = B.named;\n  B.named();\n}\n```\n\n- Not redirect to another constructor:\n\n```dart\nabstract class A {\n  factory A() = B;\n}\nclass B implements A {\n  factory B() {\n    return B.named();\n  }\n\n  B.named();\n}\n```\n\n- Not be a factory constructor:\n\n```dart\nabstract class A {\n  factory A() = B;\n}\nclass B implements A {\n  B();\n  B.named();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "recursive_include_file",
    "description": "_The URI '{0}' included in '{1}' includes '{1}', creating a circular reference._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an analysis options file,\ndirectly or indirectly, includes itself.\n\n## Examples\n\nThe following code produces this diagnostic because the file directly\nincludes itself:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\ninclude: [!analysis_options.yaml!]\n```\n\nGiven a file named `shared_options.yaml` that contains:\n\n```yaml\n// %uri=\"shared_options.yaml\"\ninclude: analysis_options.yaml\n```\n\nThe following code produces this diagnostic because the file indirectly\nincludes itself:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\ninclude: [!shared_options.yaml!]\n```\n\n## Common fixes\n\nChange at least one of the files in order to break the circularity.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "recursive_interface_inheritance",
    "description": "_'{0}' can't be a superinterface of itself: {1}._\n\n_'{0}' can't extend itself._\n\n_'{0}' can't implement itself._\n\n_'{0}' can't use itself as a mixin._\n\n_'{0}' can't use itself as a superclass constraint._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when there's a circularity in the\ntype hierarchy. This happens when a type, either directly or indirectly,\nis declared to be a subtype of itself.\n\n## Example\n\nThe following code produces this diagnostic because the class `A` is\ndeclared to be a subtype of `B`, and `B` is a subtype of `A`:\n\n```dart\nclass [!A!] extends B {}\nclass B implements A {}\n```\n\n## Common fixes\n\nChange the type hierarchy so that there's no circularity.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "redeclare_on_non_redeclaring_member",
    "description": "_The {0} doesn't redeclare a {0} declared in a superinterface._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a member of an extension type\nis annotated with `@redeclare`, but none of the implemented interfaces\nhas a member with the same name.\n\n## Example\n\nThe following code produces this diagnostic because the member `n`\ndeclared by the extension type `E` is annotated with `@redeclare`, but `C`\ndoesn't have a member named `n`:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass C {\n  void m() {}\n}\n\nextension type E(C c) implements C {\n  @redeclare\n  void [!n!]() {}\n}\n```\n\n## Common fixes\n\nIf the annotated member has the right name, then remove the annotation:\n\n```dart\nclass C {\n  void m() {}\n}\n\nextension type E(C c) implements C {\n  void n() {}\n}\n```\n\nIf the annotated member is suppose to replace a member from the\nimplemented interfaces, then change the name of the annotated member to\nmatch the member being replaced:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass C {\n  void m() {}\n}\n\nextension type E(C c) implements C {\n  @redeclare\n  void m() {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "redirecting_constructor_with_body",
    "description": "_Redirecting constructors can't have a body._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "redirection_in_non_factory_constructor",
    "description": "_Only factory constructor can specify '=' redirection._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "redirect_generative_to_missing_constructor",
    "description": "_The constructor '{0}' couldn't be found in '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a generative constructor\nredirects to a constructor that isn't defined.\n\n## Example\n\nThe following code produces this diagnostic because the constructor `C.a`\nredirects to the constructor `C.b`, but `C.b` isn't defined:\n\n```dart\nclass C {\n  C.a() : [!this.b()!];\n}\n```\n\n## Common fixes\n\nIf the missing constructor must be called, then define it:\n\n```dart\nclass C {\n  C.a() : this.b();\n  C.b();\n}\n```\n\nIf the missing constructor doesn't need to be called, then remove the\nredirect:\n\n```dart\nclass C {\n  C.a();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "redirect_generative_to_non_generative_constructor",
    "description": "_Generative constructors can't redirect to a factory constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a generative constructor\nredirects to a factory constructor.\n\n## Example\n\nThe following code produces this diagnostic because the generative\nconstructor `C.a` redirects to the factory constructor `C.b`:\n\n```dart\nclass C {\n  C.a() : [!this.b()!];\n  factory C.b() => C.a();\n}\n```\n\n## Common fixes\n\nIf the generative constructor doesn't need to redirect to another\nconstructor, then remove the redirect.\n\n```dart\nclass C {\n  C.a();\n  factory C.b() => C.a();\n}\n```\n\nIf the generative constructor must redirect to another constructor, then\nmake the other constructor be a generative (non-factory) constructor:\n\n```dart\nclass C {\n  C.a() : this.b();\n  C.b();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "redirect_to_abstract_class_constructor",
    "description": "_The redirecting constructor '{0}' can't redirect to a constructor of the abstract class '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor redirects to a\nconstructor in an abstract class.\n\n## Example\n\nThe following code produces this diagnostic because the factory\nconstructor in `A` redirects to a constructor in `B`, but `B` is an\nabstract class:\n\n```dart\nclass A {\n  factory A() = [!B!];\n}\n\nabstract class B implements A {}\n```\n\n## Common fixes\n\nIf the code redirects to the correct constructor, then change the class so\nthat it isn't abstract:\n\n```dart\nclass A {\n  factory A() = B;\n}\n\nclass B implements A {}\n```\n\nOtherwise, change the factory constructor so that it either redirects to a\nconstructor in a concrete class, or has a concrete implementation.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "redirect_to_invalid_function_type",
    "description": "_The redirected constructor '{0}' has incompatible parameters with '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a factory constructor attempts\nto redirect to another constructor, but the two have incompatible\nparameters. The parameters are compatible if all of the parameters of the\nredirecting constructor can be passed to the other constructor and if the\nother constructor doesn't require any parameters that aren't declared by\nthe redirecting constructor.\n\n## Examples\n\nThe following code produces this diagnostic because the constructor for `A`\ndoesn't declare a parameter that the constructor for `B` requires:\n\n```dart\nabstract class A {\n  factory A() = [!B!];\n}\n\nclass B implements A {\n  B(int x);\n  B.zero();\n}\n```\n\nThe following code produces this diagnostic because the constructor for `A`\ndeclares a named parameter (`y`) that the constructor for `B` doesn't\nallow:\n\n```dart\nabstract class A {\n  factory A(int x, {int y}) = [!B!];\n}\n\nclass B implements A {\n  B(int x);\n}\n```\n\n## Common fixes\n\nIf there's a different constructor that is compatible with the redirecting\nconstructor, then redirect to that constructor:\n\n```dart\nabstract class A {\n  factory A() = B.zero;\n}\n\nclass B implements A {\n  B(int x);\n  B.zero();\n}\n```\n\nOtherwise, update the redirecting constructor to be compatible:\n\n```dart\nabstract class A {\n  factory A(int x) = B;\n}\n\nclass B implements A {\n  B(int x);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "redirect_to_invalid_return_type",
    "description": "_The return type '{0}' of the redirected constructor isn't a subtype of '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a factory constructor redirects\nto a constructor whose return type isn't a subtype of the type that the\nfactory constructor is declared to produce.\n\n## Example\n\nThe following code produces this diagnostic because `A` isn't a subclass\nof `C`, which means that the value returned by the constructor `A()`\ncouldn't be returned from the constructor `C()`:\n\n```dart\nclass A {}\n\nclass B implements C {}\n\nclass C {\n  factory C() = [!A!];\n}\n```\n\n## Common fixes\n\nIf the factory constructor is redirecting to a constructor in the wrong\nclass, then update the factory constructor to redirect to the correct\nconstructor:\n\n```dart\nclass A {}\n\nclass B implements C {}\n\nclass C {\n  factory C() = B;\n}\n```\n\nIf the class defining the constructor being redirected to is the class that\nshould be returned, then make it a subtype of the factory's return type:\n\n```dart\nclass A implements C {}\n\nclass B implements C {}\n\nclass C {\n  factory C() = A;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "redirect_to_missing_constructor",
    "description": "_The constructor '{0}' couldn't be found in '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor redirects to a\nconstructor that doesn't exist.\n\n## Example\n\nThe following code produces this diagnostic because the factory\nconstructor in `A` redirects to a constructor in `B` that doesn't exist:\n\n```dart\nclass A {\n  factory A() = [!B.name!];\n}\n\nclass B implements A {\n  B();\n}\n```\n\n## Common fixes\n\nIf the constructor being redirected to is correct, then define the\nconstructor:\n\n```dart\nclass A {\n  factory A() = B.name;\n}\n\nclass B implements A {\n  B();\n  B.name();\n}\n```\n\nIf a different constructor should be invoked, then update the redirect:\n\n```dart\nclass A {\n  factory A() = B;\n}\n\nclass B implements A {\n  B();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "redirect_to_non_class",
    "description": "_The name '{0}' isn't a type and can't be used in a redirected constructor._",
    "documentation": "## Description\n\nOne way to implement a factory constructor is to redirect to another\nconstructor by referencing the name of the constructor. The analyzer\nproduces this diagnostic when the redirect is to something other than a\nconstructor.\n\n## Example\n\nThe following code produces this diagnostic because `f` is a function:\n\n```dart\nC f() => throw 0;\n\nclass C {\n  factory C() = [!f!];\n}\n```\n\n## Common fixes\n\nIf the constructor isn't defined, then either define it or replace it with\na constructor that is defined.\n\nIf the constructor is defined but the class that defines it isn't visible,\nthen you probably need to add an import.\n\nIf you're trying to return the value returned by a function, then rewrite\nthe constructor to return the value from the constructor's body:\n\n```dart\nC f() => throw 0;\n\nclass C {\n  factory C() => f();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "redirect_to_non_const_constructor",
    "description": "_A constant redirecting constructor can't redirect to a non-constant constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor marked as `const`\nredirects to a constructor that isn't marked as `const`.\n\n## Example\n\nThe following code produces this diagnostic because the constructor `C.a`\nis marked as `const` but redirects to the constructor `C.b`, which isn't:\n\n```dart\nclass C {\n  const C.a() : this.[!b!]();\n  C.b();\n}\n```\n\n## Common fixes\n\nIf the non-constant constructor can be marked as `const`, then mark it as\n`const`:\n\n```dart\nclass C {\n  const C.a() : this.b();\n  const C.b();\n}\n```\n\nIf the non-constant constructor can't be marked as `const`, then either\nremove the redirect or remove `const` from the redirecting constructor:\n\n```dart\nclass C {\n  C.a() : this.b();\n  C.b();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "redirect_to_type_alias_expands_to_type_parameter",
    "description": "_A redirecting constructor can't redirect to a type alias that expands to a type parameter._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a redirecting factory\nconstructor redirects to a type alias, and the type alias expands to one of\nthe type parameters of the type alias. This isn't allowed because the value\nof the type parameter is a type rather than a class.\n\n## Example\n\nThe following code produces this diagnostic because the redirect to `B<A>`\nis to a type alias whose value is `T`, even though it looks like the value\nshould be `A`:\n\n```dart\nclass A implements C {}\n\ntypedef B<T> = T;\n\nabstract class C {\n  factory C() = [!B!]<A>;\n}\n```\n\n## Common fixes\n\nUse either a class name or a type alias that is defined to be a class\nrather than a type alias defined to be a type parameter:\n\n```dart\nclass A implements C {}\n\nabstract class C {\n  factory C() = A;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "referenced_before_declaration",
    "description": "_Local variable '{0}' can't be referenced before it is declared._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a variable is referenced before\nit's declared. In Dart, variables are visible everywhere in the block in\nwhich they are declared, but can only be referenced after they are\ndeclared.\n\nThe analyzer also produces a context message that indicates where the\ndeclaration is located.\n\n## Example\n\nThe following code produces this diagnostic because `i` is used before it\nis declared:\n\n```dart\nvoid f() {\n  print([!i!]);\n  int i = 5;\n}\n```\n\n## Common fixes\n\nIf you intended to reference the local variable, move the declaration\nbefore the first reference:\n\n```dart\nvoid f() {\n  int i = 5;\n  print(i);\n}\n```\n\nIf you intended to reference a name from an outer scope, such as a\nparameter, instance field or top-level variable, then rename the local\ndeclaration so that it doesn't hide the outer variable.\n\n```dart\nvoid f(int i) {\n  print(i);\n  int x = 5;\n  print(x);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "refutable_pattern_in_irrefutable_context",
    "description": "_Refutable patterns can't be used in an irrefutable context._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a [refutable pattern][] is used\nin a context where only an [irrefutable pattern][] is allowed.\n\nThe refutable patterns that are disallowed are:\n- logical-or\n- relational\n- null-check\n- constant\n\nThe contexts that are checked are:\n- pattern-based variable declarations\n- pattern-based for loops\n- assignments with a pattern on the left-hand side\n\n## Example\n\nThe following code produces this diagnostic because the null-check\npattern, which is a refutable pattern, is in a pattern-based variable\ndeclaration, which doesn't allow refutable patterns:\n\n```dart\nvoid f(int? x) {\n  var ([!_?!]) = x;\n}\n```\n\n## Common fixes\n\nRewrite the code to not use a refutable pattern in an irrefutable context.\n\n[irrefutable pattern]: /resources/glossary#irrefutable-pattern\n[refutable pattern]: /resources/glossary#refutable-pattern\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "relational_pattern_operand_type_not_assignable",
    "description": "_The constant expression type '{0}' is not assignable to the parameter type '{1}' of the '{2}' operator._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the operand of a relational\npattern has a type that isn't assignable to the parameter of the operator\nthat will be invoked.\n\n## Example\n\nThe following code produces this diagnostic because the operand in the\nrelational pattern (`0`) is an `int`, but the `>` operator defined in `C`\nexpects an object of type `C`:\n\n```dart\nclass C {\n  const C();\n\n  bool operator >(C other) => true;\n}\n\nvoid f(C c) {\n  switch (c) {\n    case > [!0!]:\n      print('positive');\n  }\n}\n```\n\n## Common fixes\n\nIf the switch is using the correct value, then change the case to compare\nthe value to the right type of object:\n\n```dart\nclass C {\n  const C();\n\n  bool operator >(C other) => true;\n}\n\nvoid f(C c) {\n  switch (c) {\n    case > const C():\n      print('positive');\n  }\n}\n```\n\nIf the switch is using the wrong value, then change the expression used to\ncompute the value being matched:\n\n```dart\nclass C {\n  const C();\n\n  bool operator >(C other) => true;\n\n  int get toInt => 0;\n}\n\nvoid f(C c) {\n  switch (c.toInt) {\n    case > 0:\n      print('positive');\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "relational_pattern_operator_return_type_not_assignable_to_bool",
    "description": "_The return type of operators used in relational patterns must be assignable to 'bool'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a relational pattern references\nan operator that doesn't produce a value of type `bool`.\n\n## Example\n\nThe following code produces this diagnostic because the operator `>`, used\nin the relational pattern `> c2`, returns a value of type `int` rather\nthan a `bool`:\n\n```dart\nclass C {\n  const C();\n\n  int operator >(C c) => 3;\n\n  bool operator <(C c) => false;\n}\n\nconst C c2 = C();\n\nvoid f(C c1) {\n  if (c1 case [!>!] c2) {}\n}\n```\n\n## Common fixes\n\nIf there's a different operator that should be used, then change the\noperator:\n\n```dart\nclass C {\n  const C();\n\n  int operator >(C c) => 3;\n\n  bool operator <(C c) => false;\n}\n\nconst C c2 = C();\n\nvoid f(C c1) {\n  if (c1 case < c2) {}\n}\n```\n\nIf the operator is expected to return `bool`, then update the declaration\nof the operator:\n\n```dart\nclass C {\n  const C();\n\n  bool operator >(C c) => true;\n\n  bool operator <(C c) => false;\n}\n\nconst C c2 = C();\n\nvoid f(C c1) {\n  if (c1 case > c2) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "removed_lint",
    "description": "_'{0}' was removed in Dart '{1}'_",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an analysis options file\nenables a lint that is no longer supported.\n\n## Example\n\nThe following code produces this diagnostic because the lint\n`always_declare_return_types` is no longer supported:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nlinter:\n  rules:\n    - [!always_declare_return_types!]\n    - annotate_overrides\n```\n\n## Common fixes\n\nRemove the reference to the removed lint rule:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nlinter:\n  rules:\n    - annotate_overrides\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "removed_lint_use",
    "description": "_'{0}' was removed in Dart '{1}'_",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a lint that has been removed is\nused in an analysis options file. Because the lint no longer exists,\nreferencing it will have no effect.\n\n## Example\n\nAssuming that the lint `removed_lint` has been removed, the following\noptions file produces this diagnostic:\n\n```yaml\nlinter:\n  rules:\n  - always_put_required_named_parameters_first\n  - [!removed_lint!]\n```\n\n## Common fixes\n\nRemove the reference to the lint code:\n\n```yaml\nlinter:\n  rules:\n  - always_put_required_named_parameters_first\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "replaced_lint",
    "description": "_'{0}' was replaced by '{1}' in Dart '{2}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "replaced_lint_use",
    "description": "_'{0}' was replaced by '{1}' in Dart '{2}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "representation_field_modifier",
    "description": "_Representation fields can't have modifiers._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "representation_field_trailing_comma",
    "description": "_The representation field can't have a trailing comma._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "rest_element_in_map_pattern",
    "description": "_A map pattern can't contain a rest pattern._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a map pattern contains a rest\npattern. Map patterns match a map with more keys\nthan those explicitly given in the pattern (as long as the given keys match),\nso a rest pattern is unnecessary.\n\n## Example\n\nThe following code produces this diagnostic because the map pattern contains\na rest pattern:\n\n```dart\nvoid f(Map<int, String> x) {\n  if (x case {0: _, [!...!]}) {}\n}\n```\n\n## Common fixes\n\nRemove the rest pattern:\n\n```dart\nvoid f(Map<int, String> x) {\n  if (x case {0: _}) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "rethrow_outside_catch",
    "description": "_A rethrow must be inside of a catch clause._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `rethrow` statement is outside\na `catch` clause. The `rethrow` statement is used to throw a caught\nexception again, but there's no caught exception outside of a `catch`\nclause.\n\n## Example\n\nThe following code produces this diagnostic because the`rethrow` statement\nis outside of a `catch` clause:\n\n```dart\nvoid f() {\n  [!rethrow!];\n}\n```\n\n## Common fixes\n\nIf you're trying to rethrow an exception, then wrap the `rethrow` statement\nin a `catch` clause:\n\n```dart\nvoid f() {\n  try {\n    // ...\n  } catch (exception) {\n    rethrow;\n  }\n}\n```\n\nIf you're trying to throw a new exception, then replace the `rethrow`\nstatement with a `throw` expression:\n\n```dart\nvoid f() {\n  throw UnsupportedError('Not yet implemented');\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "return_in_generative_constructor",
    "description": "_Constructors can't return values._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a generative constructor\ncontains a `return` statement that specifies a value to be returned.\nGenerative constructors always return the object that was created, and\ntherefore can't return a different object.\n\n## Example\n\nThe following code produces this diagnostic because the `return` statement\nhas an expression:\n\n```dart\nclass C {\n  C() {\n    return [!this!];\n  }\n}\n```\n\n## Common fixes\n\nIf the constructor should create a new instance, then remove either the\n`return` statement or the expression:\n\n```dart\nclass C {\n  C();\n}\n```\n\nIf the constructor shouldn't create a new instance, then convert it to be a\nfactory constructor:\n\n```dart\nclass C {\n  factory C() {\n    return _instance;\n  }\n\n  static C _instance = C._();\n\n  C._();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "return_in_generator",
    "description": "_Can't return a value from a generator function that uses the 'async*' or 'sync*' modifier._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a generator function (one whose\nbody is marked with either `async*` or `sync*`) uses either a `return`\nstatement to return a value or implicitly returns a value because of using\n`=>`. In any of these cases, they should use `yield` instead of `return`.\n\n## Examples\n\nThe following code produces this diagnostic because the method `f` is a\ngenerator and is using `return` to return a value:\n\n```dart\nIterable<int> f() sync* {\n  [!return!] 3;\n}\n```\n\nThe following code produces this diagnostic because the function `f` is a\ngenerator and is implicitly returning a value:\n\n```dart\nStream<int> f() async* [!=>!] 3;\n```\n\n## Common fixes\n\nIf the function is using `=>` for the body of the function, then convert it\nto a block function body, and use `yield` to return a value:\n\n```dart\nStream<int> f() async* {\n  yield 3;\n}\n```\n\nIf the method is intended to be a generator, then use `yield` to return a\nvalue:\n\n```dart\nIterable<int> f() sync* {\n  yield 3;\n}\n```\n\nIf the method isn't intended to be a generator, then remove the modifier\nfrom the body (or use `async` if you're returning a future):\n\n```dart\nint f() {\n  return 3;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "return_of_do_not_store",
    "description": "_'{0}' is annotated with 'doNotStore' and shouldn't be returned unless '{1}' is also annotated._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a value that is annotated with\nthe [`doNotStore`][meta-doNotStore] annotation is returned from a method,\ngetter, or function that doesn't have the same annotation.\n\n## Example\n\nThe following code produces this diagnostic because the result of invoking\n`f` shouldn't be stored, but the function `g` isn't annotated to preserve\nthat semantic:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@doNotStore\nint f() => 0;\n\nint g() => [!f()!];\n```\n\n## Common fixes\n\nIf the value that shouldn't be stored is the correct value to return, then\nmark the function with the [`doNotStore`][meta-doNotStore] annotation:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@doNotStore\nint f() => 0;\n\n@doNotStore\nint g() => f();\n```\n\nOtherwise, return a different value from the function:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@doNotStore\nint f() => 0;\n\nint g() => 0;\n```\n\n[meta-doNotStore]: https://pub.dev/documentation/meta/latest/meta/doNotStore-constant.html\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "return_of_invalid_type",
    "description": "_A value of type '{0}' can't be returned from the constructor '{1}' because it has a return type of '{2}'._\n\n_A value of type '{0}' can't be returned from the function '{1}' because it has a return type of '{2}'._\n\n_A value of type '{0}' can't be returned from the method '{1}' because it has a return type of '{2}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a method or function returns a\nvalue whose type isn't assignable to the declared return type.\n\n## Example\n\nThe following code produces this diagnostic because `f` has a return type\nof `String` but is returning an `int`:\n\n```dart\nString f() => [!3!];\n```\n\n## Common fixes\n\nIf the return type is correct, then replace the value being returned with a\nvalue of the correct type, possibly by converting the existing value:\n\n```dart\nString f() => 3.toString();\n```\n\nIf the value is correct, then change the return type to match:\n\n```dart\nint f() => 3;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "return_of_invalid_type_from_closure",
    "description": "_The returned type '{0}' isn't returnable from a '{1}' function, as required by the closure's context._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the static type of a returned\nexpression isn't assignable to the return type that the closure is required\nto have.\n\n## Example\n\nThe following code produces this diagnostic because `f` is defined to be a\nfunction that returns a `String`, but the closure assigned to it returns an\n`int`:\n\n```dart\nString Function(String) f = (s) => [!3!];\n```\n\n## Common fixes\n\nIf the return type is correct, then replace the returned value with a value\nof the correct type, possibly by converting the existing value:\n\n```dart\nString Function(String) f = (s) => 3.toString();\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "return_without_value",
    "description": "_The return value is missing after 'return'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it finds a `return` statement\nwithout an expression in a function that declares a return type.\n\n## Example\n\nThe following code produces this diagnostic because the function `f` is\nexpected to return an `int`, but no value is being returned:\n\n```dart\nint f() {\n  [!return!];\n}\n```\n\n## Common fixes\n\nAdd an expression that computes the value to be returned:\n\n```dart\nint f() {\n  return 0;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "sdk_version_async_exported_from_core",
    "description": "_The class '{0}' wasn't exported from 'dart:core' until version 2.1, but this code is required to be able to run on earlier versions._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when either the class `Future` or\n`Stream` is referenced in a library that doesn't import `dart:async` in\ncode that has an SDK constraint whose lower bound is less than 2.1.0. In\nearlier versions, these classes weren't defined in `dart:core`, so the\nimport was necessary.\n\n## Example\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.1.0:\n\n```yaml\nenvironment:\n  sdk: '>=2.0.0 <2.4.0'\n```\n\nIn the package that has that pubspec, code like the following produces this\ndiagnostic:\n\n```dart\nvoid f([!Future!] f) {}\n```\n\n## Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the classes to be referenced:\n\n```yaml\nenvironment:\n  sdk: '>=2.1.0 <2.4.0'\n```\n\nIf you need to support older versions of the SDK, then import the\n`dart:async` library.\n\n```dart\nimport 'dart:async';\n\nvoid f(Future f) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "sdk_version_as_expression_in_const_context",
    "description": "_The use of an as expression in a constant expression wasn't supported until version 2.3.2, but this code is required to be able to run on earlier versions._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an `as` expression inside a\n[constant context][] is found in code that has an SDK constraint whose\nlower bound is less than 2.3.2. Using an `as` expression in a\n[constant context][] wasn't supported in earlier versions, so this code\nwon't be able to run against earlier versions of the SDK.\n\n## Example\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.3.2:\n\n```yaml\nenvironment:\n  sdk: '>=2.1.0 <2.4.0'\n```\n\nIn the package that has that pubspec, code like the following produces\nthis diagnostic:\n\n```dart\nconst num n = 3;\nconst int i = [!n as int!];\n```\n\n## Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the expression to be used:\n\n```yaml\nenvironment:\n  sdk: '>=2.3.2 <2.4.0'\n```\n\nIf you need to support older versions of the SDK, then either rewrite the\ncode to not use an `as` expression, or change the code so that the `as`\nexpression isn't in a [constant context][]:\n\n```dart\nnum x = 3;\nint y = x as int;\n```\n\n[constant context]: /resources/glossary#constant-context\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "sdk_version_bool_operator_in_const_context",
    "description": "_The use of the operator '{0}' for 'bool' operands in a constant context wasn't supported until version 2.3.2, but this code is required to be able to run on earlier versions._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when any use of the `&`, `|`, or `^`\noperators on the class `bool` inside a [constant context][] is found in\ncode that has an SDK constraint whose lower bound is less than 2.3.2. Using\nthese operators in a [constant context][] wasn't supported in earlier\nversions, so this code won't be able to run against earlier versions of the\nSDK.\n\n## Example\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.3.2:\n\n```yaml\nenvironment:\n  sdk: '>=2.1.0 <2.4.0'\n```\n\nIn the package that has that pubspec, code like the following produces this\ndiagnostic:\n\n```dart\nconst bool a = true;\nconst bool b = false;\nconst bool c = a [!&!] b;\n```\n\n## Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the operators to be used:\n\n```yaml\nenvironment:\n sdk: '>=2.3.2 <2.4.0'\n```\n\nIf you need to support older versions of the SDK, then either rewrite the\ncode to not use these operators, or change the code so that the expression\nisn't in a [constant context][]:\n\n```dart\nconst bool a = true;\nconst bool b = false;\nbool c = a & b;\n```\n\n[constant context]: /resources/glossary#constant-context\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "sdk_version_constructor_tearoffs",
    "description": "_Tearing off a constructor requires the 'constructor-tearoffs' language feature._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor tear-off is found\nin code that has an SDK constraint whose lower bound is less than 2.15.\nConstructor tear-offs weren't supported in earlier versions, so this code\nwon't be able to run against earlier versions of the SDK.\n\n## Example\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.15:\n\n```yaml\nenvironment:\n  sdk: '>=2.9.0 <2.15.0'\n```\n\nIn the package that has that pubspec, code like the following produces this\ndiagnostic:\n\n```dart\nvar setConstructor = [!Set.identity!];\n```\n\n## Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the operator to be used:\n\n```yaml\nenvironment:\n  sdk: '>=2.15.0 <2.16.0'\n```\n\nIf you need to support older versions of the SDK, then rewrite the code to\nnot use constructor tear-offs:\n\n```dart\nvar setConstructor = () => Set.identity();\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "sdk_version_eq_eq_operator_in_const_context",
    "description": "_Using the operator '==' for non-primitive types wasn't supported until version 2.3.2, but this code is required to be able to run on earlier versions._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the operator `==` is used on a\nnon-primitive type inside a [constant context][] is found in code that has\nan SDK constraint whose lower bound is less than 2.3.2. Using this operator\nin a [constant context][] wasn't supported in earlier versions, so this\ncode won't be able to run against earlier versions of the SDK.\n\n## Example\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.3.2:\n\n```yaml\nenvironment:\n  sdk: '>=2.1.0 <2.4.0'\n```\n\nIn the package that has that pubspec, code like the following produces this\ndiagnostic:\n\n```dart\nclass C {}\nconst C a = null;\nconst C b = null;\nconst bool same = a [!==!] b;\n```\n\n## Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the operator to be used:\n\n```yaml\nenvironment:\n  sdk: '>=2.3.2 <2.4.0'\n```\n\nIf you need to support older versions of the SDK, then either rewrite the\ncode to not use the `==` operator, or change the code so that the\nexpression isn't in a [constant context][]:\n\n```dart\nclass C {}\nconst C a = null;\nconst C b = null;\nbool same = a == b;\n```\n\n[constant context]: /resources/glossary#constant-context\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "sdk_version_extension_methods",
    "description": "_Extension methods weren't supported until version 2.6.0, but this code is required to be able to run on earlier versions._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an extension declaration or an\nextension override is found in code that has an SDK constraint whose lower\nbound is less than 2.6.0. Using extensions wasn't supported in earlier\nversions, so this code won't be able to run against earlier versions of the\nSDK.\n\n## Example\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.6.0:\n\n```yaml\nenvironment:\n sdk: '>=2.4.0 <2.7.0'\n```\n\nIn the package that has that pubspec, code like the following produces\nthis diagnostic:\n\n```dart\n[!extension!] E on String {\n  void sayHello() {\n    print('Hello $this');\n  }\n}\n```\n\n## Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the syntax to be used:\n\n```yaml\nenvironment:\n  sdk: '>=2.6.0 <2.7.0'\n```\n\nIf you need to support older versions of the SDK, then rewrite the code to\nnot make use of extensions. The most common way to do this is to rewrite\nthe members of the extension as top-level functions (or methods) that take\nthe value that would have been bound to `this` as a parameter:\n\n```dart\nvoid sayHello(String s) {\n  print('Hello $s');\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "sdk_version_gt_gt_gt_operator",
    "description": "_The operator '>>>' wasn't supported until version 2.14.0, but this code is required to be able to run on earlier versions._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the operator `>>>` is used in\ncode that has an SDK constraint whose lower bound is less than 2.14.0. This\noperator wasn't supported in earlier versions, so this code won't be able\nto run against earlier versions of the SDK.\n\n## Example\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.14.0:\n\n```yaml\nenvironment:\n sdk: '>=2.0.0 <2.15.0'\n```\n\nIn the package that has that pubspec, code like the following produces this\ndiagnostic:\n\n```dart\nint x = 3 [!>>>!] 4;\n```\n\n## Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the operator to be used:\n\n```yaml\nenvironment:\n  sdk: '>=2.14.0 <2.15.0'\n```\n\nIf you need to support older versions of the SDK, then rewrite the code to\nnot use the `>>>` operator:\n\n```dart\nint x = logicalShiftRight(3, 4);\n\nint logicalShiftRight(int leftOperand, int rightOperand) {\n  int divisor = 1 << rightOperand;\n  if (divisor == 0) {\n    return 0;\n  }\n  return leftOperand ~/ divisor;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "sdk_version_is_expression_in_const_context",
    "description": "_The use of an is expression in a constant context wasn't supported until version 2.3.2, but this code is required to be able to run on earlier versions._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an `is` expression inside a\n[constant context][] is found in code that has an SDK constraint whose\nlower bound is less than 2.3.2. Using an `is` expression in a\n[constant context][] wasn't supported in earlier versions, so this code\nwon't be able to run against earlier versions of the SDK.\n\n## Example\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.3.2:\n\n```yaml\nenvironment:\n  sdk: '>=2.1.0 <2.4.0'\n```\n\nIn the package that has that pubspec, code like the following produces\nthis diagnostic:\n\n```dart\nconst Object x = 4;\nconst y = [!x is int!] ? 0 : 1;\n```\n\n## Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the expression to be used:\n\n```yaml\nenvironment:\n  sdk: '>=2.3.2 <2.4.0'\n```\n\nIf you need to support older versions of the SDK, then either rewrite the\ncode to not use the `is` operator, or, if that isn't possible, change the\ncode so that the `is` expression isn't in a\n[constant context][]:\n\n```dart\nconst Object x = 4;\nvar y = x is int ? 0 : 1;\n```\n\n[constant context]: /resources/glossary#constant-context\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "sdk_version_never",
    "description": "_The type 'Never' wasn't supported until version 2.12.0, but this code is required to be able to run on earlier versions._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a reference to the class `Never`\nis found in code that has an SDK constraint whose lower bound is less than\n2.12.0. This class wasn't defined in earlier versions, so this code won't\nbe able to run against earlier versions of the SDK.\n\n## Example\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.12.0:\n\n```yaml\nenvironment:\n  sdk: '>=2.5.0 <2.6.0'\n```\n\nIn the package that has that pubspec, code like the following produces this\ndiagnostic:\n\n```dart\n[!Never!] n;\n```\n\n## Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the type to be used:\n\n```yaml\nenvironment:\n  sdk: '>=2.12.0 <2.13.0'\n```\n\nIf you need to support older versions of the SDK, then rewrite the code to\nnot reference this class:\n\n```dart\ndynamic x;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "sdk_version_set_literal",
    "description": "_Set literals weren't supported until version 2.2, but this code is required to be able to run on earlier versions._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a set literal is found in code\nthat has an SDK constraint whose lower bound is less than 2.2.0. Set\nliterals weren't supported in earlier versions, so this code won't be able\nto run against earlier versions of the SDK.\n\n## Example\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.2.0:\n\n```yaml\nenvironment:\n  sdk: '>=2.1.0 <2.4.0'\n```\n\nIn the package that has that pubspec, code like the following produces this\ndiagnostic:\n\n```dart\nvar s = [!<int>{}!];\n```\n\n## Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the syntax to be used:\n\n```yaml\nenvironment:\n  sdk: '>=2.2.0 <2.4.0'\n```\n\nIf you do need to support older versions of the SDK, then replace the set\nliteral with code that creates the set without the use of a literal:\n\n```dart\nvar s = new Set<int>();\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "sdk_version_since",
    "description": "_This API is available since SDK {0}, but constraints '{1}' don't guarantee it._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "sdk_version_ui_as_code",
    "description": "_The for, if, and spread elements weren't supported until version 2.3.0, but this code is required to be able to run on earlier versions._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a for, if, or spread element is\nfound in code that has an SDK constraint whose lower bound is less than\n2.3.0. Using a for, if, or spread element wasn't supported in earlier\nversions, so this code won't be able to run against earlier versions of the\nSDK.\n\n## Example\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.3.0:\n\n```yaml\nenvironment:\n  sdk: '>=2.2.0 <2.4.0'\n```\n\nIn the package that has that pubspec, code like the following produces\nthis diagnostic:\n\n```dart\nvar digits = [[!for (int i = 0; i < 10; i++) i!]];\n```\n\n## Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the syntax to be used:\n\n```yaml\nenvironment:\n  sdk: '>=2.3.0 <2.4.0'\n```\n\nIf you need to support older versions of the SDK, then rewrite the code to\nnot make use of those elements:\n\n```dart\nvar digits = _initializeDigits();\n\nList<int> _initializeDigits() {\n  var digits = <int>[];\n  for (int i = 0; i < 10; i++) {\n    digits.add(i);\n  }\n  return digits;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "sdk_version_ui_as_code_in_const_context",
    "description": "_The if and spread elements weren't supported in constant expressions until version 2.5.0, but this code is required to be able to run on earlier versions._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an if or spread element inside\na [constant context][] is found in code that has an SDK constraint whose\nlower bound is less than 2.5.0. Using an if or spread element inside a\n[constant context][] wasn't supported in earlier versions, so this code\nwon't be able to run against earlier versions of the SDK.\n\n## Example\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.5.0:\n\n```yaml\nenvironment:\n  sdk: '>=2.4.0 <2.6.0'\n```\n\nIn the package that has that pubspec, code like the following produces\nthis diagnostic:\n\n```dart\nconst a = [1, 2];\nconst b = [[!...a!]];\n```\n\n## Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the syntax to be used:\n\n```yaml\nenvironment:\n  sdk: '>=2.5.0 <2.6.0'\n```\n\nIf you need to support older versions of the SDK, then rewrite the code to\nnot make use of those elements:\n\n```dart\nconst a = [1, 2];\nconst b = [1, 2];\n```\n\nIf that isn't possible, change the code so that the element isn't in a\n[constant context][]:\n\n```dart\nconst a = [1, 2];\nvar b = [...a];\n```\n\n[constant context]: /resources/glossary#constant-context\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "sealed_enum",
    "description": "_Enums can't be declared to be 'sealed'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "sealed_mixin",
    "description": "_A mixin can't be declared 'sealed'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "sealed_mixin_class",
    "description": "_A mixin class can't be declared 'sealed'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "setter_constructor",
    "description": "_Constructors can't be a setter._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "setter_in_function",
    "description": "_Setters can't be defined within methods or functions._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "setting_orientation_on_activity",
    "description": "_The `<activity>` element should not be locked to any orientation so that users can take advantage of the multi-window environments and larger screens on Chrome OS_",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "set_element_type_not_assignable",
    "description": "_The element type '{0}' can't be assigned to the set type '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an element in a set literal has\na type that isn't assignable to the element type of the set.\n\n## Example\n\nThe following code produces this diagnostic because the type of the string\nliteral `'0'` is `String`, which isn't assignable to `int`, the element\ntype of the set:\n\n```dart\nvar s = <int>{[!'0'!]};\n```\n\n## Common fixes\n\nIf the element type of the set literal is wrong, then change the element\ntype of the set:\n\n```dart\nvar s = <String>{'0'};\n```\n\nIf the type of the element is wrong, then change the element:\n\n```dart\nvar s = <int>{'0'.length};\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "shared_deferred_prefix",
    "description": "_The prefix of a deferred import can't be used in other import directives._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a prefix in a deferred import is\nalso used as a prefix in other imports (whether deferred or not). The\nprefix in a deferred import can't be shared with other imports because the\nprefix is used to load the imported library.\n\n## Example\n\nThe following code produces this diagnostic because the prefix `x` is used\nas the prefix for a deferred import and is also used for one other import:\n\n```dart\nimport 'dart:math' [!deferred!] as x;\nimport 'dart:convert' as x;\n\nvar y = x.json.encode(x.min(0, 1));\n```\n\n## Common fixes\n\nIf you can use a different name for the deferred import, then do so:\n\n```dart\nimport 'dart:math' deferred as math;\nimport 'dart:convert' as x;\n\nvar y = x.json.encode(math.min(0, 1));\n```\n\nIf you can use a different name for the other imports, then do so:\n\n```dart\nimport 'dart:math' deferred as x;\nimport 'dart:convert' as convert;\n\nvar y = convert.json.encode(x.min(0, 1));\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "size_annotation_dimensions",
    "description": "_'Array's must have an 'Array' annotation that matches the dimensions._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the number of dimensions\nspecified in an `Array` annotation doesn't match the number of nested\narrays specified by the type of a field.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the field `a0` has a\ntype with three nested arrays, but only two dimensions are given in the\n`Array` annotation:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  [!@Array(8, 8)!]\n  external Array<Array<Array<Uint8>>> a0;\n}\n```\n\n## Common fixes\n\nIf the type of the field is correct, then fix the annotation to have the\nrequired number of dimensions:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Array(8, 8, 4)\n  external Array<Array<Array<Uint8>>> a0;\n}\n```\n\nIf the type of the field is wrong, then fix the type of the field:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Array(8, 8)\n  external Array<Array<Uint8>> a0;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "spread_expression_from_deferred_library",
    "description": "_Constant values from a deferred library can't be spread into a const literal._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "stack_overflow",
    "description": "_The file has too many nested expressions or statements._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "static_access_to_instance_member",
    "description": "_Instance member '{0}' can't be accessed using static access._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class name is used to access\nan instance field. Instance fields don't exist on a class; they exist only\non an instance of the class.\n\n## Example\n\nThe following code produces this diagnostic because `x` is an instance\nfield:\n\n```dart\nclass C {\n  static int a = 0;\n\n  int b = 0;\n}\n\nint f() => C.[!b!];\n```\n\n## Common fixes\n\nIf you intend to access a static field, then change the name of the field\nto an existing static field:\n\n```dart\nclass C {\n  static int a = 0;\n\n  int b = 0;\n}\n\nint f() => C.a;\n```\n\nIf you intend to access the instance field, then use an instance of the\nclass to access the field:\n\n```dart\nclass C {\n  static int a = 0;\n\n  int b = 0;\n}\n\nint f(C c) => c.b;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "static_constructor",
    "description": "_Constructors can't be static._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "static_getter_without_body",
    "description": "_A 'static' getter must have a body._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "static_operator",
    "description": "_Operators can't be static._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "static_setter_without_body",
    "description": "_A 'static' setter must have a body._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "strict_raw_type",
    "description": "_The generic type '{0}' should have explicit type arguments but doesn't._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "subtype_of_base_or_final_is_not_base_final_or_sealed",
    "description": "_The mixin '{0}' must be 'base' because the supertype '{1}' is 'base'._\n\n_The mixin '{0}' must be 'base' because the supertype '{1}' is 'final'._\n\n_The type '{0}' must be 'base', 'final' or 'sealed' because the supertype '{1}' is 'base'._\n\n_The type '{0}' must be 'base', 'final' or 'sealed' because the supertype '{1}' is 'final'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class or mixin has a direct\nor indirect supertype that is either `base` or `final`, but the class or\nmixin itself isn't marked either `base`, `final`, or `sealed`.\n\n## Example\n\nThe following code produces this diagnostic because the class `B` is a\nsubtype of `A`, and `A` is a `base` class, but `B` is neither `base`,\n`final` or `sealed`:\n\n```dart\nbase class A {}\nclass [!B!] extends A {}\n```\n\n## Common fixes\n\nAdd either `base`, `final` or `sealed` to the class or mixin declaration:\n\n```dart\nbase class A {}\nfinal class B extends A {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "subtype_of_deferred_class",
    "description": "_Classes and mixins can't implement deferred classes._\n\n_Classes can't extend deferred classes._\n\n_Classes can't mixin deferred classes._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a type (class or mixin) is a\nsubtype of a class from a library being imported using a deferred import.\nThe supertypes of a type must be compiled at the same time as the type, and\nclasses from deferred libraries aren't compiled until the library is\nloaded.\n\nFor more information, check out\n[Lazily loading a library](https://dart.dev/language/libraries#lazily-loading-a-library).\n\n## Example\n\nGiven a file `a.dart` that defines the class `A`:\n\n```dart\nclass A {}\n```\n\nThe following code produces this diagnostic because the superclass of `B`\nis declared in a deferred library:\n\n```dart\nimport 'a.dart' deferred as a;\n\nclass B extends [!a.A!] {}\n```\n\n## Common fixes\n\nIf you need to create a subtype of a type from the deferred library, then\nremove the `deferred` keyword:\n\n```dart\nimport 'a.dart' as a;\n\nclass B extends a.A {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "subtype_of_disallowed_type",
    "description": "_'{0}' can't be used as a superclass constraint._\n\n_Classes and mixins can't implement '{0}'._\n\n_Classes can't extend '{0}'._\n\n_Classes can't mixin '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when one of the restricted classes is\nused in either an `extends`, `implements`, `with`, or `on` clause. The\nclasses `bool`, `double`, `FutureOr`, `int`, `Null`, `num`, and `String`\nare all restricted in this way, to allow for more efficient\nimplementations.\n\n## Examples\n\nThe following code produces this diagnostic because `String` is used in an\n`extends` clause:\n\n```dart\nclass A extends [!String!] {}\n```\n\nThe following code produces this diagnostic because `String` is used in an\n`implements` clause:\n\n```dart\nclass B implements [!String!] {}\n```\n\nThe following code produces this diagnostic because `String` is used in a\n`with` clause:\n\n```dart\nclass C with [!String!] {}\n```\n\nThe following code produces this diagnostic because `String` is used in an\n`on` clause:\n\n```dart\nmixin M on [!String!] {}\n```\n\n## Common fixes\n\nIf a different type should be specified, then replace the type:\n\n```dart\nclass A extends Object {}\n```\n\nIf there isn't a different type that would be appropriate, then remove the\ntype, and possibly the whole clause:\n\n```dart\nclass B {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "subtype_of_ffi_class",
    "description": "_The class '{0}' can't extend '{1}'._\n\n_The class '{0}' can't implement '{1}'._\n\n_The class '{0}' can't mix in '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class extends any FFI class\nother than `Struct` or `Union`, or implements or mixes in any FFI class.\n`Struct` and `Union` are the only FFI classes that can be subtyped, and\nthen only by extending them.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the class `C` extends\n`Double`:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends [!Double!] {}\n```\n\n## Common fixes\n\nIf the class should extend either `Struct` or `Union`, then change the\ndeclaration of the class:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Int32()\n  external int i;\n}\n```\n\nIf the class shouldn't extend either `Struct` or `Union`, then remove any\nreferences to FFI classes:\n\n```dart\nfinal class C {}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "subtype_of_sealed_class",
    "description": "_The class '{0}' shouldn't be extended, mixed in, or implemented because it's sealed._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a sealed class (one that either\nhas the [`sealed`][meta-sealed] annotation or inherits or mixes in a\nsealed class) is referenced in either the `extends`, `implements`, or\n`with` clause of a class or mixin declaration if the declaration isn't in\nthe same package as the sealed class.\n\n## Example\n\nGiven a library in a package other than the package being analyzed that\ncontains the following:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass A {}\n\n@sealed\nclass B {}\n```\n\nThe following code produces this diagnostic because `C`, which isn't in the\nsame package as `B`, is extending the sealed class `B`:\n\n```dart\nimport 'package:a/a.dart';\n\n[!class C extends B {}!]\n```\n\n## Common fixes\n\nIf the class doesn't need to be a subtype of the sealed class, then change\nthe declaration so that it isn't:\n\n```dart\nimport 'package:a/a.dart';\n\nclass B extends A {}\n```\n\nIf the class needs to be a subtype of the sealed class, then either change\nthe sealed class so that it's no longer sealed or move the subclass into\nthe same package as the sealed class.\n\n[meta-sealed]: https://pub.dev/documentation/meta/latest/meta/sealed-constant.html\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "subtype_of_struct_class",
    "description": "_The class '{0}' can't extend '{1}' because '{1}' is a subtype of 'Struct', 'Union', or 'AbiSpecificInteger'._\n\n_The class '{0}' can't implement '{1}' because '{1}' is a subtype of 'Struct', 'Union', or 'AbiSpecificInteger'._\n\n_The class '{0}' can't mix in '{1}' because '{1}' is a subtype of 'Struct', 'Union', or 'AbiSpecificInteger'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class extends, implements, or\nmixes in a class that extends either `Struct` or `Union`. Classes can only\nextend either `Struct` or `Union` directly.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the class `C` extends\n`S`, and `S` extends `Struct`:\n\n```dart\nimport 'dart:ffi';\n\nfinal class S extends Struct {\n  external Pointer f;\n}\n\nfinal class C extends [!S!] {\n  external Pointer g;\n}\n```\n\n## Common fixes\n\nIf you're trying to define a struct or union that shares some fields\ndeclared by a different struct or union, then extend `Struct` or `Union`\ndirectly and copy the shared fields:\n\n```dart\nimport 'dart:ffi';\n\nfinal class S extends Struct {\n  external Pointer f;\n}\n\nfinal class C extends Struct {\n  external Pointer f;\n\n  external Pointer g;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "supertype_expands_to_type_parameter",
    "description": "_A type alias that expands to a type parameter can't be implemented._\n\n_A type alias that expands to a type parameter can't be mixed in._\n\n_A type alias that expands to a type parameter can't be used as a superclass constraint._\n\n_A type alias that expands to a type parameter can't be used as a superclass._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a type alias that expands to a\ntype parameter is used in an `extends`, `implements`, `with`, or `on`\nclause.\n\n## Example\n\nThe following code produces this diagnostic because the type alias `T`,\nwhich expands to the type parameter `S`, is used in the `extends` clause of\nthe class `C`:\n\n```dart\ntypedef T<S> = S;\n\nclass C extends [!T!]<Object> {}\n```\n\n## Common fixes\n\nUse the value of the type argument directly:\n\n```dart\ntypedef T<S> = S;\n\nclass C extends Object {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "super_formal_parameter_type_is_not_subtype_of_associated",
    "description": "_The type '{0}' of this parameter isn't a subtype of the type '{1}' of the associated super constructor parameter._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the type of a super parameter\nisn't a subtype of the corresponding parameter from the super constructor.\n\n## Example\n\nThe following code produces this diagnostic because the type of the super\nparameter `x` in the constructor for `B` isn't a subtype of the parameter\n`x` in the constructor for `A`:\n\n```dart\nclass A {\n  A(num x);\n}\n\nclass B extends A {\n  B(String super.[!x!]);\n}\n```\n\n## Common fixes\n\nIf the type of the super parameter can be the same as the parameter from\nthe super constructor, then remove the type annotation from the super\nparameter (if the type is implicit, it is inferred from the type in the\nsuper constructor):\n\n```dart\nclass A {\n  A(num x);\n}\n\nclass B extends A {\n  B(super.x);\n}\n```\n\nIf the type of the super parameter can be a subtype of the corresponding\nparameter's type, then change the type of the super parameter:\n\n```dart\nclass A {\n  A(num x);\n}\n\nclass B extends A {\n  B(int super.x);\n}\n```\n\nIf the type of the super parameter can't be changed, then use a normal\nparameter instead of a super parameter:\n\n```dart\nclass A {\n  A(num x);\n}\n\nclass B extends A {\n  B(String x) : super(x.length);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "super_formal_parameter_without_associated_named",
    "description": "_No associated named super constructor parameter._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when there's a named super parameter\nin a constructor and the implicitly or explicitly invoked super\nconstructor doesn't have a named parameter with the same name.\n\nNamed super parameters are associated by name with named parameters in the\nsuper constructor.\n\n## Example\n\nThe following code produces this diagnostic because the constructor in `A`\ndoesn't have a parameter named `y`:\n\n```dart\nclass A {\n  A({int? x});\n}\n\nclass B extends A {\n  B({super.[!y!]});\n}\n```\n\n## Common fixes\n\nIf the super parameter should be associated with an existing parameter\nfrom the super constructor, then change the name to match the name of the\ncorresponding parameter:\n\n```dart\nclass A {\n  A({int? x});\n}\n\nclass B extends A {\n  B({super.x});\n}\n```\n\nIf the super parameter should be associated with a parameter that hasn't\nyet been added to the super constructor, then add it:\n\n```dart\nclass A {\n  A({int? x, int? y});\n}\n\nclass B extends A {\n  B({super.y});\n}\n```\n\nIf the super parameter doesn't correspond to a named parameter from the\nsuper constructor, then change it to be a normal parameter:\n\n```dart\nclass A {\n  A({int? x});\n}\n\nclass B extends A {\n  B({int? y});\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "super_formal_parameter_without_associated_positional",
    "description": "_No associated positional super constructor parameter._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when there's a positional super\nparameter in a constructor and the implicitly or explicitly invoked super\nconstructor doesn't have a positional parameter at the corresponding\nindex.\n\nPositional super parameters are associated with positional parameters in\nthe super constructor by their index. That is, the first super parameter\nis associated with the first positional parameter in the super\nconstructor, the second with the second, and so on.\n\n## Examples\n\nThe following code produces this diagnostic because the constructor in `B`\nhas a positional super parameter, but there's no positional parameter in\nthe super constructor in `A`:\n\n```dart\nclass A {\n  A({int? x});\n}\n\nclass B extends A {\n  B(super.[!x!]);\n}\n```\n\nThe following code produces this diagnostic because the constructor in `B`\nhas two positional super parameters, but there's only one positional\nparameter in the super constructor in `A`, which means that there's no\ncorresponding parameter for `y`:\n\n```dart\nclass A {\n  A(int x);\n}\n\nclass B extends A {\n  B(super.x, super.[!y!]);\n}\n```\n\n## Common fixes\n\nIf the super constructor should have a positional parameter corresponding\nto the super parameter, then update the super constructor appropriately:\n\n```dart\nclass A {\n  A(int x, int y);\n}\n\nclass B extends A {\n  B(super.x, super.y);\n}\n```\n\nIf the super constructor is correct, or can't be changed, then convert the\nsuper parameter into a normal parameter:\n\n```dart\nclass A {\n  A(int x);\n}\n\nclass B extends A {\n  B(super.x, int y);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "super_initializer_in_object",
    "description": "_The class 'Object' can't invoke a constructor from a superclass._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "super_invocation_not_last",
    "description": "_The superconstructor call must be last in an initializer list: '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the initializer list of a\nconstructor contains an invocation of a constructor in the superclass, but\nthe invocation isn't the last item in the initializer list.\n\n## Example\n\nThe following code produces this diagnostic because the invocation of the\nsuperclass' constructor isn't the last item in the initializer list:\n\n```dart\nclass A {\n  A(int x);\n}\n\nclass B extends A {\n  B(int x) : [!super!](x), assert(x >= 0);\n}\n```\n\n## Common fixes\n\nMove the invocation of the superclass' constructor to the end of the\ninitializer list:\n\n```dart\nclass A {\n  A(int x);\n}\n\nclass B extends A {\n  B(int x) : assert(x >= 0), super(x);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": [
      "invalid_super_invocation"
    ]
  },
  {
    "id": "super_in_enum_constructor",
    "description": "_The enum constructor can't have a 'super' initializer._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the initializer list in a\nconstructor in an enum contains an invocation of a super constructor.\n\n## Example\n\nThe following code produces this diagnostic because the constructor in\nthe enum `E` has a super constructor invocation in the initializer list:\n\n```dart\nenum E {\n  e;\n\n  const E() : [!super!]();\n}\n```\n\n## Common fixes\n\nRemove the super constructor invocation:\n\n```dart\nenum E {\n  e;\n\n  const E();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "super_in_extension",
    "description": "_The 'super' keyword can't be used in an extension because an extension doesn't have a superclass._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a member declared inside an\nextension uses the `super` keyword . Extensions aren't classes and don't\nhave superclasses, so the `super` keyword serves no purpose.\n\n## Example\n\nThe following code produces this diagnostic because `super` can't be used\nin an extension:\n\n```dart\nextension E on Object {\n  String get displayString => [!super!].toString();\n}\n```\n\n## Common fixes\n\nRemove the `super` keyword :\n\n```dart\nextension E on Object {\n  String get displayString => toString();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "super_in_extension_type",
    "description": "_The 'super' keyword can't be used in an extension type because an extension type doesn't have a superclass._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when `super` is used in an instance\nmember of an extension type. Extension types don't have superclasses, so\nthere's no inherited member that could be invoked.\n\n## Example\n\nThe following code produces this diagnostic because :\n\n```dart\nextension type E(String s) {\n  void m() {\n    [!super!].m();\n  }\n}\n```\n\n## Common fixes\n\nReplace or remove the `super` invocation:\n\n```dart\nextension type E(String s) {\n  void m() {\n    s.toLowerCase();\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "super_in_invalid_context",
    "description": "_Invalid context for 'super' invocation._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the keyword `super` is used\noutside of an instance method.\n\n## Example\n\nThe following code produces this diagnostic because `super` is used in a\ntop-level function:\n\n```dart\nvoid f() {\n  [!super!].f();\n}\n```\n\n## Common fixes\n\nRewrite the code to not use `super`.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "super_in_redirecting_constructor",
    "description": "_The redirecting constructor can't have a 'super' initializer._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor that redirects to\nanother constructor also attempts to invoke a constructor from the\nsuperclass. The superclass constructor will be invoked when the constructor\nthat the redirecting constructor is redirected to is invoked.\n\n## Example\n\nThe following code produces this diagnostic because the constructor `C.a`\nboth redirects to `C.b` and invokes a constructor from the superclass:\n\n```dart\nclass C {\n  C.a() : this.b(), [!super()!];\n  C.b();\n}\n```\n\n## Common fixes\n\nRemove the invocation of the `super` constructor:\n\n```dart\nclass C {\n  C.a() : this.b();\n  C.b();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "switch_case_completes_normally",
    "description": "_The 'case' shouldn't complete normally._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the statements following a\n`case` label in a `switch` statement could fall through to the next `case`\nor `default` label.\n\n## Example\n\nThe following code produces this diagnostic because the `case` label with\n a value of zero (`0`) falls through to the `default` statements:\n\n```dart\nvoid f(int a) {\n  switch (a) {\n    [!case!] 0:\n      print(0);\n    default:\n      return;\n  }\n}\n```\n\n## Common fixes\n\nChange the flow of control so that the `case` won't fall through. There\nare several ways that this can be done, including adding one of the\nfollowing at the end of the current list of statements:\n- a `return` statement,\n- a `throw` expression,\n- a `break` statement,\n- a `continue`, or\n- an invocation of a function or method whose return type is `Never`.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "switch_expression_not_assignable",
    "description": "_Type '{0}' of the switch expression isn't assignable to the type '{1}' of case expressions._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the type of the expression in a\n`switch` statement isn't assignable to the type of the expressions in the\n`case` clauses.\n\n## Example\n\nThe following code produces this diagnostic because the type of `s`\n(`String`) isn't assignable to the type of `0` (`int`):\n\n```dart\nvoid f(String s) {\n  switch ([!s!]) {\n    case 0:\n      break;\n  }\n}\n```\n\n## Common fixes\n\nIf the type of the `case` expressions is correct, then change the\nexpression in the `switch` statement to have the correct type:\n\n```dart\nvoid f(String s) {\n  switch (int.parse(s)) {\n    case 0:\n      break;\n  }\n}\n```\n\nIf the type of the `switch` expression is correct, then change the `case`\nexpressions to have the correct type:\n\n```dart\nvoid f(String s) {\n  switch (s) {\n    case '0':\n      break;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "switch_has_case_after_default_case",
    "description": "_The default case should be the last case in a switch statement._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "switch_has_multiple_default_cases",
    "description": "_The 'default' case can only be declared once._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "tearoff_of_generative_constructor_of_abstract_class",
    "description": "_A generative constructor of an abstract class can't be torn off._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a generative constructor from an\nabstract class is being torn off. This isn't allowed because it isn't valid\nto create an instance of an abstract class, which means that there isn't\nany valid use for the torn off constructor.\n\n## Example\n\nThe following code produces this diagnostic because the constructor `C.new`\nis being torn off and the class `C` is an abstract class:\n\n```dart\nabstract class C {\n  C();\n}\n\nvoid f() {\n  [!C.new!];\n}\n```\n\n## Common fixes\n\nTear off the constructor of a concrete class.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "text_direction_code_point_in_comment",
    "description": "_The Unicode code point 'U+{0}' changes the appearance of text from how it's interpreted by the compiler._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it encounters source that\ncontains text direction Unicode code points. These code points cause\nsource code in either a string literal or a comment to be interpreted\nand compiled differently than how it appears in editors, leading to\npossible security vulnerabilities.\n\n## Example\n\nThe following code produces this diagnostic twice because there are\nhidden characters at the start and end of the label string:\n\n```dart\nvar label = '[!I!]nteractive text[!'!];\n```\n\n## Common fixes\n\nIf the code points are intended to be included in the string literal,\nthen escape them:\n\n```dart\nvar label = '\\u202AInteractive text\\u202C';\n```\n\nIf the code points aren't intended to be included in the string literal,\nthen remove them:\n\n```dart\nvar label = 'Interactive text';\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "text_direction_code_point_in_literal",
    "description": "_The Unicode code point 'U+{0}' changes the appearance of text from how it's interpreted by the compiler._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it encounters source that\ncontains text direction Unicode code points. These code points cause\nsource code in either a string literal or a comment to be interpreted\nand compiled differently than how it appears in editors, leading to\npossible security vulnerabilities.\n\n## Example\n\nThe following code produces this diagnostic twice because there are\nhidden characters at the start and end of the label string:\n\n```dart\nvar label = '[!I!]nteractive text[!'!];\n```\n\n## Common fixes\n\nIf the code points are intended to be included in the string literal,\nthen escape them:\n\n```dart\nvar label = '\\u202AInteractive text\\u202C';\n```\n\nIf the code points aren't intended to be included in the string literal,\nthen remove them:\n\n```dart\nvar label = 'Interactive text';\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "throw_of_invalid_type",
    "description": "_The type '{0}' of the thrown expression must be assignable to 'Object'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the type of the expression in a\nthrow expression isn't assignable to `Object`. It isn't valid to throw\n`null`, so it isn't valid to use an expression that might evaluate to\n`null`.\n\n## Example\n\nThe following code produces this diagnostic because `s` might be `null`:\n\n```dart\nvoid f(String? s) {\n  throw [!s!];\n}\n```\n\n## Common fixes\n\nAdd an explicit null-check to the expression:\n\n```dart\nvoid f(String? s) {\n  throw s!;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "todo",
    "description": "_{0}_",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "top_level_cycle",
    "description": "_The type of '{0}' can't be inferred because it depends on itself through the cycle: {1}._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a top-level variable has no type\nannotation and the variable's initializer refers to the variable, either\ndirectly or indirectly.\n\n## Example\n\nThe following code produces this diagnostic because the variables `x` and\n`y` are defined in terms of each other, and neither has an explicit type,\nso the type of the other can't be inferred:\n\n```dart\nvar x = y;\nvar y = [!x!];\n```\n\n## Common fixes\n\nIf the two variables don't need to refer to each other, then break the\ncycle:\n\n```dart\nvar x = 0;\nvar y = x;\n```\n\nIf the two variables need to refer to each other, then give at least one of\nthem an explicit type:\n\n```dart\nint x = y;\nvar y = x;\n```\n\nNote, however, that while this code doesn't produce any diagnostics, it\nwill produce a stack overflow at runtime unless at least one of the\nvariables is assigned a value that doesn't depend on the other variables\nbefore any of the variables in the cycle are referenced.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "top_level_operator",
    "description": "_Operators must be declared within a class._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "typedef_in_class",
    "description": "_Typedefs can't be declared inside classes._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "type_alias_cannot_reference_itself",
    "description": "_Typedefs can't reference themselves directly or recursively via another typedef._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a typedef refers to itself,\neither directly or indirectly.\n\n## Example\n\nThe following code produces this diagnostic because `F` depends on itself\nindirectly through `G`:\n\n```dart\ntypedef [!F!] = void Function(G);\ntypedef G = void Function(F);\n```\n\n## Common fixes\n\nChange one or more of the typedefs in the cycle so that none of them refer\nto themselves:\n\n```dart\ntypedef F = void Function(G);\ntypedef G = void Function(int);\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "type_annotation_deferred_class",
    "description": "_The deferred type '{0}' can't be used in a declaration, cast, or type test._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the type annotation is in a\nvariable declaration, or the type used in a cast (`as`) or type test (`is`)\nis a type declared in a library that is imported using a deferred import.\nThese types are required to be available at compile time, but aren't.\n\nFor more information, check out\n[Lazily loading a library](https://dart.dev/language/libraries#lazily-loading-a-library).\n\n## Example\n\nThe following code produces this diagnostic because the type of the\nparameter `f` is imported from a deferred library:\n\n```dart\nimport 'dart:io' deferred as io;\n\nvoid f([!io.File!] f) {}\n```\n\n## Common fixes\n\nIf you need to reference the imported type, then remove the `deferred`\nkeyword:\n\n```dart\nimport 'dart:io' as io;\n\nvoid f(io.File f) {}\n```\n\nIf the import is required to be deferred and there's another type that is\nappropriate, then use that type in place of the type from the deferred\nlibrary.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "type_arguments_on_type_variable",
    "description": "_Can't use type arguments with type variable '{0}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "type_argument_not_matching_bounds",
    "description": "_'{0}' doesn't conform to the bound '{1}' of the type parameter '{2}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a type argument isn't the same\nas or a subclass of the bounds of the corresponding type parameter.\n\n## Example\n\nThe following code produces this diagnostic because `String` isn't a\nsubclass of `num`:\n\n```dart\nclass A<E extends num> {}\n\nvar a = A<[!String!]>();\n```\n\n## Common fixes\n\nChange the type argument to be a subclass of the bounds:\n\n```dart\nclass A<E extends num> {}\n\nvar a = A<int>();\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "type_before_factory",
    "description": "_Factory constructors cannot have a return type._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "type_check_with_null",
    "description": "_Tests for non-null should be done with '!= null'._\n\n_Tests for null should be done with '== null'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when there's a type check (using the\n`as` operator) where the type is `Null`. There's only one value whose type\nis `Null`, so the code is both more readable and more performant when it\ntests for `null` explicitly.\n\n## Examples\n\nThe following code produces this diagnostic because the code is testing to\nsee whether the value of `s` is `null` by using a type check:\n\n```dart\nvoid f(String? s) {\n  if ([!s is Null!]) {\n    return;\n  }\n  print(s);\n}\n```\n\nThe following code produces this diagnostic because the code is testing to\nsee whether the value of `s` is something other than `null` by using a type\ncheck:\n\n```dart\nvoid f(String? s) {\n  if ([!s is! Null!]) {\n    print(s);\n  }\n}\n```\n\n## Common fixes\n\nReplace the type check with the equivalent comparison with `null`:\n\n```dart\nvoid f(String? s) {\n  if (s == null) {\n    return;\n  }\n  print(s);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "type_parameter_on_constructor",
    "description": "_Constructors can't have type parameters._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "type_parameter_on_operator",
    "description": "_Types parameters aren't allowed when defining an operator._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "type_parameter_referenced_by_static",
    "description": "_Static members can't reference type parameters of the class._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a static member references a\ntype parameter that is declared for the class. Type parameters only have\nmeaning for instances of the class.\n\n## Example\n\nThe following code produces this diagnostic because the static method\n`hasType` has a reference to the type parameter `T`:\n\n```dart\nclass C<T> {\n  static bool hasType(Object o) => o is [!T!];\n}\n```\n\n## Common fixes\n\nIf the member can be an instance member, then remove the keyword `static`:\n\n```dart\nclass C<T> {\n  bool hasType(Object o) => o is T;\n}\n```\n\nIf the member must be a static member, then make the member be generic:\n\n```dart\nclass C<T> {\n  static bool hasType<S>(Object o) => o is S;\n}\n```\n\nNote, however, that there isn't a relationship between `T` and `S`, so this\nsecond option changes the semantics from what was likely to be intended.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "type_parameter_supertype_of_its_bound",
    "description": "_'{0}' can't be a supertype of its upper bound._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the bound of a type parameter\n(the type following the `extends` keyword) is either directly or indirectly\nthe type parameter itself. Stating that the type parameter must be the same\nas itself or a subtype of itself or a subtype of itself isn't helpful\nbecause it will always be the same as itself.\n\n## Examples\n\nThe following code produces this diagnostic because the bound of `T` is\n`T`:\n\n```dart\nclass C<[!T!] extends T> {}\n```\n\nThe following code produces this diagnostic because the bound of `T1` is\n`T2`, and the bound of `T2` is `T1`, effectively making the bound of `T1`\nbe `T1`:\n\n```dart\nclass C<[!T1!] extends T2, T2 extends T1> {}\n```\n\n## Common fixes\n\nIf the type parameter needs to be a subclass of some type, then replace the\nbound with the required type:\n\n```dart\nclass C<T extends num> {}\n```\n\nIf the type parameter can be any type, then remove the `extends` clause:\n\n```dart\nclass C<T> {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "type_test_with_non_type",
    "description": "_The name '{0}' isn't a type and can't be used in an 'is' expression._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the right-hand side of an `is`\nor `is!` test isn't a type.\n\n## Example\n\nThe following code produces this diagnostic because the right-hand side is\na parameter, not a type:\n\n```dart\ntypedef B = int Function(int);\n\nvoid f(Object a, B b) {\n  if (a is [!b!]) {\n    return;\n  }\n}\n```\n\n## Common fixes\n\nIf you intended to use a type test, then replace the right-hand side with a\ntype:\n\n```dart\ntypedef B = int Function(int);\n\nvoid f(Object a, B b) {\n  if (a is B) {\n    return;\n  }\n}\n```\n\nIf you intended to use a different kind of test, then change the test:\n\n```dart\ntypedef B = int Function(int);\n\nvoid f(Object a, B b) {\n  if (a == b) {\n    return;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "type_test_with_undefined_name",
    "description": "_The name '{0}' isn't defined, so it can't be used in an 'is' expression._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the name following the `is` in a\ntype test expression isn't defined.\n\n## Example\n\nThe following code produces this diagnostic because the name `Srting` isn't\ndefined:\n\n```dart\nvoid f(Object o) {\n  if (o is [!Srting!]) {\n    // ...\n  }\n}\n```\n\n## Common fixes\n\nReplace the name with the name of a type:\n\n```dart\nvoid f(Object o) {\n  if (o is String) {\n    // ...\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unable_get_content",
    "description": "_Unable to get content of '{0}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unchecked_use_of_nullable_value",
    "description": "_A nullable expression can't be used as a condition._\n\n_A nullable expression can't be used as an iterator in a for-in loop._\n\n_A nullable expression can't be used in a spread._\n\n_A nullable expression can't be used in a yield-each statement._\n\n_The function can't be unconditionally invoked because it can be 'null'._\n\n_The method '{0}' can't be unconditionally invoked because the receiver can be 'null'._\n\n_The operator '{0}' can't be unconditionally invoked because the receiver can be 'null'._\n\n_The property '{0}' can't be unconditionally accessed because the receiver can be 'null'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an expression whose type is\n[potentially non-nullable][] is dereferenced without first verifying that\nthe value isn't `null`.\n\n## Example\n\nThe following code produces this diagnostic because `s` can be `null` at\nthe point where it's referenced:\n\n```dart\nvoid f(String? s) {\n  if (s.[!length!] > 3) {\n    // ...\n  }\n}\n```\n\n## Common fixes\n\nIf the value really can be `null`, then add a test to ensure that members\nare only accessed when the value isn't `null`:\n\n```dart\nvoid f(String? s) {\n  if (s != null && s.length > 3) {\n    // ...\n  }\n}\n```\n\nIf the expression is a variable and the value should never be `null`, then\nchange the type of the variable to be non-nullable:\n\n```dart\nvoid f(String s) {\n  if (s.length > 3) {\n    // ...\n  }\n}\n```\n\nIf you believe that the value of the expression should never be `null`, but\nyou can't change the type of the variable, and you're willing to risk\nhaving an exception thrown at runtime if you're wrong, then you can assert\nthat the value isn't null:\n\n```dart\nvoid f(String? s) {\n  if (s!.length > 3) {\n    // ...\n  }\n}\n```\n\n[potentially non-nullable]: /resources/glossary#potentially-non-nullable\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_annotation",
    "description": "_Undefined name '{0}' used as an annotation._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a name that isn't defined is\nused as an annotation.\n\n## Example\n\nThe following code produces this diagnostic because the name `undefined`\nisn't defined:\n\n```dart\n[!@undefined!]\nvoid f() {}\n```\n\n## Common fixes\n\nIf the name is correct, but it isn't declared yet, then declare the name as\na constant value:\n\n```dart\nconst undefined = 'undefined';\n\n@undefined\nvoid f() {}\n```\n\nIf the name is wrong, replace the name with the name of a valid constant:\n\n```dart\n@deprecated\nvoid f() {}\n```\n\nOtherwise, remove the annotation.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_class",
    "description": "_Undefined class '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it encounters an identifier that\nappears to be the name of a class but either isn't defined or isn't visible\nin the scope in which it's being referenced.\n\n## Example\n\nThe following code produces this diagnostic because `Piont` isn't defined:\n\n```dart\nclass Point {}\n\nvoid f([!Piont!] p) {}\n```\n\n## Common fixes\n\nIf the identifier isn't defined, then either define it or replace it with\nthe name of a class that is defined. The example above can be corrected by\nfixing the spelling of the class:\n\n```dart\nclass Point {}\n\nvoid f(Point p) {}\n```\n\nIf the class is defined but isn't visible, then you probably need to add an\nimport.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_constructor_in_initializer",
    "description": "_The class '{0}' doesn't have a constructor named '{1}'._\n\n_The class '{0}' doesn't have an unnamed constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a superclass constructor is\ninvoked in the initializer list of a constructor, but the superclass\ndoesn't define the constructor being invoked.\n\n## Examples\n\nThe following code produces this diagnostic because `A` doesn't have an\nunnamed constructor:\n\n```dart\nclass A {\n  A.n();\n}\nclass B extends A {\n  B() : [!super()!];\n}\n```\n\nThe following code produces this diagnostic because `A` doesn't have a\nconstructor named `m`:\n\n```dart\nclass A {\n  A.n();\n}\nclass B extends A {\n  B() : [!super.m()!];\n}\n```\n\n## Common fixes\n\nIf the superclass defines a constructor that should be invoked, then change\nthe constructor being invoked:\n\n```dart\nclass A {\n  A.n();\n}\nclass B extends A {\n  B() : super.n();\n}\n```\n\nIf the superclass doesn't define an appropriate constructor, then define\nthe constructor being invoked:\n\n```dart\nclass A {\n  A.m();\n  A.n();\n}\nclass B extends A {\n  B() : super.m();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_enum_constant",
    "description": "_There's no constant named '{0}' in '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it encounters an identifier\nthat appears to be the name of an enum value, and the name either isn't\ndefined or isn't visible in the scope in which it's being referenced.\n\n## Example\n\nThe following code produces this diagnostic because `E` doesn't define a\nconstant named `c`:\n\n```dart\nenum E {a, b}\n\nvar e = E.[!c!];\n```\n\n## Common fixes\n\nIf the constant should be defined, then add it to the declaration of the\nenum:\n\n```dart\nenum E {a, b, c}\n\nvar e = E.c;\n```\n\nIf the constant shouldn't be defined, then change the name to the name of\nan existing constant:\n\n```dart\nenum E {a, b}\n\nvar e = E.b;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_enum_constructor",
    "description": "_The enum doesn't have a constructor named '{0}'._\n\n_The enum doesn't have an unnamed constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the constructor invoked to\ninitialize an enum value doesn't exist.\n\n## Examples\n\nThe following code produces this diagnostic because the enum value `c`\nis being initialized by the unnamed constructor, but there's no unnamed\nconstructor defined in `E`:\n\n```dart\nenum E {\n  [!c!]();\n\n  const E.x();\n}\n```\n\nThe following code produces this diagnostic because the enum value `c` is\nbeing initialized by the constructor named `x`, but there's no constructor\nnamed `x` defined in `E`:\n\n```dart\nenum E {\n  c.[!x!]();\n\n  const E.y();\n}\n```\n\n## Common fixes\n\nIf the enum value is being initialized by the unnamed constructor and one\nof the named constructors should have been used, then add the name of the\nconstructor:\n\n```dart\nenum E {\n  c.x();\n\n  const E.x();\n}\n```\n\nIf the enum value is being initialized by the unnamed constructor and none\nof the named constructors are appropriate, then define the unnamed\nconstructor:\n\n```dart\nenum E {\n  c();\n\n  const E();\n}\n```\n\nIf the enum value is being initialized by a named constructor and one of\nthe existing constructors should have been used, then change the name of\nthe constructor being invoked (or remove it if the unnamed constructor\nshould be used):\n\n```dart\nenum E {\n  c.y();\n\n  const E();\n  const E.y();\n}\n```\n\nIf the enum value is being initialized by a named constructor and none of\nthe existing constructors should have been used, then define a constructor\nwith the name that was used:\n\n```dart\nenum E {\n  c.x();\n\n  const E.x();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_extension_getter",
    "description": "_The getter '{0}' isn't defined for the extension '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an extension override is used to\ninvoke a getter, but the getter isn't defined by the specified extension.\nThe analyzer also produces this diagnostic when a static getter is\nreferenced but isn't defined by the specified extension.\n\n## Examples\n\nThe following code produces this diagnostic because the extension `E`\ndoesn't declare an instance getter named `b`:\n\n```dart\nextension E on String {\n  String get a => 'a';\n}\n\nextension F on String {\n  String get b => 'b';\n}\n\nvoid f() {\n  E('c').[!b!];\n}\n```\n\nThe following code produces this diagnostic because the extension `E`\ndoesn't declare a static getter named `a`:\n\n```dart\nextension E on String {}\n\nvar x = E.[!a!];\n```\n\n## Common fixes\n\nIf the name of the getter is incorrect, then change it to the name of an\nexisting getter:\n\n```dart\nextension E on String {\n  String get a => 'a';\n}\n\nextension F on String {\n  String get b => 'b';\n}\n\nvoid f() {\n  E('c').a;\n}\n```\n\nIf the name of the getter is correct but the name of the extension is\nwrong, then change the name of the extension to the correct name:\n\n```dart\nextension E on String {\n  String get a => 'a';\n}\n\nextension F on String {\n  String get b => 'b';\n}\n\nvoid f() {\n  F('c').b;\n}\n```\n\nIf the name of the getter and extension are both correct, but the getter\nisn't defined, then define the getter:\n\n```dart\nextension E on String {\n  String get a => 'a';\n  String get b => 'z';\n}\n\nextension F on String {\n  String get b => 'b';\n}\n\nvoid f() {\n  E('c').b;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_extension_method",
    "description": "_The method '{0}' isn't defined for the extension '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an extension override is used to\ninvoke a method, but the method isn't defined by the specified extension.\nThe analyzer also produces this diagnostic when a static method is\nreferenced but isn't defined by the specified extension.\n\n## Examples\n\nThe following code produces this diagnostic because the extension `E`\ndoesn't declare an instance method named `b`:\n\n```dart\nextension E on String {\n  String a() => 'a';\n}\n\nextension F on String {\n  String b() => 'b';\n}\n\nvoid f() {\n  E('c').[!b!]();\n}\n```\n\nThe following code produces this diagnostic because the extension `E`\ndoesn't declare a static method named `a`:\n\n```dart\nextension E on String {}\n\nvar x = E.[!a!]();\n```\n\n## Common fixes\n\nIf the name of the method is incorrect, then change it to the name of an\nexisting method:\n\n```dart\nextension E on String {\n  String a() => 'a';\n}\n\nextension F on String {\n  String b() => 'b';\n}\n\nvoid f() {\n  E('c').a();\n}\n```\n\nIf the name of the method is correct, but the name of the extension is\nwrong, then change the name of the extension to the correct name:\n\n```dart\nextension E on String {\n  String a() => 'a';\n}\n\nextension F on String {\n  String b() => 'b';\n}\n\nvoid f() {\n  F('c').b();\n}\n```\n\nIf the name of the method and extension are both correct, but the method\nisn't defined, then define the method:\n\n```dart\nextension E on String {\n  String a() => 'a';\n  String b() => 'z';\n}\n\nextension F on String {\n  String b() => 'b';\n}\n\nvoid f() {\n  E('c').b();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_extension_operator",
    "description": "_The operator '{0}' isn't defined for the extension '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an operator is invoked on a\nspecific extension when that extension doesn't implement the operator.\n\n## Example\n\nThe following code produces this diagnostic because the extension `E`\ndoesn't define the operator `*`:\n\n```dart\nvar x = E('') [!*!] 4;\n\nextension E on String {}\n```\n\n## Common fixes\n\nIf the extension is expected to implement the operator, then add an\nimplementation of the operator to the extension:\n\n```dart\nvar x = E('') * 4;\n\nextension E on String {\n  int operator *(int multiplier) => length * multiplier;\n}\n```\n\nIf the operator is defined by a different extension, then change the name\nof the extension to the name of the one that defines the operator.\n\nIf the operator is defined on the argument of the extension override, then\nremove the extension override:\n\n```dart\nvar x = '' * 4;\n\nextension E on String {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_extension_setter",
    "description": "_The setter '{0}' isn't defined for the extension '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an extension override is used to\ninvoke a setter, but the setter isn't defined by the specified extension.\nThe analyzer also produces this diagnostic when a static setter is\nreferenced but isn't defined by the specified extension.\n\n## Examples\n\nThe following code produces this diagnostic because the extension `E`\ndoesn't declare an instance setter named `b`:\n\n```dart\nextension E on String {\n  set a(String v) {}\n}\n\nextension F on String {\n  set b(String v) {}\n}\n\nvoid f() {\n  E('c').[!b!] = 'd';\n}\n```\n\nThe following code produces this diagnostic because the extension `E`\ndoesn't declare a static setter named `a`:\n\n```dart\nextension E on String {}\n\nvoid f() {\n  E.[!a!] = 3;\n}\n```\n\n## Common fixes\n\nIf the name of the setter is incorrect, then change it to the name of an\nexisting setter:\n\n```dart\nextension E on String {\n  set a(String v) {}\n}\n\nextension F on String {\n  set b(String v) {}\n}\n\nvoid f() {\n  E('c').a = 'd';\n}\n```\n\nIf the name of the setter is correct, but the name of the extension is\nwrong, then change the name of the extension to the correct name:\n\n```dart\nextension E on String {\n  set a(String v) {}\n}\n\nextension F on String {\n  set b(String v) {}\n}\n\nvoid f() {\n  F('c').b = 'd';\n}\n```\n\nIf the name of the setter and extension are both correct, but the setter\nisn't defined, then define the setter:\n\n```dart\nextension E on String {\n  set a(String v) {}\n  set b(String v) {}\n}\n\nextension F on String {\n  set b(String v) {}\n}\n\nvoid f() {\n  E('c').b = 'd';\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_function",
    "description": "_The function '{0}' isn't defined._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it encounters an identifier that\nappears to be the name of a function but either isn't defined or isn't\nvisible in the scope in which it's being referenced.\n\n## Example\n\nThe following code produces this diagnostic because the name `emty` isn't\ndefined:\n\n```dart\nList<int> empty() => [];\n\nvoid main() {\n  print([!emty!]());\n}\n```\n\n## Common fixes\n\nIf the identifier isn't defined, then either define it or replace it with\nthe name of a function that is defined. The example above can be corrected\nby fixing the spelling of the function:\n\n```dart\nList<int> empty() => [];\n\nvoid main() {\n  print(empty());\n}\n```\n\nIf the function is defined but isn't visible, then you probably need to add\nan import or re-arrange your code to make the function visible.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_getter",
    "description": "_The getter '{0}' isn't defined for the '{1}' function type._\n\n_The getter '{0}' isn't defined for the type '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it encounters an identifier that\nappears to be the name of a getter but either isn't defined or isn't\nvisible in the scope in which it's being referenced.\n\n## Example\n\nThe following code produces this diagnostic because `String` has no member\nnamed `len`:\n\n```dart\nint f(String s) => s.[!len!];\n```\n\n## Common fixes\n\nIf the identifier isn't defined, then either define it or replace it with\nthe name of a getter that is defined. The example above can be corrected by\nfixing the spelling of the getter:\n\n```dart\nint f(String s) => s.length;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_hidden_name",
    "description": "_The library '{0}' doesn't export a member with the hidden name '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a hide combinator includes a\nname that isn't defined by the library being imported.\n\n## Example\n\nThe following code produces this diagnostic because `dart:math` doesn't\ndefine the name `String`:\n\n```dart\nimport 'dart:math' hide [!String!], max;\n\nvar x = min(0, 1);\n```\n\n## Common fixes\n\nIf a different name should be hidden, then correct the name. Otherwise,\nremove the name from the list:\n\n```dart\nimport 'dart:math' hide max;\n\nvar x = min(0, 1);\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_identifier",
    "description": "_Undefined name '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it encounters an identifier that\neither isn't defined or isn't visible in the scope in which it's being\nreferenced.\n\n## Example\n\nThe following code produces this diagnostic because the name `rihgt` isn't\ndefined:\n\n```dart\nint min(int left, int right) => left <= [!rihgt!] ? left : right;\n```\n\n## Common fixes\n\nIf the identifier isn't defined, then either define it or replace it with\nan identifier that is defined. The example above can be corrected by\nfixing the spelling of the variable:\n\n```dart\nint min(int left, int right) => left <= right ? left : right;\n```\n\nIf the identifier is defined but isn't visible, then you probably need to\nadd an import or re-arrange your code to make the identifier visible.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_identifier_await",
    "description": "_Undefined name 'await' in function body not marked with 'async'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the name `await` is used in a\nmethod or function body without being declared, and the body isn't marked\nwith the `async` keyword. The name `await` only introduces an await\nexpression in an asynchronous function.\n\n## Example\n\nThe following code produces this diagnostic because the name `await` is\nused in the body of `f` even though the body of `f` isn't marked with the\n`async` keyword:\n\n```dart\nvoid f(p) { [!await!] p; }\n```\n\n## Common fixes\n\nAdd the keyword `async` to the function body:\n\n```dart\nvoid f(p) async { await p; }\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_lint",
    "description": "_'{0}' isn't a recognized lint rule._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an analysis options file\nattempts to enable a lint rule that is not defined.\n\n## Example\n\nThe following code produces this diagnostic because\n`implementation_import` isn't a known lint:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nlinter:\n  rules:\n    - annotate_overrides\n    - [!implementation_import!]\n```\n\n## Common fixes\n\nIf the name of the lint was mistyped, then correct the name.\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nlinter:\n  rules:\n    - annotate_overrides\n    - implementation_imports\n```\n\nIf there is no lint corresponding to the flagged entry, then remove the\nundefined lint:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nlinter:\n  rules:\n    - annotate_overrides\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_method",
    "description": "_The method '{0}' isn't defined for the '{1}' function type._\n\n_The method '{0}' isn't defined for the type '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it encounters an identifier that\nappears to be the name of a method but either isn't defined or isn't\nvisible in the scope in which it's being referenced.\n\n## Example\n\nThe following code produces this diagnostic because the identifier\n`removeMiddle` isn't defined:\n\n```dart\nint f(List<int> l) => l.[!removeMiddle!]();\n```\n\n## Common fixes\n\nIf the identifier isn't defined, then either define it or replace it with\nthe name of a method that is defined. The example above can be corrected by\nfixing the spelling of the method:\n\n```dart\nint f(List<int> l) => l.removeLast();\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_named_parameter",
    "description": "_The named parameter '{0}' isn't defined._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a method or function invocation\nhas a named argument, but the method or function being invoked doesn't\ndefine a parameter with the same name.\n\n## Example\n\nThe following code produces this diagnostic because `m` doesn't declare a\nnamed parameter named `a`:\n\n```dart\nclass C {\n  m({int? b}) {}\n}\n\nvoid f(C c) {\n  c.m([!a!]: 1);\n}\n```\n\n## Common fixes\n\nIf the argument name is mistyped, then replace it with the correct name.\nThe example above can be fixed by changing `a` to `b`:\n\n```dart\nclass C {\n  m({int? b}) {}\n}\n\nvoid f(C c) {\n  c.m(b: 1);\n}\n```\n\nIf a subclass adds a parameter with the name in question, then cast the\nreceiver to the subclass:\n\n```dart\nclass C {\n  m({int? b}) {}\n}\n\nclass D extends C {\n  m({int? a, int? b}) {}\n}\n\nvoid f(C c) {\n  (c as D).m(a: 1);\n}\n```\n\nIf the parameter should be added to the function, then add it:\n\n```dart\nclass C {\n  m({int? a, int? b}) {}\n}\n\nvoid f(C c) {\n  c.m(a: 1);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_operator",
    "description": "_The operator '{0}' isn't defined for the type '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a user-definable operator is\ninvoked on an object for which the operator isn't defined.\n\n## Example\n\nThe following code produces this diagnostic because the class `C` doesn't\ndefine the operator `+`:\n\n```dart\nclass C {}\n\nC f(C c) => c [!+!] 2;\n```\n\n## Common fixes\n\nIf the operator should be defined for the class, then define it:\n\n```dart\nclass C {\n  C operator +(int i) => this;\n}\n\nC f(C c) => c + 2;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_prefixed_name",
    "description": "_The name '{0}' is being referenced through the prefix '{1}', but it isn't defined in any of the libraries imported using that prefix._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a prefixed identifier is found\nwhere the prefix is valid, but the identifier isn't declared in any of the\nlibraries imported using that prefix.\n\n## Example\n\nThe following code produces this diagnostic because `dart:core` doesn't\ndefine anything named `a`:\n\n```dart\nimport 'dart:core' as p;\n\nvoid f() {\n  p.[!a!];\n}\n```\n\n## Common fixes\n\nIf the library in which the name is declared isn't imported yet, add an\nimport for the library.\n\nIf the name is wrong, then change it to one of the names that's declared in\nthe imported libraries.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_referenced_parameter",
    "description": "_The parameter '{0}' isn't defined by '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an annotation of the form\n[`UseResult.unless(parameterDefined: parameterName)`][meta-UseResult]\nspecifies a parameter name that isn't defined by the annotated function.\n\n## Example\n\nThe following code produces this diagnostic because the function `f`\ndoesn't have a parameter named `b`:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@UseResult.unless(parameterDefined: [!'b'!])\nint f([int? a]) => a ?? 0;\n```\n\n## Common fixes\n\nChange the argument named `parameterDefined` to match the name of one of\nthe parameters to the function:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@UseResult.unless(parameterDefined: 'a')\nint f([int? a]) => a ?? 0;\n```\n\n[meta-UseResult]: https://pub.dev/documentation/meta/latest/meta/UseResult-class.html\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_setter",
    "description": "_The setter '{0}' isn't defined for the '{1}' function type._\n\n_The setter '{0}' isn't defined for the type '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it encounters an identifier that\nappears to be the name of a setter but either isn't defined or isn't\nvisible in the scope in which the identifier is being referenced.\n\n## Example\n\nThe following code produces this diagnostic because there isn't a setter\nnamed `z`:\n\n```dart\nclass C {\n  int x = 0;\n  void m(int y) {\n    this.[!z!] = y;\n  }\n}\n```\n\n## Common fixes\n\nIf the identifier isn't defined, then either define it or replace it with\nthe name of a setter that is defined. The example above can be corrected by\nfixing the spelling of the setter:\n\n```dart\nclass C {\n  int x = 0;\n  void m(int y) {\n    this.x = y;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_shown_name",
    "description": "_The library '{0}' doesn't export a member with the shown name '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a show combinator includes a\nname that isn't defined by the library being imported.\n\n## Example\n\nThe following code produces this diagnostic because `dart:math` doesn't\ndefine the name `String`:\n\n```dart\nimport 'dart:math' show min, [!String!];\n\nvar x = min(0, 1);\n```\n\n## Common fixes\n\nIf a different name should be shown, then correct the name. Otherwise,\nremove the name from the list:\n\n```dart\nimport 'dart:math' show min;\n\nvar x = min(0, 1);\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "undefined_super_member",
    "description": "_The getter '{0}' isn't defined in a superclass of '{1}'._\n\n_The method '{0}' isn't defined in a superclass of '{1}'._\n\n_The operator '{0}' isn't defined in a superclass of '{1}'._\n\n_The setter '{0}' isn't defined in a superclass of '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an inherited member (method,\ngetter, setter, or operator) is referenced using `super`, but there's no\nmember with that name in the superclass chain.\n\n## Examples\n\nThe following code produces this diagnostic because `Object` doesn't define\na method named `n`:\n\n```dart\nclass C {\n  void m() {\n    super.[!n!]();\n  }\n}\n```\n\nThe following code produces this diagnostic because `Object` doesn't define\na getter named `g`:\n\n```dart\nclass C {\n  void m() {\n    super.[!g!];\n  }\n}\n```\n\n## Common fixes\n\nIf the inherited member you intend to invoke has a different name, then\nmake the name of the invoked member match the inherited member.\n\nIf the member you intend to invoke is defined in the same class, then\nremove the `super.`.\n\nIf the member isn't defined, then either add the member to one of the\nsuperclasses or remove the invocation.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": [
      "undefined_super_method"
    ]
  },
  {
    "id": "undone",
    "description": "_{0}_",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unexpected_dollar_in_string",
    "description": "_A '$' has special meaning inside a string, and must be followed by an identifier or an expression in curly braces ({})._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unexpected_separator_in_number",
    "description": "_Digit separators ('\\_') in a number literal can only be placed between two digits._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unexpected_terminator_for_parameter_group",
    "description": "_There is no '{0}' to open a parameter group._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unexpected_token",
    "description": "_Unexpected text '{0}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unexpected_tokens",
    "description": "_Unexpected tokens._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unignorable_ignore",
    "description": "_The diagnostic '{0}' can't be ignored._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unknown_platform",
    "description": "_The platform '{0}' is not a recognized platform._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an unknown platform name is\nused as a key in the `platforms` map.\nTo learn more about specifying your package's supported platforms,\ncheck out the [documentation on platform declarations](https://dart.dev/tools/pub/pubspec#platforms).\n\n## Example\n\nThe following `pubspec.yaml` produces this diagnostic because the platform\n`browser` is unknown.\n\n```yaml\nname: example\nplatforms:\n  [!browser:!]\n```\n\n## Common fixes\n\nIf you can rely on automatic platform detection, then omit the\ntop-level `platforms` key.\n\n```yaml\nname: example\n```\n\nIf you need to manually specify the list of supported platforms, then\nwrite the `platforms` field as a map with known platform names as keys.\n\n```yaml\nname: example\nplatforms:\n  # These are the known platforms\n  android:\n  ios:\n  linux:\n  macos:\n  web:\n  windows:\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unnecessary_cast",
    "description": "_Unnecessary cast._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the value being cast is already\nknown to be of the type that it's being cast to.\n\n## Example\n\nThe following code produces this diagnostic because `n` is already known to\nbe an `int` as a result of the `is` test:\n\n```dart\nvoid f(num n) {\n  if (n is int) {\n    ([!n as int!]).isEven;\n  }\n}\n```\n\n## Common fixes\n\nRemove the unnecessary cast:\n\n```dart\nvoid f(num n) {\n  if (n is int) {\n    n.isEven;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unnecessary_cast_pattern",
    "description": "_Unnecessary cast pattern._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a cast pattern is used on a\nvalue that is known to be of the specified type.\n\n## Example\n\nThe following code produces this diagnostic because the cast `as num` is\nknown to always succeed because the type of `z` is `int`:\n\n```dart\nvoid f(int x) {\n  if (x case var z [!as!] num) {\n    print(z);\n  }\n}\n```\n\n## Common fixes\n\nRemove the cast pattern:\n\n```dart\nvoid f(int x) {\n  if (x case var z) {\n    print(z);\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unnecessary_dev_dependency",
    "description": "_The dev dependency on {0} is unnecessary because there is also a normal dependency on that package._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when there's an entry under\n`dev_dependencies` for a package that is also listed under `dependencies`.\nThe packages under `dependencies` are available to all of the code in the\npackage, so there's no need to also list them under `dev_dependencies`.\n\n## Example\n\nThe following code produces this diagnostic because the package `meta` is\nlisted under both `dependencies` and `dev_dependencies`:\n\n```yaml\nname: example\ndependencies:\n  meta: ^1.0.2\ndev_dependencies:\n  [!meta!]: ^1.0.2\n```\n\n## Common fixes\n\nRemove the entry under `dev_dependencies` (and the `dev_dependencies` key\nif that's the only package listed there):\n\n```yaml\nname: example\ndependencies:\n  meta: ^1.0.2\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unnecessary_final",
    "description": "_The keyword 'final' isn't necessary because the parameter is implicitly 'final'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when either a field initializing\nparameter or a super parameter in a constructor has the keyword `final`.\nIn both cases the keyword is unnecessary because the parameter is\nimplicitly `final`.\n\n## Examples\n\nThe following code produces this diagnostic because the field initializing\nparameter has the keyword `final`:\n\n```dart\nclass A {\n  int value;\n\n  A([!final!] this.value);\n}\n```\n\nThe following code produces this diagnostic because the super parameter in\n`B` has the keyword `final`:\n\n```dart\nclass A {\n  A(int value);\n}\n\nclass B extends A {\n  B([!final!] super.value);\n}\n```\n\n## Common fixes\n\nRemove the unnecessary `final` keyword:\n\n```dart\nclass A {\n  A(int value);\n}\n\nclass B extends A {\n  B(super.value);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unnecessary_import",
    "description": "_The import of '{0}' is unnecessary because all of the used elements are also provided by the import of '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an import isn't needed because\nall of the names that are imported and referenced within the importing\nlibrary are also visible through another import.\n\n## Example\n\nGiven a file `a.dart` that contains the following:\n\n```dart\nclass A {}\n```\n\nAnd, given a file `b.dart` that contains the following:\n\n```dart\nexport 'a.dart';\n\nclass B {}\n```\n\nThe following code produces this diagnostic because the class `A`, which is\nimported from `a.dart`, is also imported from `b.dart`. Removing the import\nof `a.dart` leaves the semantics unchanged:\n\n```dart\nimport [!'a.dart'!];\nimport 'b.dart';\n\nvoid f(A a, B b) {}\n```\n\n## Common fixes\n\nIf the import isn't needed, then remove it.\n\nIf some of the names imported by this import are intended to be used but\naren't yet, and if those names aren't imported by other imports, then add\nthe missing references to those names.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unnecessary_nan_comparison",
    "description": "_A double can't equal 'double.nan', so the condition is always 'false'._\n\n_A double can't equal 'double.nan', so the condition is always 'true'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a value is compared to\n`double.nan` using either `==` or `!=`.\n\nDart follows the [IEEE 754] floating-point standard for the semantics of\nfloating point operations, which states that, for any floating point value\n`x` (including NaN, positive infinity, and negative infinity),\n- `NaN == x` is always false\n- `NaN != x` is always true\n\nAs a result, comparing any value to NaN is pointless because the result is\nalready known (based on the comparison operator being used).\n\n## Example\n\nThe following code produces this diagnostic because `d` is being compared\nto `double.nan`:\n\n```dart\nbool isNaN(double d) => d [!== double.nan!];\n```\n\n## Common fixes\n\nUse the getter `double.isNaN` instead:\n\n```dart\nbool isNaN(double d) => d.isNaN;\n```\n\n[IEEE 754]: https://en.wikipedia.org/wiki/IEEE_754\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unnecessary_non_null_assertion",
    "description": "_The '!' will have no effect because the receiver can't be null._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the operand of the `!` operator\ncan't be `null`.\n\n## Example\n\nThe following code produces this diagnostic because `x` can't be `null`:\n\n```dart\nint f(int x) {\n  return x[!!!];\n}\n```\n\n## Common fixes\n\nRemove the null check operator (`!`):\n\n```dart\nint f(int x) {\n  return x;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unnecessary_no_such_method",
    "description": "_Unnecessary 'noSuchMethod' declaration._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when there's a declaration of\n`noSuchMethod`, the only thing the declaration does is invoke the\noverridden declaration, and the overridden declaration isn't the\ndeclaration in `Object`.\n\nOverriding the implementation of `Object`'s `noSuchMethod` (no matter what\nthe implementation does) signals to the analyzer that it shouldn't flag any\ninherited abstract methods that aren't implemented in that class. This\nworks even if the overriding implementation is inherited from a superclass,\nso there's no value to declare it again in a subclass.\n\n## Example\n\nThe following code produces this diagnostic because the declaration of\n`noSuchMethod` in `A` makes the declaration of `noSuchMethod` in `B`\nunnecessary:\n\n```dart\nclass A {\n  @override\n  dynamic noSuchMethod(x) => super.noSuchMethod(x);\n}\nclass B extends A {\n  @override\n  dynamic [!noSuchMethod!](y) {\n    return super.noSuchMethod(y);\n  }\n}\n```\n\n## Common fixes\n\nRemove the unnecessary declaration:\n\n```dart\nclass A {\n  @override\n  dynamic noSuchMethod(x) => super.noSuchMethod(x);\n}\nclass B extends A {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unnecessary_null_assert_pattern",
    "description": "_The null-assert pattern will have no effect because the matched type isn't nullable._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a null-assert pattern is used\nto match a value that isn't nullable.\n\n## Example\n\nThe following code produces this diagnostic because the variable `x` isn't\nnullable:\n\n```dart\nvoid f(int x) {\n  if (x case var a[!!!] when a > 0) {}\n}\n```\n\n## Common fixes\n\nRemove the null-assert pattern:\n\n```dart\nvoid f(int x) {\n  if (x case var a when a > 0) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unnecessary_null_check_pattern",
    "description": "_The null-check pattern will have no effect because the matched type isn't nullable._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a null-check pattern is used to\nmatch a value that isn't nullable.\n\n## Example\n\nThe following code produces this diagnostic because the value `x` isn't\nnullable:\n\n```dart\nvoid f(int x) {\n  if (x case var a[!?!] when a > 0) {}\n}\n```\n\n## Common fixes\n\nRemove the null-check pattern:\n\n```dart\nvoid f(int x) {\n  if (x case var a when a > 0) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unnecessary_null_comparison",
    "description": "_The operand can't be 'null', so the condition is always 'false'._\n\n_The operand can't be 'null', so the condition is always 'true'._\n\n_The operand must be 'null', so the condition is always 'false'._\n\n_The operand must be 'null', so the condition is always 'true'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it finds an equality comparison\n(either `==` or `!=`) with one operand of `null` and the other operand\ncan't be `null`. Such comparisons are always either `true` or `false`, so\nthey serve no purpose.\n\n## Examples\n\nThe following code produces this diagnostic because `x` can never be\n`null`, so the comparison always evaluates to `true`:\n\n```dart\nvoid f(int x) {\n  if (x [!!= null!]) {\n    print(x);\n  }\n}\n```\n\nThe following code produces this diagnostic because `x` can never be\n`null`, so the comparison always evaluates to `false`:\n\n```dart\nvoid f(int x) {\n  if (x [!== null!]) {\n    throw ArgumentError(\"x can't be null\");\n  }\n}\n```\n\n## Common fixes\n\nIf the other operand should be able to be `null`, then change the type of\nthe operand:\n\n```dart\nvoid f(int? x) {\n  if (x != null) {\n    print(x);\n  }\n}\n```\n\nIf the other operand really can't be `null`, then remove the condition:\n\n```dart\nvoid f(int x) {\n  print(x);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unnecessary_question_mark",
    "description": "_The '?' is unnecessary because '{0}' is nullable without it._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when either the type `dynamic` or the\ntype `Null` is followed by a question mark. Both of these types are\ninherently nullable so the question mark doesn't change the semantics.\n\n## Example\n\nThe following code produces this diagnostic because the question mark\nfollowing `dynamic` isn't necessary:\n\n```dart\ndynamic[!?!] x;\n```\n\n## Common fixes\n\nRemove the unneeded question mark:\n\n```dart\ndynamic x;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unnecessary_set_literal",
    "description": "_Braces unnecessarily wrap this expression in a set literal._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a function that has a return\ntype of `void`, `Future<void>`, or `FutureOr<void>` uses an expression\nfunction body (`=>`) and the returned value is a literal set containing a\nsingle element.\n\nAlthough the language allows it, returning a value from a `void` function\nisn't useful because it can't be used at the call site. In this particular\ncase the return is often due to a misunderstanding about the syntax. The\nbraces aren't necessary and can be removed.\n\n## Example\n\nThe following code produces this diagnostic because the closure being\npassed to `g` has a return type of `void`, but is returning a set:\n\n```dart\nvoid f() {\n  g(() => [!{1}!]);\n}\n\nvoid g(void Function() p) {}\n```\n\n## Common fixes\n\nRemove the braces from around the value:\n\n```dart\nvoid f() {\n  g(() => 1);\n}\n\nvoid g(void Function() p) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unnecessary_type_check",
    "description": "_Unnecessary type check; the result is always 'false'._\n\n_Unnecessary type check; the result is always 'true'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the value of a type check (using\neither `is` or `is!`) is known at compile time.\n\n## Example\n\nThe following code produces this diagnostic because the test `a is Object?`\nis always `true`:\n\n```dart\nbool f<T>(T a) => [!a is Object?!];\n```\n\n## Common fixes\n\nIf the type check doesn't check what you intended to check, then change the\ntest:\n\n```dart\nbool f<T>(T a) => a is Object;\n```\n\nIf the type check does check what you intended to check, then replace the\ntype check with its known value or completely remove it:\n\n```dart\nbool f<T>(T a) => true;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unnecessary_wildcard_pattern",
    "description": "_Unnecessary wildcard pattern._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a wildcard pattern is used in\neither an and (`&&`) pattern or an or (`||`) pattern.\n\n## Example\n\nThe following code produces this diagnostic because the wildcard pattern\n(`_`) will always succeed, making it's use in an and pattern unnecessary:\n\n```dart\nvoid f(Object? x) {\n  if (x case [!_!] && 0) {}\n}\n```\n\n## Common fixes\n\nRemove the use of the wildcard pattern:\n\n```dart\nvoid f(Object? x) {\n  if (x case 0) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unqualified_reference_to_non_local_static_member",
    "description": "_Static members from supertypes must be qualified by the name of the defining type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when code in one class references a\nstatic member in a superclass without prefixing the member's name with the\nname of the superclass. Static members can only be referenced without a\nprefix in the class in which they're declared.\n\n## Example\n\nThe following code produces this diagnostic because the static field `x` is\nreferenced in the getter `g` without prefixing it with the name of the\ndefining class:\n\n```dart\nclass A {\n  static int x = 3;\n}\n\nclass B extends A {\n  int get g => [!x!];\n}\n```\n\n## Common fixes\n\nPrefix the name of the static member with the name of the declaring class:\n\n```dart\nclass A {\n  static int x = 3;\n}\n\nclass B extends A {\n  int get g => A.x;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unqualified_reference_to_static_member_of_extended_type",
    "description": "_Static members from the extended type or one of its superclasses must be qualified by the name of the defining type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an undefined name is found, and\nthe name is the same as a static member of the extended type or one of its\nsuperclasses.\n\n## Example\n\nThe following code produces this diagnostic because `m` is a static member\nof the extended type `C`:\n\n```dart\nclass C {\n  static void m() {}\n}\n\nextension E on C {\n  void f() {\n    [!m!]();\n  }\n}\n```\n\n## Common fixes\n\nIf you're trying to reference a static member that's declared outside the\nextension, then add the name of the class or extension before the reference\nto the member:\n\n```dart\nclass C {\n  static void m() {}\n}\n\nextension E on C {\n  void f() {\n    C.m();\n  }\n}\n```\n\nIf you're referencing a member that isn't declared yet, add a declaration:\n\n```dart\nclass C {\n  static void m() {}\n}\n\nextension E on C {\n  void f() {\n    m();\n  }\n\n  void m() {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unreachable_switch_case",
    "description": "_This case is covered by the previous cases._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `case` clause in a `switch`\nstatement doesn't match anything because all of the matchable values are\nmatched by an earlier `case` clause.\n\n## Example\n\nThe following code produces this diagnostic because the value `1` was\nmatched in the preceding case:\n\n```dart\nvoid f(int x) {\n  switch (x) {\n    case 1:\n      print('one');\n    [!case!] 1:\n      print('two');\n  }\n}\n```\n\n## Common fixes\n\nChange one or both of the conflicting cases to match different values:\n\n```dart\nvoid f(int x) {\n  switch (x) {\n    case 1:\n      print('one');\n    case 2:\n      print('two');\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unreachable_switch_default",
    "description": "_This default clause is covered by the previous cases._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `default` clause in a\n`switch` statement doesn't match anything because all of the matchable\nvalues are matched by an earlier `case` clause.\n\n## Example\n\nThe following code produces this diagnostic because the values `E.e1` and\n`E.e2` were matched in the preceding cases:\n\n```dart\nenum E { e1, e2 }\n\nvoid f(E x) {\n  switch (x) {\n    case E.e1:\n      print('one');\n    case E.e2:\n      print('two');\n    [!default!]:\n      print('other');\n  }\n}\n```\n\n## Common fixes\n\nRemove the unnecessary `default` clause:\n\n```dart\nenum E { e1, e2 }\nvoid f(E x) {\n  switch (x) {\n    case E.e1:\n      print('one');\n    case E.e2:\n      print('two');\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unrecognized_error_code",
    "description": "_'{0}' isn't a recognized diagnostic code._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the analyzer/errors section in\nan analysis options file contains a diagnostic code that is not valid.\n\n## Example\n\nThe following code produces this diagnostic because the diagnostic\n`implementation_import` isn't defined:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nanalyzer:\n  errors:\n    annotate_overrides: error\n    [!implementation_import!]: warning\n```\n\n## Common fixes\n\nIf the diagnostic being specified has a different name, then replace the\nname:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nanalyzer:\n  errors:\n    annotate_overrides: error\n    implementation_imports: warning\n```\n\nIf there is no diagnostic, then remove the name:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nanalyzer:\n  errors:\n    annotate_overrides: error\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unsupported_chrome_os_feature",
    "description": "_The feature {0} isn't supported on Chrome OS, consider making it optional._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unsupported_chrome_os_hardware",
    "description": "_The feature {0} isn't supported on Chrome OS, consider making it optional._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unsupported_operator",
    "description": "_The '{0}' operator is not supported._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unsupported_option",
    "description": "_The option '{0}' isn't supported by '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an unsupported option is\nspecified.\n\n## Example\n\nThe following code produces this diagnostic because `experiments` isn't a\nsupported option:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nanalyzer:\n  [!experiments!]:\n    - augmentations\n```\n\n## Common fixes\n\nIf you intended to use a supported option, then replace the unsupported\noption with the supported one:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nanalyzer:\n  enable-experiment:\n    - augmentations\n```\n\nIf no option exists for your intended purpose, then remove the unsupported\noption:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nanalyzer:\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unsupported_value",
    "description": "_The value '{0}' isn't supported by '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an analysis options file\ncontains a valid option and the value of that option is not a valid value.\n\n## Example\n\nThe following code produces this diagnostic because `fatal` isn't a valid\nseverity:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nanalyzer:\n  errors:\n    dead_code: [!fatal!]\n```\n\n## Common fixes\n\nIf a valid value specifies the intended behavior, then replace the\nunsupported value with it:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nanalyzer:\n  errors:\n    dead_code: error\n```\n\nIf there is no valid value to use, then remove the option:\n\n```yaml\n// %uri=\"analysis_options.yaml\"\nanalyzer:\n  errors:\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unterminated_multi_line_comment",
    "description": "_Unterminated multi-line comment._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unterminated_string_literal",
    "description": "_Unterminated string literal._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unused_catch_clause",
    "description": "_The exception variable '{0}' isn't used, so the 'catch' clause can be removed._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `catch` clause is found, and\nneither the exception parameter nor the optional stack trace parameter are\nused in the `catch` block.\n\n## Example\n\nThe following code produces this diagnostic because `e` isn't referenced:\n\n```dart\nvoid f() {\n  try {\n    int.parse(';');\n  } on FormatException catch ([!e!]) {\n    // ignored\n  }\n}\n```\n\n## Common fixes\n\nRemove the unused `catch` clause:\n\n```dart\nvoid f() {\n  try {\n    int.parse(';');\n  } on FormatException {\n    // ignored\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unused_catch_stack",
    "description": "_The stack trace variable '{0}' isn't used and can be removed._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the stack trace parameter in a\n`catch` clause isn't referenced within the body of the `catch` block.\n\n## Example\n\nThe following code produces this diagnostic because `stackTrace` isn't\nreferenced:\n\n```dart\nvoid f() {\n  try {\n    // ...\n  } catch (exception, [!stackTrace!]) {\n    // ...\n  }\n}\n```\n\n## Common fixes\n\nIf you need to reference the stack trace parameter, then add a reference to\nit. Otherwise, remove it:\n\n```dart\nvoid f() {\n  try {\n    // ...\n  } catch (exception) {\n    // ...\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unused_element",
    "description": "_The declaration '{0}' isn't referenced._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a private declaration isn't\nreferenced in the library that contains the declaration. The following\nkinds of declarations are analyzed:\n- Private top-level declarations and all of their members\n- Private members of public declarations\n\nNot all references to an element will mark it as \"used\":\n- Assigning a value to a top-level variable (with a standard `=`\n  assignment, or a null-aware `??=` assignment) does not count as using\n  it.\n- Referring to an element in a doc comment reference does not count as\n  using it.\n- Referring to a class, mixin, or enum on the right side of an `is`\n  expression does not count as using it.\n\n## Example\n\nAssuming that no code in the library references `_C`, the following code\nproduces this diagnostic:\n\n```dart\nclass [!_C!] {}\n```\n\n## Common fixes\n\nIf the declaration isn't needed, then remove it.\n\nIf the declaration is intended to be used, then add the code to use it.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unused_element_parameter",
    "description": "_A value for optional parameter '{0}' isn't ever given._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a value is never passed for an\noptional parameter declared within a private declaration.\n\n## Example\n\nAssuming that no code in the library passes a value for `y` in any\ninvocation of `_m`, the following code produces this diagnostic:\n\n```dart\nclass C {\n  void _m(int x, [int? [!y!]]) {}\n\n  void n() => _m(0);\n}\n```\n\n## Common fixes\n\nIf the declaration isn't needed, then remove it:\n\n```dart\nclass C {\n  void _m(int x) {}\n\n  void n() => _m(0);\n}\n```\n\nIf the declaration is intended to be used, then add the code to use it.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unused_field",
    "description": "_The value of the field '{0}' isn't used._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a private field is declared but\nnever read, even if it's written in one or more places.\n\n## Example\n\nThe following code produces this diagnostic because the field\n`_originalValue` isn't read anywhere in the library:\n\n```dart\nclass C {\n  final String [!_originalValue!];\n  final String _currentValue;\n\n  C(this._originalValue) : _currentValue = _originalValue;\n\n  String get value => _currentValue;\n}\n```\n\nIt might appear that the field `_originalValue` is being read in the\ninitializer (`_currentValue = _originalValue`), but that is actually a\nreference to the parameter of the same name, not a reference to the field.\n\n## Common fixes\n\nIf the field isn't needed, then remove it.\n\nIf the field was intended to be used, then add the missing code.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unused_import",
    "description": "_Unused import: '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an import isn't needed because\nnone of the names that are imported are referenced within the importing\nlibrary.\n\n## Example\n\nThe following code produces this diagnostic because nothing defined in\n`dart:async` is referenced in the library:\n\n```dart\nimport [!'dart:async'!];\n\nvoid main() {}\n```\n\n## Common fixes\n\nIf the import isn't needed, then remove it.\n\nIf some of the imported names are intended to be used, then add the missing\ncode.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unused_label",
    "description": "_The label '{0}' isn't used._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a label that isn't used is\nfound.\n\n## Example\n\nThe following code produces this diagnostic because the label `loop` isn't\nreferenced anywhere in the method:\n\n```dart\nvoid f(int limit) {\n  [!loop:!] for (int i = 0; i < limit; i++) {\n    print(i);\n  }\n}\n```\n\n## Common fixes\n\nIf the label isn't needed, then remove it:\n\n```dart\nvoid f(int limit) {\n  for (int i = 0; i < limit; i++) {\n    print(i);\n  }\n}\n```\n\nIf the label is needed, then use it:\n\n```dart\nvoid f(int limit) {\n  loop: for (int i = 0; i < limit; i++) {\n    print(i);\n    if (i != 0) {\n      break loop;\n    }\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unused_local_variable",
    "description": "_The value of the local variable '{0}' isn't used._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a local variable is declared but\nnever read, even if it's written in one or more places.\n\n## Example\n\nThe following code produces this diagnostic because the value of `count` is\nnever read:\n\n```dart\nvoid main() {\n  int [!count!] = 0;\n}\n```\n\n## Common fixes\n\nIf the variable isn't needed, then remove it.\n\nIf the variable was intended to be used, then add the missing code.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unused_result",
    "description": "_'{0}' should be used. {1}._\n\n_The value of '{0}' should be used._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a function annotated with\n[`useResult`][meta-useResult] is invoked, and the value returned by that\nfunction isn't used. The value is considered to be used if a member of the\nvalue is invoked, if the value is passed to another function, or if the\nvalue is assigned to a variable or field.\n\n## Example\n\nThe following code produces this diagnostic because the invocation of\n`c.a()` isn't used, even though the method `a` is annotated with\n[`useResult`][meta-useResult]:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass C {\n  @useResult\n  int a() => 0;\n\n  int b() => 0;\n}\n\nvoid f(C c) {\n  c.[!a!]();\n}\n```\n\n## Common fixes\n\nIf you intended to invoke the annotated function, then use the value that\nwas returned:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass C {\n  @useResult\n  int a() => 0;\n\n  int b() => 0;\n}\n\nvoid f(C c) {\n  print(c.a());\n}\n```\n\nIf you intended to invoke a different function, then correct the name of\nthe function being invoked:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass C {\n  @useResult\n  int a() => 0;\n\n  int b() => 0;\n}\n\nvoid f(C c) {\n  c.b();\n}\n```\n\n[meta-useResult]: https://pub.dev/documentation/meta/latest/meta/useResult-constant.html\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unused_shown_name",
    "description": "_The name {0} is shown, but isn't used._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a show combinator includes a\nname that isn't used within the library. Because it isn't referenced, the\nname can be removed.\n\n## Example\n\nThe following code produces this diagnostic because the function `max`\nisn't used:\n\n```dart\nimport 'dart:math' show min, [!max!];\n\nvar x = min(0, 1);\n```\n\n## Common fixes\n\nEither use the name or remove it:\n\n```dart\nimport 'dart:math' show min;\n\nvar x = min(0, 1);\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "uri_does_not_exist",
    "description": "_Target of URI doesn't exist: '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an import, export, or part\ndirective is found where the URI refers to a file that doesn't exist.\n\n## Examples\n\nIf the file `lib.dart` doesn't exist, the following code produces this\ndiagnostic:\n\n```dart\nimport [!'lib.dart'!];\n```\n\n## Common fixes\n\nIf the URI was mistyped or invalid, then correct the URI.\n\nIf the URI is correct, then create the file.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "uri_does_not_exist_in_doc_import",
    "description": "_Target of URI doesn't exist: '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a doc-import is found where\nthe URI refers to a file that doesn't exist.\n\n## Examples\n\nIf the file `lib.dart` doesn't exist, the following code produces this\ndiagnostic:\n\n```dart\n/// @docImport [!'lib.dart'!];\nlibrary;\n```\n\n## Common fixes\n\nIf the URI was mistyped or invalid, then correct the URI.\n\nIf the URI is correct, then create the file.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "uri_has_not_been_generated",
    "description": "_Target of URI hasn't been generated: '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an import, export, or part\ndirective is found where the URI refers to a file that doesn't exist and\nthe name of the file ends with a pattern that's commonly produced by code\ngenerators, such as one of the following:\n- `.g.dart`\n- `.pb.dart`\n- `.pbenum.dart`\n- `.pbserver.dart`\n- `.pbjson.dart`\n- `.template.dart`\n\n## Example\n\nIf the file `lib.g.dart` doesn't exist, the following code produces this\ndiagnostic:\n\n```dart\nimport [!'lib.g.dart'!];\n```\n\n## Common fixes\n\nIf the file is a generated file, then run the generator that generates the\nfile.\n\nIf the file isn't a generated file, then check the spelling of the URI or\ncreate the file.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "uri_with_interpolation",
    "description": "_URIs can't use string interpolation._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the string literal in an\n`import`, `export`, or `part` directive contains an interpolation. The\nresolution of the URIs in directives must happen before the declarations\nare compiled, so expressions can't be  evaluated  while determining the\nvalues of the URIs.\n\n## Example\n\nThe following code produces this diagnostic because the string in the\n`import` directive contains an interpolation:\n\n```dart\nimport [!'dart:$m'!];\n\nconst m = 'math';\n```\n\n## Common fixes\n\nRemove the interpolation from the URI:\n\n```dart\nimport 'dart:math';\n\nvar zero = min(0, 0);\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "use_of_native_extension",
    "description": "_Dart native extensions are deprecated and aren't available in Dart 2.15._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a library is imported using the\n`dart-ext` scheme.\n\n## Example\n\nThe following code produces this diagnostic because the native library `x`\nis being imported using a scheme of `dart-ext`:\n\n```dart\nimport [!'dart-ext:x'!];\n```\n\n## Common fixes\n\nRewrite the code to use `dart:ffi` as a way of invoking the contents of the\nnative library.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "use_of_void_result",
    "description": "_This expression has a type of 'void' so its value can't be used._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when it finds an expression whose\ntype is `void`, and the expression is used in a place where a value is\nexpected, such as before a member access or on the right-hand side of an\nassignment.\n\n## Example\n\nThe following code produces this diagnostic because `f` doesn't produce an\nobject on which `toString` can be invoked:\n\n```dart\nvoid f() {}\n\nvoid g() {\n  [!f()!].toString();\n}\n```\n\n## Common fixes\n\nEither rewrite the code so that the expression has a value or rewrite the\ncode so that it doesn't depend on the value.\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "values_declaration_in_enum",
    "description": "_A member named 'values' can't be declared in an enum._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an enum declaration defines a\nmember named `values`, whether the member is an enum value, an instance\nmember, or a static member.\n\nAny such member conflicts with the implicit declaration of the static\ngetter named `values` that returns a list containing all the enum\nconstants.\n\n## Example\n\nThe following code produces this diagnostic because the enum `E` defines\nan instance member named `values`:\n\n```dart\nenum E {\n  v;\n  void [!values!]() {}\n}\n```\n\n## Common fixes\n\nChange the name of the conflicting member:\n\n```dart\nenum E {\n  v;\n  void getValues() {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "variable_length_array_not_last",
    "description": "_Variable length 'Array's must only occur as the last field of Structs._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a variable length inline `Array`\nis not the last member of a `Struct`.\n\nFor more information about FFI, see [C interop using dart:ffi][ffi].\n\n## Example\n\nThe following code produces this diagnostic because the field `a0` has a\ntype with three nested arrays, but only two dimensions are given in the\n`Array` annotation:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  [!@Array.variable()!]\n  external Array<Uint8> a0;\n\n  @Uint8()\n  external int a1;\n}\n```\n\n## Common fixes\n\nMove the variable length inline `Array` to be the last field in the struct.\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Uint8()\n  external int a1;\n\n  @Array.variable()\n  external Array<Uint8> a0;\n}\n```\n\nIf the inline array has a fixed size, annotate it with the size:\n\n```dart\nimport 'dart:ffi';\n\nfinal class C extends Struct {\n  @Array(10)\n  external Array<Uint8> a0;\n\n  @Uint8()\n  external int a1;\n}\n```\n\n[ffi]: /interop/c-interop\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "variable_pattern_keyword_in_declaration_context",
    "description": "_Variable patterns in declaration context can't specify 'var' or 'final' keyword._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a variable pattern is used\nwithin a declaration context.\n\n## Example\n\nThe following code produces this diagnostic because the variable patterns\nin the record pattern are in a declaration context:\n\n```dart\nvoid f((int, int) r) {\n  var ([!var!] x, y) = r;\n  print(x + y);\n}\n```\n\n## Common fixes\n\nRemove the `var` or `final` keyword(s) within the variable pattern:\n\n```dart\nvoid f((int, int) r) {\n  var (x, y) = r;\n  print(x + y);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "variable_type_mismatch",
    "description": "_A value of type '{0}' can't be assigned to a const variable of type '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the evaluation of a constant\nexpression would result in a `CastException`.\n\n## Example\n\nThe following code produces this diagnostic because the value of `x` is an\n`int`, which can't be assigned to `y` because an `int` isn't a `String`:\n\n```dart\nconst dynamic x = 0;\nconst String y = [!x!];\n```\n\n## Common fixes\n\nIf the declaration of the constant is correct, then change the value being\nassigned to be of the correct type:\n\n```dart\nconst dynamic x = 0;\nconst String y = '$x';\n```\n\nIf the assigned value is correct, then change the declaration to have the\ncorrect type:\n\n```dart\nconst int x = 0;\nconst int y = x;\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "var_and_type",
    "description": "_Variables can't be declared using both 'var' and a type name._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "var_as_type_name",
    "description": "_The keyword 'var' can't be used as a type name._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "var_class",
    "description": "_Classes can't be declared to be 'var'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "var_enum",
    "description": "_Enums can't be declared to be 'var'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "var_return_type",
    "description": "_The return type can't be 'var'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "var_typedef",
    "description": "_Typedefs can't be declared to be 'var'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "void_with_type_arguments",
    "description": "_Type 'void' can't have type arguments._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "with_before_extends",
    "description": "_The extends clause must be before the with clause._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "workspace_field_not_list",
    "description": "_The value of the 'workspace' field is required to be a list of relative file paths._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the value of the `workspace` key\nisn't a list.\n\n## Example\n\nThe following code produces this diagnostic because the value of the\n`workspace` key is a string when a list is expected:\n\n```yaml\nname: example\nworkspace: [!notPaths!]\n```\n\n## Common fixes\n\nChange the value of the workspace field so that it's a list:\n\n```yaml\nname: example\nworkspace:\n    - pkg/package_1\n    - pkg/package_2\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "workspace_value_not_string",
    "description": "_Workspace entries are required to be directory paths (strings)._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `workspace` list contains a\nvalue that isn't a string.\n\n## Example\n\nThe following code produces this diagnostic because the `workspace` list\ncontains a map:\n\n```yaml\nname: example\nworkspace:\n    - [!image.gif: true!]\n```\n\n## Common fixes\n\nChange the `workspace` list so that it only contains valid POSIX-style directory\npaths:\n\n```yaml\nname: example\nworkspace:\n    - pkg/package_1\n    - pkg/package_2\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "workspace_value_not_subdirectory",
    "description": "_Workspace values must be a relative path of a subdirectory of '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `workspace` list contains a\nvalue that is not a subdirectory of the directory containing the `pubspec.yaml`` file.\n\n## Example\n\nThe following code produces this diagnostic because the value in the `workspace` list is not a\nrelative path of a subdirectory of the directory containing the 'pubspec.yaml' file:\n\n```yaml\nname: example\nworkspace:\n    - /home/my_package\n```\n\n## Common fixes\n\nChange the `workspace` list so that it only contains only subdirectory paths.\n\n```yaml\nname: example\nworkspace:\n    - pkg/package_1\n    - pkg/package_2\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "wrong_explicit_type_parameter_variance_in_superinterface",
    "description": "_'{0}' is an '{1}' type parameter and can't be used in an '{2}' position in '{3}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "wrong_number_of_parameters_for_operator",
    "description": "_Operator '-' should declare 0 or 1 parameter, but {0} found._\n\n_Operator '{0}' should declare exactly {1} parameters, but {2} found._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a declaration of an operator has\nthe wrong number of parameters.\n\n## Example\n\nThe following code produces this diagnostic because the operator `+` must\nhave a single parameter corresponding to the right operand:\n\n```dart\nclass C {\n  int operator [!+!](a, b) => 0;\n}\n```\n\n## Common fixes\n\nAdd or remove parameters to match the required number:\n\n```dart\nclass C {\n  int operator +(a) => 0;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "wrong_number_of_parameters_for_setter",
    "description": "_Setters must declare exactly one required positional parameter._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a setter is found that doesn't\ndeclare exactly one required positional parameter.\n\n## Examples\n\nThe following code produces this diagnostic because the setter `s` declares\ntwo required parameters:\n\n```dart\nclass C {\n  set [!s!](int x, int y) {}\n}\n```\n\nThe following code produces this diagnostic because the setter `s` declares\none optional parameter:\n\n```dart\nclass C {\n  set [!s!]([int? x]) {}\n}\n```\n\n## Common fixes\n\nChange the declaration so that there's exactly one required positional\nparameter:\n\n```dart\nclass C {\n  set s(int x) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "wrong_number_of_type_arguments",
    "description": "_The type '{0}' is declared with {1} type parameters, but {2} type arguments were given._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a type that has type parameters\nis used and type arguments are provided, but the number of type arguments\nisn't the same as the number of type parameters.\n\nThe analyzer also produces this diagnostic when a constructor is invoked\nand the number of type arguments doesn't match the number of type\nparameters declared for the class.\n\n## Examples\n\nThe following code produces this diagnostic because `C` has one type\nparameter but two type arguments are provided when it is used as a type\nannotation:\n\n```dart\nclass C<E> {}\n\nvoid f([!C<int, int>!] x) {}\n```\n\nThe following code produces this diagnostic because `C` declares one type\nparameter, but two type arguments are provided when creating an instance:\n\n```dart\nclass C<E> {}\n\nvar c = [!C<int, int>!]();\n```\n\n## Common fixes\n\nAdd or remove type arguments, as necessary, to match the number of type\nparameters defined for the type:\n\n```dart\nclass C<E> {}\n\nvoid f(C<int> x) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "wrong_number_of_type_arguments_constructor",
    "description": "_The constructor '{0}.{1}' doesn't have type parameters._\n\n_The constructor '{0}.{1}` doesn't have type parameters._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when type arguments are provided\nafter the name of a named constructor. Constructors can't declare type\nparameters, so invocations can only provide the type arguments associated\nwith the class, and those type arguments are required to follow the name of\nthe class rather than the name of the constructor.\n\n## Example\n\nThe following code produces this diagnostic because the type parameters\n(`<String>`) follow the name of the constructor rather than the name of the\nclass:\n\n```dart\nclass C<T> {\n  C.named();\n}\nC f() => C.named[!<String>!]();\n```\n\n## Common fixes\n\nIf the type arguments are for the class' type parameters, then move the\ntype arguments to follow the class name:\n\n```dart\nclass C<T> {\n  C.named();\n}\nC f() => C<String>.named();\n```\n\nIf the type arguments aren't for the class' type parameters, then remove\nthem:\n\n```dart\nclass C<T> {\n  C.named();\n}\nC f() => C.named();\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "wrong_number_of_type_arguments_enum",
    "description": "_The enum is declared with {0} type parameters, but {1} type arguments were given._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an enum value in an enum that\nhas type parameters is instantiated and type arguments are provided, but\nthe number of type arguments isn't the same as the number of type\nparameters.\n\n## Example\n\nThe following code produces this diagnostic because the enum value `c`\nprovides one type argument even though the enum `E` is declared to have\ntwo type parameters:\n\n```dart\nenum E<T, U> {\n  c[!<int>!]()\n}\n```\n\n## Common fixes\n\nIf the number of type parameters is correct, then change the number of\ntype arguments to match the number of type parameters:\n\n```dart\nenum E<T, U> {\n  c<int, String>()\n}\n```\n\nIf the number of type arguments is correct, then change the number of type\nparameters to match the number of type arguments:\n\n```dart\nenum E<T> {\n  c<int>()\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "wrong_number_of_type_arguments_extension",
    "description": "_The extension '{0}' is declared with {1} type parameters, but {2} type arguments were given._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an extension that has type\nparameters is used and type arguments are provided, but the number of type\narguments isn't the same as the number of type parameters.\n\n## Example\n\nThe following code produces this diagnostic because the extension `E` is\ndeclared to have a single type parameter (`T`), but the extension override\nhas two type arguments:\n\n```dart\nextension E<T> on List<T> {\n  int get len => length;\n}\n\nvoid f(List<int> p) {\n  E[!<int, String>!](p).len;\n}\n```\n\n## Common fixes\n\nChange the type arguments so that there are the same number of type\narguments as there are type parameters:\n\n```dart\nextension E<T> on List<T> {\n  int get len => length;\n}\n\nvoid f(List<int> p) {\n  E<int>(p).len;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "wrong_number_of_type_arguments_function",
    "description": "_The function '{0}' is declared with {1} type parameters, but {2} type arguments were given._\n\n_This function is declared with {0} type parameters, but {1} type arguments were given._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "wrong_number_of_type_arguments_method",
    "description": "_The method '{0}' is declared with {1} type parameters, but {2} type arguments are given._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a method or function is invoked\nwith a different number of type arguments than the number of type\nparameters specified in its declaration. There must either be no type\narguments or the number of arguments must match the number of parameters.\n\n## Example\n\nThe following code produces this diagnostic because the invocation of the\nmethod `m` has two type arguments, but the declaration of `m` only has one\ntype parameter:\n\n```dart\nclass C {\n  int m<A>(A a) => 0;\n}\n\nint f(C c) => c.m[!<int, int>!](2);\n```\n\n## Common fixes\n\nIf the type arguments are necessary, then make them match the number of\ntype parameters by either adding or removing type arguments:\n\n```dart\nclass C {\n  int m<A>(A a) => 0;\n}\n\nint f(C c) => c.m<int>(2);\n```\n\nIf the type arguments aren't necessary, then remove them:\n\n```dart\nclass C {\n  int m<A>(A a) => 0;\n}\n\nint f(C c) => c.m(2);\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "wrong_separator_for_positional_parameter",
    "description": "_The default value of a positional parameter should be preceded by '='._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "wrong_terminator_for_parameter_group",
    "description": "_Expected '{0}' to close parameter group._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "wrong_type_parameter_variance_in_superinterface",
    "description": "_'{0}' can't be used contravariantly or invariantly in '{1}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "wrong_type_parameter_variance_position",
    "description": "_The '{0}' type parameter '{1}' can't be used in an '{2}' position._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "yield_in_non_generator",
    "description": "_Yield statements must be in a generator function (one marked with either 'async*' or 'sync*')._\n\n_Yield-each statements must be in a generator function (one marked with either 'async*' or 'sync*')._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `yield` or `yield*` statement\nappears in a function whose body isn't marked with one of the `async*` or\n`sync*` modifiers.\n\n## Examples\n\nThe following code produces this diagnostic because `yield` is being used\nin a function whose body doesn't have a modifier:\n\n```dart\nIterable<int> get digits {\n  yield* [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n}\n```\n\nThe following code produces this diagnostic because `yield*` is being used\nin a function whose body has the `async` modifier rather than the `async*`\nmodifier:\n\n```dart\nStream<int> get digits async {\n  yield* [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n}\n```\n\n## Common fixes\n\nAdd a modifier, or change the existing modifier to be either `async*` or\n`sync*`:\n\n```dart\nIterable<int> get digits sync* {\n  yield* [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "yield_of_invalid_type",
    "description": "_A yielded value of type '{0}' must be assignable to '{1}'._\n\n_The type '{0}' implied by the 'yield*' expression must be assignable to '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the type of object produced by\na `yield` or `yield*` expression doesn't match the type of objects that\nare to be returned from the `Iterable` or `Stream` types that are returned\nfrom a generator (a function or method marked with either `sync*` or\n`async*`).\n\n## Example\n\nThe following code produces this diagnostic because the getter `zero` is\ndeclared to return an `Iterable` that returns integers, but the `yield` is\nreturning a string from the iterable:\n\n```dart\nIterable<int> get zero sync* {\n  yield [!'0'!];\n}\n```\n\n## Common fixes\n\nIf the return type of the function is correct, then fix the expression\nfollowing the keyword `yield` to return the correct type:\n\n```dart\nIterable<int> get zero sync* {\n  yield 0;\n}\n```\n\nIf the expression following the `yield` is correct, then change the return\ntype of the function to allow it:\n\n```dart\nIterable<String> get zero sync* {\n  yield '0';\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "always_declare_return_types",
    "description": "_The function '{0}' should have a return type but doesn't._\n\n_The method '{0}' should have a return type but doesn't._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a method or function doesn't\nhave an explicit return type.\n\n## Example\n\nThe following code produces this diagnostic because the function `f`\ndoesn't have a return type:\n\n```dart\n[!f!]() {}\n```\n\n## Common fixes\n\nAdd an explicit return type:\n\n```dart\nvoid f() {}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "always_put_control_body_on_new_line",
    "description": "_Statement should be on a separate line._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the code being controlled by a\ncontrol flow statement (`if`, `for`, `while`, or `do`) is on the same line\nas the control flow statement.\n\n## Example\n\nThe following code produces this diagnostic because the `return` statement\nis on the same line as the `if` that controls whether the `return` will be\nexecuted:\n\n```dart\nvoid f(bool b) {\n  if (b) [!return!];\n}\n```\n\n## Common fixes\n\nPut the controlled statement onto a separate, indented, line:\n\n```dart\nvoid f(bool b) {\n  if (b)\n    return;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "always_put_required_named_parameters_first",
    "description": "_Required named parameters should be before optional named parameters._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when required named parameters occur\nafter optional named parameters.\n\n## Example\n\nThe following code produces this diagnostic because the required parameter\n`x` is after the optional parameter `y`:\n\n```dart\nvoid f({int? y, required int [!x!]}) {}\n```\n\n## Common fixes\n\nReorder the parameters so that all required named parameters are before\nany optional named parameters:\n\n```dart\nvoid f({required int x, int? y}) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "always_require_non_null_named_parameters",
    "description": "",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "always_specify_types",
    "description": "_Missing type annotation._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "always_use_package_imports",
    "description": "_Use 'package:' imports for files in the 'lib' directory._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an `import` in a library inside\nthe `lib` directory uses a relative path to import another library inside\nthe `lib` directory of the same package.\n\n## Example\n\nGiven that a file named `a.dart` and the code below are both inside the\n`lib` directory of the same package, the following code produces this\ndiagnostic because a relative URI is used to import `a.dart`:\n\n```dart\nimport [!'a.dart'!];\n```\n\n## Common fixes\n\nUse a package import:\n\n```dart\nimport 'package:p/a.dart';\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "analyzer_element_model_tracking_bad",
    "description": "_Bad tracking annotation for this member._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "analyzer_element_model_tracking_more_than_one",
    "description": "_There can be only one tracking annotation._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "analyzer_element_model_tracking_zero",
    "description": "_No required tracking annotation._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "analyzer_public_api_bad_part_directive",
    "description": "_Part directives in the analyzer public API should point to files in the analyzer public API._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "analyzer_public_api_bad_type",
    "description": "_Element makes use of type(s) which is not part of the analyzer public API: {0}._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "analyzer_public_api_experimental_inconsistency",
    "description": "_Element makes use of experimental type(s), but is not itself marked with `@experimental`: {0}._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "analyzer_public_api_exports_non_public_name",
    "description": "_Export directive exports element(s) that are not part of the analyzer public API: {0}._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "analyzer_public_api_impl_in_public_api",
    "description": "_Declarations in the analyzer public API should not end in \"Impl\"._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "annotate_overrides",
    "description": "_The member '{0}' overrides an inherited member but isn't annotated with '@override'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a member overrides an inherited\nmember, but isn't annotated with `@override`.\n\n## Example\n\nThe following code produces this diagnostic because the method `m` in the\nclass `B` overrides the method with the same name in class `A`, but isn't\nmarked as an intentional override:\n\n```dart\nclass A {\n  void m() {}\n}\n\nclass B extends A {\n  void [!m!]() {}\n}\n```\n\n## Common fixes\n\nIf the member in the subclass is intended to override the member in the\nsuperclass, then add an `@override` annotation:\n\n```dart\nclass A {\n  void m() {}\n}\n\nclass B extends A {\n  @override\n  void m() {}\n}\n```\n\nIf the member in the subclass is not intended to override the member in\nthe superclass, then rename one of the members:\n\n```dart\nclass A {\n  void m() {}\n}\n\nclass B extends A {\n  void m2() {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "annotate_redeclares",
    "description": "_The member '{0}' is redeclaring but isn't annotated with '@redeclare'._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_annotating_with_dynamic",
    "description": "_Unnecessary 'dynamic' type annotation._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_as",
    "description": "",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_bool_literals_in_conditional_expressions",
    "description": "_Conditional expressions with a 'bool' literal can be simplified._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_catches_without_on_clauses",
    "description": "_Catch clause should use 'on' to specify the type of exception being caught._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_catching_errors",
    "description": "_The type 'Error' should not be caught._\n\n_The type '{0}' should not be caught because it is a subclass of 'Error'._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_classes_with_only_static_members",
    "description": "_Classes should define instance members._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_double_and_int_checks",
    "description": "_Explicit check for double or int._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_dynamic_calls",
    "description": "_Method invocation or property access on a 'dynamic' target._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a member of a class is accessed\non an expression whose type is `dynamic`.\n\n## Example\n\nThe following code produces this diagnostic because the getter `length` is\nbeing invoked on `s`, which has the type `dynamic`:\n\n```dart\nvoid f(dynamic s) {\n  [!s!].length;\n}\n```\n\n## Common fixes\n\nProvide enough type information that the expression has a type other than\n`dynamic`:\n\n```dart\nvoid f(String s) {\n  s.length;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_empty_else",
    "description": "_Empty statements are not allowed in an 'else' clause._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the statement after an `else`\nis an empty statement (a semicolon).\n\nFor more information, see the documentation for\n[`avoid_empty_else`](https://dart.dev/diagnostics/avoid_empty_else).\n\n## Example\n\nThe following code produces this diagnostic because the statement\nfollowing the `else` is an empty statement:\n\n```dart\nvoid f(int x, int y) {\n  if (x > y)\n    print(\"1\");\n  else [!;!]\n    print(\"2\");\n}\n```\n\n## Common fixes\n\nIf the statement after the empty statement is intended to be executed only\nwhen the condition is `false`, then remove the empty statement:\n\n```dart\nvoid f(int x, int y) {\n  if (x > y)\n    print(\"1\");\n  else\n    print(\"2\");\n}\n```\n\nIf there is no code that is intended to be executed only when the\ncondition is `false`, then remove the whole `else` clause:\n\n```dart\nvoid f(int x, int y) {\n  if (x > y)\n    print(\"1\");\n  print(\"2\");\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_equals_and_hash_code_on_mutable_classes",
    "description": "_The method '{0}' should not be overridden in classes not annotated with '@immutable'._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_escaping_inner_quotes",
    "description": "_Unnecessary escape of '{0}'._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_field_initializers_in_const_classes",
    "description": "_Fields in 'const' classes should not have initializers._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_final_parameters",
    "description": "_Parameters should not be marked as 'final'._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_function_literals_in_foreach_calls",
    "description": "_Function literals shouldn't be passed to 'forEach'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the argument to\n`Iterable.forEach` is a closure.\n\n## Example\n\nThe following code produces this diagnostic because the argument to the\ninvocation of `forEach` is a closure:\n\n```dart\nvoid f(Iterable<String> s) {\n  s.[!forEach!]((e) => print(e));\n}\n```\n\n## Common fixes\n\nIf the closure can be replaced by a tear-off, then replace the closure:\n\n```dart\nvoid f(Iterable<String> s) {\n  s.forEach(print);\n}\n```\n\nIf the closure can't be replaced by a tear-off, then use a `for` loop to\niterate over the elements:\n\n```dart\nvoid f(Iterable<String> s) {\n  for (var e in s) {\n    print(e);\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_futureor_void",
    "description": "_Don't use the type 'FutureOr<void>'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the type `FutureOr<void>`\nis used as the type of a result (to be precise: it is used in a\nposition that isn't contravariant). The type `FutureOr<void>` is\nproblematic because it may appear to encode that a result is either a\n`Future<void>`, or the result should be discarded (when it is\n`void`).  However, there is no safe way to detect whether we have one\nor the other case because an expression of type `void` can evaluate\nto any object whatsoever, including a future of any type.\n\nIt is also conceptually unsound to have a type whose meaning is\nsomething like \"ignore this object; also, take a look because it\nmight be a future\".\n\nAn exception is made for contravariant occurrences of the type\n`FutureOr<void>` (e.g., for the type of a formal parameter), and no\nwarning is emitted for these occurrences. The reason for this\nexception is that the type does not describe a result, it describes a\nconstraint on a value provided by others. Similarly, an exception is\nmade for type alias declarations, because they may well be used in a\ncontravariant position (e.g., as the type of a formal\nparameter). Hence, in type alias declarations, only the type\nparameter bounds are checked.\n\n## Example\n\n```dart\nimport 'dart:async';\n\n[!FutureOr<void>!] m() => null;\n```\n\n## Common fixes\n\nA replacement for the type `FutureOr<void>` which is often useful is\n`Future<void>?`. This type encodes that a result is either a\n`Future<void>` or it is null, and there is no ambiguity at run time\nsince no object can have both types.\n\nIt may not always be possible to use the type `Future<void>?` as a\nreplacement for the type `FutureOr<void>`, because the latter is a\nsupertype of all types, and the former is not. In this case it may be a\nuseful remedy to replace `FutureOr<void>` by the type `void`.\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_implementing_value_types",
    "description": "_Classes that override '==' should not be implemented._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_init_to_null",
    "description": "_Redundant initialization to 'null'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a nullable variable is\nexplicitly initialized to `null`. The variable can be a local variable,\nfield, or top-level variable.\n\nA variable or field that isn't explicitly initialized automatically gets\ninitialized to `null`. There's no concept of \"uninitialized memory\" in\nDart.\n\n## Example\n\nThe following code produces this diagnostic because the variable `f` is\nexplicitly initialized to `null`:\n\n```dart\nclass C {\n  int? [!f = null!];\n\n  void m() {\n    if (f != null) {\n      print(f);\n    }\n  }\n}\n```\n\n## Common fixes\n\nRemove the unnecessary initialization:\n\n```dart\nclass C {\n  int? f;\n\n  void m() {\n    if (f != null) {\n      print(f);\n    }\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_js_rounded_ints",
    "description": "_Integer literal can't be represented exactly when compiled to JavaScript._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_multiple_declarations_per_line",
    "description": "_Multiple variables declared on a single line._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_null_checks_in_equality_operators",
    "description": "_Unnecessary null comparison in implementation of '=='._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_positional_boolean_parameters",
    "description": "_'bool' parameters should be named parameters._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_print",
    "description": "_Don't invoke 'print' in production code._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the function `print` is invoked\nin production code.\n\n## Example\n\nThe following code produces this diagnostic because the function `print`\ncan't be invoked in production:\n\n```dart\nvoid f(int x) {\n  [!print!]('x = $x');\n}\n```\n\n## Common fixes\n\nIf you're writing code that uses Flutter, then use the function\n[`debugPrint`][debugPrint], guarded by a test\nusing [`kDebugMode`][kDebugMode]:\n\n```dart\nimport 'package:flutter/foundation.dart';\n\nvoid f(int x) {\n  if (kDebugMode) {\n    debugPrint('x = $x');\n  }\n}\n```\n\nIf you're writing code that doesn't use Flutter, then use a logging\nservice, such as [`package:logging`][package-logging], to write the\ninformation.\n\n[debugPrint]: https://api.flutter.dev/flutter/foundation/debugPrint.html\n[kDebugMode]: https://api.flutter.dev/flutter/foundation/kDebugMode-constant.html\n[package-logging]: https://pub.dev/packages/logging\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_private_typedef_functions",
    "description": "_The typedef is unnecessary because it is only used in one place._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_redundant_argument_values",
    "description": "_The value of the argument is redundant because it matches the default value._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_relative_lib_imports",
    "description": "_Can't use a relative path to import a library in 'lib'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the URI in an `import`\ndirective has `lib` in the path.\n\n## Example\n\nAssuming that there is a file named `a.dart` in the `lib` directory:\n\n```dart\nclass A {}\n```\n\nThe following code produces this diagnostic because the import contains a\npath that includes `lib`:\n\n```dart\nimport [!'../lib/a.dart'!];\n```\n\n## Common fixes\n\nRewrite the import to not include `lib` in the URI:\n\n```dart\nimport 'a.dart';\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_renaming_method_parameters",
    "description": "_The parameter name '{0}' doesn't match the name '{1}' in the overridden method._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a method that overrides a\nmethod from a superclass changes the names of the parameters.\n\n## Example\n\nThe following code produces this diagnostic because the parameter of the\nmethod `m` in `B` is named `b`, which is different from the name of the\noverridden method's parameter in `A`:\n\n```dart\nclass A {\n  void m(int a) {}\n}\n\nclass B extends A {\n  @override\n  void m(int [!b!]) {}\n}\n```\n\n## Common fixes\n\nRename one of the parameters so that they are the same:\n\n```dart\nclass A {\n  void m(int a) {}\n}\n\nclass B extends A {\n  @override\n  void m(int a) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_return_types_on_setters",
    "description": "_Unnecessary return type on a setter._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a setter has an explicit return\ntype.\n\nSetters never return a value, so declaring the return type of one is\nredundant.\n\n## Example\n\nThe following code produces this diagnostic because the setter `s` has an\nexplicit return type (`void`):\n\n```dart\n[!void!] set s(int p) {}\n```\n\n## Common fixes\n\nRemove the return type:\n\n```dart\nset s(int p) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_returning_null",
    "description": "",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_returning_null_for_future",
    "description": "",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_returning_null_for_void",
    "description": "_Don't return 'null' from a function with a return type of 'void'._\n\n_Don't return 'null' from a method with a return type of 'void'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a function that has a return\ntype of `void` explicitly returns `null`.\n\n## Example\n\nThe following code produces this diagnostic because there is an explicit\nreturn of `null` in a `void` function:\n\n```dart\nvoid f() {\n  [!return null;!]\n}\n```\n\n## Common fixes\n\nRemove the unnecessary explicit `null`:\n\n```dart\nvoid f() {\n  return;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_returning_this",
    "description": "_Don't return 'this' from a method._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_setters_without_getters",
    "description": "_Setter has no corresponding getter._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_shadowing_type_parameters",
    "description": "_The type parameter '{0}' shadows a type parameter from the enclosing {1}._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a type parameter shadows a type\nparameter from an enclosing declaration.\n\nShadowing a type parameter with a different type parameter can lead to\nsubtle bugs that are difficult to debug.\n\n## Example\n\nThe following code produces this diagnostic because the type parameter `T`\ndefined by the method `m` shadows the type parameter `T` defined by the\nclass `C`:\n\n```dart\nclass C<T> {\n  void m<[!T!]>() {}\n}\n```\n\n## Common fixes\n\nRename one of the type parameters:\n\n```dart\nclass C<T> {\n  void m<S>() {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_single_cascade_in_expression_statements",
    "description": "_Unnecessary cascade expression._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a single cascade operator is\nused and the value of the expression isn't being used for anything (such\nas being assigned to a variable or being passed as an argument).\n\n## Example\n\nThe following code produces this diagnostic because the value of the\ncascade expression `s..length` isn't being used:\n\n```dart\nvoid f(String s) {\n  [!s..length!];\n}\n```\n\n## Common fixes\n\nReplace the cascade operator with a simple access operator:\n\n```dart\nvoid f(String s) {\n  s.length;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_slow_async_io",
    "description": "_Use of an async 'dart:io' method._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an asynchronous file I/O method\nwith a synchronous equivalent is used.\n\nThe following are the specific flagged asynchronous methods:\n\n- `Directory.exists`\n- `Directory.stat`\n- `File.lastModified`\n- `File.exists`\n- `File.stat`\n- `FileSystemEntity.isDirectory`\n- `FileSystemEntity.isFile`\n- `FileSystemEntity.isLink`\n- `FileSystemEntity.type`\n\n## Example\n\nThe following code produces this diagnostic because the async method\n`exists` is invoked:\n\n```dart\nimport 'dart:io';\n\nFuture<void> g(File f) async {\n  await [!f.exists()!];\n}\n```\n\n## Common fixes\n\nUse the synchronous version of the method:\n\n```dart\nimport 'dart:io';\n\nvoid g(File f) {\n  f.existsSync();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_type_to_string",
    "description": "_Using 'toString' on a 'Type' is not safe in production code._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the method `toString` is\ninvoked on a value whose static type is `Type`.\n\n## Example\n\nThe following code produces this diagnostic because the method `toString`\nis invoked on the `Type` returned by `runtimeType`:\n\n```dart\nbool isC(Object o) => o.runtimeType.[!toString!]() == 'C';\n\nclass C {}\n```\n\n## Common fixes\n\nIf it's essential that the type is exactly the same, then use an explicit\ncomparison:\n\n```dart\nbool isC(Object o) => o.runtimeType == C;\n\nclass C {}\n```\n\nIf it's alright for instances of subtypes of the type to return `true`,\nthen use a type check:\n\n```dart\nbool isC(Object o) => o is C;\n\nclass C {}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_types_as_parameter_names",
    "description": "_The parameter name '{0}' matches a visible type name._\n\n_The type parameter name '{0}' matches a visible type name._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the name of a parameter in a\nparameter list is the same as a visible type (a type whose name is in\nscope).\n\nThis often indicates that the intended name of the parameter is missing,\ncausing the name of the type to be used as the name of the parameter\nrather than the type of the parameter. Even when that's not the case (the\nname of the parameter is intentional), the name of the parameter will\nshadow the existing type, which can lead to bugs that are difficult to\ndiagnose.\n\nThe analyzer also produces this diagnostic when the name of a type\nparameter in a type parameter list is the same as a type whose name is\nin scope. It is again recommended that the type parameter is renamed\nsuch that the error-prone shadowing is avoided.\n\n## Example\n\nThe following code produces this diagnostic because the function `f` has a\nparameter named `int`, which shadows the type `int` from `dart:core`:\n\n```dart\nvoid f([!int!]) {}\n```\n\n## Common fixes\n\nIf the parameter name is missing, then add a name for the parameter:\n\n```dart\nvoid f(int x) {}\n```\n\nIf the parameter is intended to have an implicit type of `dynamic`, then\nrename the parameter so that it doesn't shadow the name of any visible type:\n\n```dart\nvoid f(int_) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_types_on_closure_parameters",
    "description": "_Unnecessary type annotation on a function expression parameter._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_unnecessary_containers",
    "description": "_Unnecessary instance of 'Container'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a widget tree contains an\ninstance of `Container` and the only argument to the constructor is\n`child:`.\n\n## Example\n\nThe following code produces this diagnostic because the invocation of the\n`Container` constructor only has a `child:` argument:\n\n```dart\nimport 'package:flutter/material.dart';\n\nWidget buildRow() {\n  return [!Container!](\n    child: Row(\n      children: [\n        Text('a'),\n        Text('b'),\n      ],\n    )\n  );\n}\n```\n\n## Common fixes\n\nIf you intended to provide other arguments to the constructor, then add\nthem:\n\n```dart\nimport 'package:flutter/material.dart';\n\nWidget buildRow() {\n  return Container(\n    color: Colors.red.shade100,\n    child: Row(\n      children: [\n        Text('a'),\n        Text('b'),\n      ],\n    )\n  );\n}\n```\n\nIf no other arguments are needed, then unwrap the child widget:\n\n```dart\nimport 'package:flutter/material.dart';\n\nWidget buildRow() {\n  return Row(\n    children: [\n      Text('a'),\n      Text('b'),\n    ],\n  );\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_unstable_final_fields",
    "description": "",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_unused_constructor_parameters",
    "description": "_The parameter '{0}' is not used in the constructor._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_void_async",
    "description": "_An 'async' function should have a 'Future' return type when it doesn't return a value._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "avoid_web_libraries_in_flutter",
    "description": "_Don't use web-only libraries outside Flutter web plugins._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a library in a package that\nisn't a web plugin contains an import of a web-only library:\n- `dart:html`\n- `dart:js`\n- `dart:js_util`\n- `dart:js_interop`\n- `dart:js_interop_unsafe`\n- `package:js`\n- `package:web`\n\n## Example\n\nWhen found in a package that isn't a web plugin, the following code\nproduces this diagnostic because it imports `dart:html`:\n\n```dart\nimport [!'dart:html'!];\n\nimport 'package:flutter/material.dart';\n\nclass C {}\n```\n\n## Common fixes\n\nIf the package isn't intended to be a web plugin, then remove the import:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass C {}\n```\n\nIf the package is intended to be a web plugin, then add the following\nlines to the `pubspec.yaml` file of the package:\n\n```yaml\nflutter:\n  plugin:\n    platforms:\n      web:\n        pluginClass: HelloPlugin\n        fileName: hello_web.dart\n```\n\nSee [Developing packages & plugins](https://flutter.dev/to/develop-packages)\nfor more information.\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "await_only_futures",
    "description": "_Uses 'await' on an instance of '{0}', which is not a subtype of 'Future'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the expression after `await`\nhas any type other than `Future<T>`, `FutureOr<T>`, `Future<T>?`,\n`FutureOr<T>?` or `dynamic`.\n\nAn exception is made for the expression `await null` because it is a\ncommon way to introduce a microtask delay.\n\nUnless the expression can produce a `Future`, the `await` is unnecessary\nand can cause a reader to assume a level of asynchrony that doesn't exist.\n\n## Example\n\nThe following code produces this diagnostic because the expression after\n`await` has the type `int`:\n\n```dart\nvoid f() async {\n  [!await!] 23;\n}\n```\n\n## Common fixes\n\nRemove the `await`:\n\n```dart\nvoid f() async {\n  23;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "camel_case_extensions",
    "description": "_The extension name '{0}' isn't an UpperCamelCase identifier._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the name of an extension\ndoesn't use the 'UpperCamelCase' naming convention.\n\n## Example\n\nThe following code produces this diagnostic because the name of the\nextension doesn't start with an uppercase letter:\n\n```dart\nextension [!stringExtension!] on String {}\n```\n\n## Common fixes\n\nIf the extension needs to have a name (needs to be visible outside this\nlibrary), then rename the extension so that it has a valid name:\n\n```dart\nextension StringExtension on String {}\n```\n\nIf the extension doesn't need to have a name, then remove the name of the\nextension:\n\n```dart\nextension on String {}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "camel_case_types",
    "description": "_The type name '{0}' isn't an UpperCamelCase identifier._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the name of a type (a class,\nmixin, enum, or typedef) doesn't use the 'UpperCamelCase' naming\nconvention.\n\n## Example\n\nThe following code produces this diagnostic because the name of the class\ndoesn't start with an uppercase letter:\n\n```dart\nclass [!c!] {}\n```\n\n## Common fixes\n\nRename the type so that it has a valid name:\n\n```dart\nclass C {}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "cancel_subscriptions",
    "description": "_Uncancelled instance of 'StreamSubscription'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an instance of\n`StreamSubscription` is created but the method `cancel` isn't invoked.\n\n## Example\n\nThe following code produces this diagnostic because the `subscription`\nisn't canceled:\n\n```dart\nimport 'dart:async';\n\nvoid f(Stream stream) {\n  // ignore: unused_local_variable\n  var [!subscription = stream.listen((_) {})!];\n}\n```\n\n## Common fixes\n\nCancel the subscription:\n\n```dart\nimport 'dart:async';\n\nvoid f(Stream stream) {\n  var subscription = stream.listen((_) {});\n  subscription.cancel();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "cascade_invocations",
    "description": "_Unnecessary duplication of receiver._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "cast_nullable_to_non_nullable",
    "description": "_Don't cast a nullable value to a non-nullable type._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "close_sinks",
    "description": "_Unclosed instance of 'Sink'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an instance of `Sink` is\ncreated but the method `close` isn't invoked.\n\n## Example\n\nThe following code produces this diagnostic because the `sink` isn't\nclosed:\n\n```dart\nimport 'dart:io';\n\nvoid g(File f) {\n  var [!sink = f.openWrite()!];\n  sink.write('x');\n}\n```\n\n## Common fixes\n\nClose the sink:\n\n```dart\nimport 'dart:io';\n\nvoid g(File f) {\n  var sink = f.openWrite();\n  sink.write('x');\n  sink.close();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "collection_methods_unrelated_type",
    "description": "_The argument type '{0}' isn't related to '{1}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when any one of several methods in\nthe core libraries are invoked with arguments of an inappropriate type.\nThese methods are ones that don't provide a specific enough type for the\nparameter to allow the normal type checking to catch the error.\n\nThe arguments that are checked are:\n- an argument to `Iterable<E>.contains` should be related to `E`\n- an argument to `List<E>.remove` should be related to `E`\n- an argument to `Map<K, V>.containsKey` should be related to `K`\n- an argument to `Map<K, V>.containsValue` should be related to `V`\n- an argument to `Map<K, V>.remove` should be related to `K`\n- an argument to `Map<K, V>.[]` should be related to `K`\n- an argument to `Queue<E>.remove` should be related to `E`\n- an argument to `Set<E>.lookup` should be related to `E`\n- an argument to `Set<E>.remove` should be related to `E`\n\n## Example\n\nThe following code produces this diagnostic because the argument to\n`contains` is a `String`, which isn't assignable to `int`, the element\ntype of the list `l`:\n\n```dart\nbool f(List<int> l)  => l.contains([!'1'!]);\n```\n\n## Common fixes\n\nIf the element type is correct, then change the argument to have the same\ntype:\n\n```dart\nbool f(List<int> l)  => l.contains(1);\n```\n\nIf the argument type is correct, then change the element type:\n\n```dart\nbool f(List<String> l)  => l.contains('1');\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "combinators_ordering",
    "description": "_Sort combinator names alphabetically._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "comment_references",
    "description": "_The referenced name isn't visible in scope._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "conditional_uri_does_not_exist",
    "description": "_The target of the conditional URI '{0}' doesn't exist._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "conflicting_key",
    "description": "_The key '{0}' can't be used when '{1}' is also used._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "constant_identifier_names",
    "description": "_The constant name '{0}' isn't a lowerCamelCase identifier._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the name of a constant doesn't\nfollow the lowerCamelCase naming convention.\n\n## Example\n\nThe following code produces this diagnostic because the name of the\ntop-level variable isn't a lowerCamelCase identifier:\n\n```dart\nconst [!EMPTY_STRING!] = '';\n```\n\n## Common fixes\n\nRewrite the name to follow the lowerCamelCase naming convention:\n\n```dart\nconst emptyString = '';\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "control_flow_in_finally",
    "description": "_Use of '{0}' in a 'finally' clause._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `finally` clause contains a\n`return`, `break`, or `continue` statement.\n\n## Example\n\nThe following code produces this diagnostic because there is a `return`\nstatement inside a `finally` block:\n\n```dart\nint f() {\n  try {\n    return 1;\n  } catch (e) {\n    print(e);\n  } finally {\n    [!return 0;!]\n  }\n}\n```\n\n## Common fixes\n\nIf the statement isn't needed, then remove the statement, and remove the\n`finally` clause if the block is empty:\n\n```dart\nint f() {\n  try {\n    return 1;\n  } catch (e) {\n    print(e);\n  }\n}\n```\n\nIf the statement is needed, then move the statement outside the `finally`\nblock:\n\n```dart\nint f() {\n  try {\n    return 1;\n  } catch (e) {\n    print(e);\n  }\n  return 0;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "curly_braces_in_flow_control_structures",
    "description": "_Statements in {0} should be enclosed in a block._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a control structure (`if`,\n`for`, `while`, or `do` statement) has a statement other than a block.\n\n## Example\n\nThe following code produces this diagnostic because the `then` statement\nis not enclosed in a block:\n\n```dart\nint f(bool b) {\n  if (b)\n    [!return 1;!]\n  return 0;\n}\n```\n\n## Common fixes\n\nAdd braces around the statement that should be a block:\n\n```dart\nint f(bool b) {\n  if (b) {\n    return 1;\n  }\n  return 0;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "dangling_library_doc_comments",
    "description": "_Dangling library doc comment._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a documentation comment that\nappears to be library documentation isn't followed by a `library`\ndirective. More specifically, it is produced when a documentation comment\nappears before the first directive in the library, assuming that it isn't\na `library` directive, or before the first top-level declaration and is\nseparated from the declaration by one or more blank lines.\n\n## Example\n\nThe following code produces this diagnostic because there's a\ndocumentation comment before the first `import` directive:\n\n```dart\n[!/// This is a great library.!]\nimport 'dart:core';\n```\n\nThe following code produces this diagnostic because there's a\ndocumentation comment before the first class declaration, but there's a\nblank line between the comment and the declaration.\n\n```dart\n[!/// This is a great library.!]\n\nclass C {}\n```\n\n## Common fixes\n\nIf the comment is library documentation, then add a `library` directive\nwithout a name:\n\n```dart\n/// This is a great library.\nlibrary;\n\nimport 'dart:core';\n```\n\nIf the comment is documentation for the following declaration, then remove\nthe blank line:\n\n```dart\n/// This is a great library.\nclass C {}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "depend_on_referenced_packages",
    "description": "_The imported package '{0}' isn't a dependency of the importing package._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a package import refers to a\npackage that is not specified in the `pubspec.yaml` file.\n\nDepending explicitly on packages that you reference ensures they will\nalways exist and allows you to put a dependency constraint on them to\nguard against breaking changes.\n\n## Example\n\nGiven a `pubspec.yaml` file containing the following:\n\n```yaml\ndependencies:\n  meta: ^3.0.0\n```\n\nThe following code produces this diagnostic because there is no dependency\non the package `a`:\n\n```dart\nimport 'package:a/a.dart';\n```\n\n## Common fixes\n\nWhether the dependency should be a regular dependency or dev dependency\ndepends on whether the package is referenced from a public library (one\nunder either `lib` or `bin`), or only private libraries, (such as one\nunder `test`).\n\nIf the package is referenced from at least one public library, then add a\nregular dependency on the package to the `pubspec.yaml` file under the\n`dependencies` field:\n\n```yaml\ndependencies:\n  a: ^1.0.0\n  meta: ^3.0.0\n```\n\nIf the package is referenced only from private libraries, then add a\ndev dependency on the package to the `pubspec.yaml` file under the\n`dev_dependencies` field:\n\n```yaml\ndependencies:\n  meta: ^3.0.0\ndev_dependencies:\n  a: ^1.0.0\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "deprecated_consistency",
    "description": "_Constructors in a deprecated class should be deprecated._\n\n_Fields that are initialized by a deprecated parameter should be deprecated._\n\n_Parameters that initialize a deprecated field should be deprecated._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "deprecated_member_use_from_same_package",
    "description": "_'{0}' is deprecated and shouldn't be used._\n\n_'{0}' is deprecated and shouldn't be used. {1}_",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "diagnostic_describe_all_properties",
    "description": "_The public property isn't described by either 'debugFillProperties' or 'debugDescribeChildren'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class that implements\n`Diagnosticable` has a public property that isn't added as a property in\neither a `debugFillProperties` or `debugDescribeChildren` method.\n\n## Example\n\nThe following code produces this diagnostic because the property `p2`\nisn't added in the `debugFillProperties` method:\n\n```dart\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\nclass C extends Widget {\n  bool get p1 => true;\n\n  bool get [!p2!] => false;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty<bool>('p1', p1));\n  }\n}\n```\n\n## Common fixes\n\nIf there isn't on override of either the `debugFillProperties` or\n`debugDescribeChildren` method, then add one.\n\nAdd a description of the property in the `debugFillProperties` or\n`debugDescribeChildren` method:\n\n```dart\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\nclass C extends Widget {\n  bool get p1 => true;\n\n  bool get p2 => false;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty<bool>('p1', p1));\n    properties.add(DiagnosticsProperty<bool>('p2', p2));\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "directives_ordering",
    "description": "_Place 'dart:' {0} before other {0}._\n\n_Place 'package:' {0} before relative {0}._\n\n_Sort directive sections alphabetically._\n\n_Specify exports in a separate section after all imports._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "discarded_futures",
    "description": "_'Future'-returning calls in a non-'async' function._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "do_not_use_environment",
    "description": "_Invalid use of an environment declaration._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "document_ignores",
    "description": "_Missing documentation explaining why the diagnostic is ignored._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "empty_catches",
    "description": "_Empty catch block._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the block in a `catch` clause\nis empty.\n\n## Example\n\nThe following code produces this diagnostic because the catch block is\nempty:\n\n```dart\nvoid f() {\n  try {\n    print('Hello');\n  } catch (exception) [!{}!]\n}\n```\n\n## Common fixes\n\nIf the exception shouldn't be ignored, then add code to handle the\nexception:\n\n```dart\nvoid f() {\n  try {\n    print('We can print.');\n  } catch (exception) {\n    print(\"We can't print.\");\n  }\n}\n```\n\nIf the exception is intended to be ignored, then add a comment explaining\nwhy:\n\n```dart\nvoid f() {\n  try {\n    print('We can print.');\n  } catch (exception) {\n    // Nothing to do.\n  }\n}\n```\n\nIf the exception is intended to be ignored and there isn't any good\nexplanation for why, then rename the exception parameter:\n\n```dart\nvoid f() {\n  try {\n    print('We can print.');\n  } catch (_) {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "empty_constructor_bodies",
    "description": "_Empty constructor bodies should be written using a ';' rather than '{}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor has an empty\nblock body.\n\n## Example\n\nThe following code produces this diagnostic because the constructor for\n`C` has a block body that is empty:\n\n```dart\nclass C {\n  C() [!{}!]\n}\n```\n\n## Common fixes\n\nReplace the block with a semicolon:\n\n```dart\nclass C {\n  C();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "empty_statements",
    "description": "_Unnecessary empty statement._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an empty statement is found.\n\n## Example\n\nThe following code produces this diagnostic because the statement\ncontrolled by the `while` loop is an empty statement:\n\n```dart\nvoid f(bool condition) {\n  while (condition)[!;!]\n    g();\n}\n\nvoid g() {}\n```\n\n## Common fixes\n\nIf there are no statements that need to be controlled, then remove both\nthe empty statement and the control structure it's part of (being careful\nthat any other code being removed doesn't have a side-effect that needs to\nbe preserved):\n\n```dart\nvoid f(bool condition) {\n  g();\n}\n\nvoid g() {}\n```\n\nIf there are no statements that need to be controlled but the control\nstructure is still required for other reasons, then replace the empty\nstatement with a block to make the structure of the code more obvious:\n\n```dart\nvoid f(bool condition) {\n  while (condition) {}\n  g();\n}\n\nvoid g() {}\n```\n\nIf there are statements that need to be controlled, remove the empty\nstatement and adjust the code so that the appropriate statements are being\ncontrolled, possibly adding a block:\n\n```dart\nvoid f(bool condition) {\n  while (condition) {\n    g();\n  }\n}\n\nvoid g() {}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "enable_null_safety",
    "description": "",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "eol_at_end_of_file",
    "description": "_Missing a newline at the end of the file._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "erase_dart_type_extension_types",
    "description": "_Unsafe use of 'DartType' in an 'is' check._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "exhaustive_cases",
    "description": "_Missing case clauses for some constants in '{0}'._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "expected_primary",
    "description": "_Expected either an identifier or a string literal._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "file_names",
    "description": "_The file name '{0}' isn't a lower\\_case\\_with\\_underscores identifier._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the name of a `.dart` file\ndoesn't use lower_case_with_underscores.\n\n## Example\n\nA file named `SliderMenu.dart` produces this diagnostic because the file\nname uses the UpperCamelCase convention.\n\n## Common fixes\n\nRename the file to use the lower_case_with_underscores convention, such as\n`slider_menu.dart`.\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "flutter_style_todos",
    "description": "_To-do comment doesn't follow the Flutter style._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "hash_and_equals",
    "description": "_Missing a corresponding override of '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class or mixin either\noverrides the definition of `==` but doesn't override the definition of\n`hashCode`, or conversely overrides the definition of `hashCode` but\ndoesn't override the definition of `==`.\n\nBoth the `==` operator and the `hashCode` property of objects must be\nconsistent for a common hash map implementation to function properly. As a\nresult, when overriding either method, both should be overridden.\n\n## Example\n\nThe following code produces this diagnostic because the class `C`\noverrides the `==` operator but doesn't override the getter `hashCode`:\n\n```dart\nclass C {\n  final int value;\n\n  C(this.value);\n\n  @override\n  bool operator [!==!](Object other) =>\n      other is C &&\n      other.runtimeType == runtimeType &&\n      other.value == value;\n}\n```\n\n## Common fixes\n\nIf you need to override one of the members, then add an override of the\nother:\n\n```dart\nclass C {\n  final int value;\n\n  C(this.value);\n\n  @override\n  bool operator ==(Object other) =>\n      other is C &&\n      other.runtimeType == runtimeType &&\n      other.value == value;\n\n  @override\n  int get hashCode => value.hashCode;\n}\n```\n\nIf you don't need to override either of the members, then remove the\nunnecessary override:\n\n```dart\nclass C {\n  final int value;\n\n  C(this.value);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "implementation_imports",
    "description": "_Import of a library in the 'lib/src' directory of another package._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an import references a library\nthat's inside the `lib/src` directory of a different package, which\nviolates [the convention for pub\npackages](https://dart.dev/tools/pub/package-layout#implementation-files).\n\n## Example\n\nThe following code, assuming that it isn't part of the `ffi` package,\nproduces this diagnostic because the library being imported is inside the\ntop-level `src` directory:\n\n```dart\nimport [!'package:ffi/src/allocation.dart'!];\n```\n\n## Common fixes\n\nIf the library being imported contains code that's part of the public API,\nthen import the public library that exports the public API:\n\n```dart\nimport 'package:ffi/ffi.dart';\n```\n\nIf the library being imported isn't part of the public API of the package,\nthen either find a different way to accomplish your goal, assuming that\nit's possible, or open an issue asking the package authors to make it part\nof the public API.\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "implicit_call_tearoffs",
    "description": "_Implicit tear-off of the 'call' method._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an object with a `call` method\nis assigned to a function-typed variable, implicitly tearing off the\n`call` method.\n\n## Example\n\nThe following code produces this diagnostic because an instance of\n`Callable` is passed to a function expecting a `Function`:\n\n```dart\nclass Callable {\n  void call() {}\n}\n\nvoid callIt(void Function() f) {\n  f();\n}\n\nvoid f() {\n  callIt([!Callable()!]);\n}\n```\n\n## Common fixes\n\nExplicitly tear off the `call` method:\n\n```dart\nclass Callable {\n  void call() {}\n}\n\nvoid callIt(void Function() f) {\n  f();\n}\n\nvoid f() {\n  callIt(Callable().call);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "implicit_reopen",
    "description": "_The {0} '{1}' reopens '{2}' because it is not marked '{3}'._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "incompatible_element_kind",
    "description": "_An element of kind '{0}' can't be replaced by an element of kind '{1}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_case_patterns",
    "description": "_This expression is not valid in a 'case' clause in Dart 3.0._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "invalid_change_for_kind",
    "description": "_A change of type '{0}' can't be used for an element of kind '{1}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_character",
    "description": "_Invalid character '{0}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_key",
    "description": "_Keys must be of type 'String' but found the type '{0}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_parameter_style",
    "description": "_The parameter style must be one of the following: {0}._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_required_if",
    "description": "_The key 'requiredIf' can only be used with optional named parameters._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_runtime_check_with_js_interop_types",
    "description": "_Cast from '{0}' to '{1}' casts a Dart value to a JS interop type, which might not be platform-consistent._\n\n_Cast from '{0}' to '{1}' casts a JS interop value to a Dart type, which might not be platform-consistent._\n\n_Cast from '{0}' to '{1}' casts a JS interop value to an incompatible JS interop type, which might not be platform-consistent._\n\n_Runtime check between '{0}' and '{1}' checks whether a Dart value is a JS interop type, which might not be platform-consistent._\n\n_Runtime check between '{0}' and '{1}' checks whether a JS interop value is a Dart type, which might not be platform-consistent._\n\n_Runtime check between '{0}' and '{1}' involves a non-trivial runtime check between two JS interop types that might not be platform-consistent._\n\n_Runtime check between '{0}' and '{1}' involves a runtime check between a JS interop value and an unrelated JS interop type that will always be true and won't check the underlying type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an `is` test has either:\n- a JS interop type on the right-hand side, whether directly or as a type\n  argument to another type, or\n- a JS interop value on the left-hand side.\n\n## Examples\n\nThe following code produces this diagnostic because the JS interop type\n`JSBoolean` is on the right-hand side of an `is` test:\n\n```dart\nimport 'dart:js_interop';\n\nbool f(Object b) => [!b is JSBoolean!];\n```\n\nThe following code produces this diagnostic because the JS interop type\n`JSString` is used as a type argument on the right-hand side of an `is`\ntest:\n\n```dart\nimport 'dart:js_interop';\n\nbool f(List<Object> l) => [!l is List<JSString>!];\n```\n\nThe following code produces this diagnostic because the JS interop value\n`a` is on the left-hand side of an `is` test:\n\n```dart\nimport 'dart:js_interop';\n\nbool f(JSAny a) => [!a is String!];\n```\n\n## Common fixes\n\nUse a JS interop helper, such as `isA`, to check the underlying type of\nJS interop values:\n\n```dart\nimport 'dart:js_interop';\n\nvoid f(Object b) => b.jsify()?.isA<JSBoolean>();\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "invalid_value",
    "description": "_The value of '{0}' should be of type '{1}' but is of type '{2}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invalid_value_one_of",
    "description": "_The value of '{0}' must be one of the following: '{1}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "invariant_booleans",
    "description": "",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "iterable_contains_unrelated_type",
    "description": "",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "join_return_with_assignment",
    "description": "_Assignment could be inlined in 'return' statement._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "leading_newlines_in_multiline_strings",
    "description": "_Missing a newline at the beginning of a multiline string._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "library_annotations",
    "description": "_This annotation should be attached to a library directive._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an annotation that applies to\na whole library isn't associated with a `library` directive.\n\n## Example\n\nThe following code produces this diagnostic because the `TestOn`\nannotation, which applies to the whole library, is associated with an\n`import` directive rather than a `library` directive:\n\n```dart\n[!@TestOn('browser')!]\n\nimport 'package:test/test.dart';\n\nvoid main() {}\n```\n\n## Common fixes\n\nAssociate the annotation with a `library` directive, adding one if\nnecessary:\n\n```dart\n@TestOn('browser')\nlibrary;\n\nimport 'package:test/test.dart';\n\nvoid main() {}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "library_names",
    "description": "_The library name '{0}' isn't a lower\\_case\\_with\\_underscores identifier._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the name of a library doesn't\nuse the lower_case_with_underscores naming convention.\n\n## Example\n\nThe following code produces this diagnostic because the library name\n`libraryName` isn't a lower_case_with_underscores identifier:\n\n```dart\nlibrary [!libraryName!];\n```\n\n## Common fixes\n\nIf the library name is not required, then remove the library name:\n\n```dart\nlibrary;\n```\n\nIf the library name is required, then convert it to use the\nlower_case_with_underscores naming convention:\n\n```dart\nlibrary library_name;\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "library_prefixes",
    "description": "_The prefix '{0}' isn't a lower\\_case\\_with\\_underscores identifier._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an import prefix doesn't use\nthe lower_case_with_underscores naming convention.\n\n## Example\n\nThe following code produces this diagnostic because the prefix\n`ffiSupport` isn't a lower_case_with_underscores identifier:\n\n```dart\nimport 'package:ffi/ffi.dart' as [!ffiSupport!];\n```\n\n## Common fixes\n\nConvert the prefix to use the lower_case_with_underscores naming\nconvention:\n\n```dart\nimport 'package:ffi/ffi.dart' as ffi_support;\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "library_private_types_in_public_api",
    "description": "_Invalid use of a private type in a public API._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a type that is not part of the\npublic API of a library is referenced in the public API of that library.\n\nUsing a private type in a public API can make the API unusable outside the\ndefining library.\n\n## Example\n\nThe following code produces this diagnostic because the parameter `c` of\nthe public function `f` has a type that is library private (`_C`):\n\n```dart\nvoid f([!_C!] c) {}\n\nclass _C {}\n```\n\n## Common fixes\n\nIf the API doesn't need to be used outside the defining library, then make\nit private:\n\n```dart\nvoid _f(_C c) {}\n\nclass _C {}\n```\n\nIf the API needs to be part of the public API of the library, then either\nuse a different type that's public, or make the referenced type public:\n\n```dart\nvoid f(C c) {}\n\nclass C {}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "lines_longer_than_80_chars",
    "description": "_The line length exceeds the 80-character limit._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "list_remove_unrelated_type",
    "description": "",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "literal_only_boolean_expressions",
    "description": "_The Boolean expression has a constant value._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the value of the condition in\nan `if` or loop statement is known to be either always `true` or always\n`false`. An exception is made for a `while` loop whose condition is the\nBoolean literal `true`.\n\n## Examples\n\nThe following code produces this diagnostic because the condition will\nalways evaluate to `true`:\n\n```dart\nvoid f() {\n  [!if (true) {!]\n    [!print('true');!]\n  [!}!]\n}\n```\n\nThe lint will evaluate a subset of expressions that are composed of\nconstants, so the following code will also produce this diagnostic because\nthe condition will always evaluate to `false`:\n\n```dart\nvoid g(int i) {\n  [!if (1 == 0 || 3 > 4) {!]\n    [!print('false');!]\n  [!}!]\n}\n```\n\n## Common fixes\n\nIf the condition is wrong, then correct the condition so that it's value\ncan't be known at compile time:\n\n```dart\nvoid g(int i) {\n  if (i == 0 || i > 4) {\n    print('false');\n  }\n}\n```\n\nIf the condition is correct, then simplify the code to not evaluate the\ncondition:\n\n```dart\nvoid f() {\n  print('true');\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "matching_super_parameters",
    "description": "_The super parameter named '{0}'' does not share the same name as the corresponding parameter in the super constructor, '{1}'._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "missing_code_block_language_in_doc_comment",
    "description": "_The code block is missing a specified language._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "missing_key",
    "description": "_Missing the required key '{0}'._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_one_of_multiple_keys",
    "description": "_Exactly one of the following keys must be provided: {0}._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_template_end",
    "description": "_Missing the end brace for the template._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_token",
    "description": "_Expected to find {0}._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_uri",
    "description": "_At least one URI must be provided._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "missing_whitespace_between_adjacent_strings",
    "description": "_Missing whitespace between adjacent strings._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic for a pair of adjacent string\nliterals unless either the left-hand string ends in whitespace or the\nright-hand string begins with whitespace.\n\n## Example\n\nThe following code produces this diagnostic because neither the left nor\nthe right string literal includes a space to separate the words that will\nbe joined:\n\n```dart\nvar s =\n  [!'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed'!]\n  'do eiusmod tempor incididunt ut labore et dolore magna';\n```\n\n## Common fixes\n\nAdd whitespace at the end of the left-hand literal or at the beginning of\nthe right-hand literal:\n\n```dart\nvar s =\n  'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed '\n  'do eiusmod tempor incididunt ut labore et dolore magna';\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "no_adjacent_strings_in_list",
    "description": "_Don't use adjacent strings in a list literal._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when two string literals are\nadjacent in a list literal. Adjacent strings in Dart are concatenated\ntogether to form a single string, but the intent might be for each string\nto be a separate element in the list.\n\n## Example\n\nThe following code produces this diagnostic because the strings `'a'` and\n`'b'` are adjacent:\n\n```dart\nList<String> list = [[!'a' 'b'!], 'c'];\n```\n\n## Common fixes\n\nIf the two strings are intended to be separate elements of the list, then\nadd a comma between them:\n\n```dart\nList<String> list = ['a', 'b', 'c'];\n```\n\nIf the two strings are intended to be a single concatenated string, then\neither manually merge the strings:\n\n```dart\nList<String> list = ['ab', 'c'];\n```\n\nOr use the `+` operator to concatenate the strings:\n\n```dart\nList<String> list = ['a' + 'b', 'c'];\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "no_default_cases",
    "description": "_Invalid use of 'default' member in a switch._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "no_duplicate_case_values",
    "description": "_The value of the case clause ('{0}') is equal to the value of an earlier case clause ('{1}')._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when two or more `case` clauses in\nthe same `switch` statement have the same value.\n\nAny `case` clauses after the first can't be executed, so having duplicate\n`case` clauses is misleading.\n\nThis diagnostic is often the result of either a typo or a change to the\nvalue of a constant.\n\n## Example\n\nThe following code produces this diagnostic because two case clauses have\nthe same value (1):\n\n```dart\n// @dart = 2.14\nvoid f(int v) {\n  switch (v) {\n    case 1:\n      break;\n    case [!1!]:\n      break;\n  }\n}\n```\n\n## Common fixes\n\nIf one of the clauses should have a different value, then change the value\nof the clause:\n\n```dart\nvoid f(int v) {\n  switch (v) {\n    case 1:\n      break;\n    case 2:\n      break;\n  }\n}\n```\n\nIf the value is correct, then merge the statements into a single clause:\n\n```dart\nvoid f(int v) {\n  switch (v) {\n    case 1:\n      break;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "no_leading_underscores_for_library_prefixes",
    "description": "_The library prefix '{0}' starts with an underscore._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the name of a prefix declared\non an import starts with an underscore.\n\nLibrary prefixes are inherently not visible outside the declaring library,\nso a leading underscore indicating private adds no value.\n\n## Example\n\nThe following code produces this diagnostic because the prefix `_core`\nstarts with an underscore:\n\n```dart\nimport 'dart:core' as [!_core!];\n```\n\n## Common fixes\n\nRemove the underscore:\n\n```dart\nimport 'dart:core' as core;\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "no_leading_underscores_for_local_identifiers",
    "description": "_The local variable '{0}' starts with an underscore._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the name of a local variable\nstarts with an underscore.\n\nLocal variables are inherently not visible outside the declaring library,\nso a leading underscore indicating private adds no value.\n\n## Example\n\nThe following code produces this diagnostic because the parameter `_s`\nstarts with an underscore:\n\n```dart\nint f(String [!_s!]) => _s.length;\n```\n\n## Common fixes\n\nRemove the underscore:\n\n```dart\nint f(String s) => s.length;\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "no_literal_bool_comparisons",
    "description": "_Unnecessary comparison to a boolean literal._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "no_logic_in_create_state",
    "description": "_Don't put any logic in 'createState'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an implementation of\n`createState` in a subclass of `StatefulWidget` contains any logic other\nthan the return of the result of invoking a zero argument constructor.\n\n## Examples\n\nThe following code produces this diagnostic because the constructor\ninvocation has arguments:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass MyWidget extends StatefulWidget {\n  @override\n  MyState createState() => [!MyState(0)!];\n}\n\nclass MyState extends State {\n  int x;\n\n  MyState(this.x);\n}\n```\n\n## Common fixes\n\nRewrite the code so that `createState` doesn't contain any logic:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass MyWidget extends StatefulWidget {\n  @override\n  MyState createState() => MyState();\n}\n\nclass MyState extends State {\n  int x = 0;\n\n  MyState();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "no_runtimetype_tostring",
    "description": "_Using 'toString' on a 'Type' is not safe in production code._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "no_self_assignments",
    "description": "_The variable or property is being assigned to itself._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "no_solo_tests",
    "description": "_Don't commit soloed tests._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "no_trailing_spaces",
    "description": "_Don't create string literals with trailing spaces in tests._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "no_wildcard_variable_uses",
    "description": "_The referenced identifier is a wildcard._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when either a parameter or local\nvariable whose name consists of only underscores is referenced. Such\nnames will become non-binding in a future version of the Dart language,\nmaking the reference illegal.\n\n## Example\n\nThe following code produces this diagnostic because the name of the\nparameter consists of two underscores:\n\n```dart\n// @dart = 3.6\nvoid f(int __) {\n  print([!__!]);\n}\n```\n\nThe following code produces this diagnostic because the name of the\nlocal variable consists of a single underscore:\n\n```dart\n// @dart = 3.6\nvoid f() {\n  int _ = 0;\n  print([!_!]);\n}\n```\n\n## Common fixes\n\nIf the variable or parameter is intended to be referenced, then give it a\nname that has at least one non-underscore character:\n\n```dart\nvoid f(int p) {\n  print(p);\n}\n```\n\nIf the variable or parameter is not intended to be referenced, then\nreplace the reference with a different expression:\n\n```dart\nvoid f() {\n  print(0);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "non_constant_identifier_names",
    "description": "_The variable name '{0}' isn't a lowerCamelCase identifier._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the name of a class member,\ntop-level declaration, variable, parameter, named parameter, or named\nconstructor that isn't declared to be `const`, doesn't use the\nlowerCamelCase convention.\n\n## Example\n\nThe following code produces this diagnostic because the top-level variable\n`Count` doesn't start with a lowercase letter:\n\n```dart\nvar [!Count!] = 0;\n```\n\n## Common fixes\n\nChange the name in the declaration to follow the lowerCamelCase\nconvention:\n\n```dart\nvar count = 0;\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "noop_primitive_operations",
    "description": "_The expression has no effect and can be removed._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "null_check_on_nullable_type_parameter",
    "description": "_The null check operator shouldn't be used on a variable whose type is a potentially nullable type parameter._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a null check operator is used\non a variable whose type is `T?`, where `T` is a type parameter that\nallows the type argument to be nullable (either has no bound or has a\nbound that is nullable).\n\nGiven a generic type parameter `T` which has a nullable bound, it is very\neasy to introduce erroneous null checks when working with a variable of\ntype `T?`. Specifically, it is not uncommon to have `T? x;` and want to\nassert that `x` has been set to a valid value of type `T`. A common\nmistake is to do so using `x!`. This is almost always incorrect, because\nif `T` is a nullable type, `x` may validly hold `null` as a value of type\n`T`.\n\n## Example\n\nThe following code produces this diagnostic because `t` has the type `T?`\nand `T` allows the type argument to be nullable (because it has no\n`extends` clause):\n\n```dart\nT f<T>(T? t) => t[!!!];\n```\n\n## Common fixes\n\nUse the type parameter to cast the variable:\n\n```dart\nT f<T>(T? t) => t as T;\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "null_closures",
    "description": "_Closure can't be 'null' because it might be invoked._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "omit_local_variable_types",
    "description": "_Unnecessary type annotation on a local variable._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "omit_obvious_local_variable_types",
    "description": "_Omit the type annotation on a local variable when the type is obvious._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "omit_obvious_property_types",
    "description": "_The type annotation isn't needed because it is obvious._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "one_member_abstracts",
    "description": "_Unnecessary use of an abstract class._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "only_throw_errors",
    "description": "_Don't throw instances of classes that don't extend either 'Exception' or 'Error'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the value being thrown isn't a\nsubclass of either `Exception` or `Error`.\n\n## Example\n\nThe following code produces this diagnostic because the string `'f'` is\nbeing thrown:\n\n```dart\nvoid f() => throw [!'f'!];\n```\n\n## Common fixes\n\nReplace the value with an instance of a subclass of either `Exception` or\n`Error`:\n\n```dart\nvoid f() => throw ArgumentError('f');\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "overridden_fields",
    "description": "_Field overrides a field inherited from '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a class defines a field that\noverrides a field from a superclass.\n\nOverriding a field with another field causes the object to have two\ndistinct fields, but because the fields have the same name only one of the\nfields can be referenced in a given scope. That can lead to confusion\nwhere a reference to one of the fields can be mistaken for a reference to\nthe other.\n\n## Example\n\nThe following code produces this diagnostic because the field `f` in `B`\nshadows the field `f` in `A`:\n\n```dart\nclass A {\n  int f = 1;\n}\n\nclass B extends A {\n  @override\n  int [!f!] = 2;\n}\n```\n\n## Common fixes\n\nIf the two fields are representing the same property, then remove the\nfield from the subclass:\n\n```dart\nclass A {\n  int f = 1;\n}\n\nclass B extends A {}\n```\n\nIf the two fields should be distinct, then rename one of the fields:\n\n```dart\nclass A {\n  int f = 1;\n}\n\nclass B extends A {\n  int g = 2;\n}\n```\n\nIf the two fields are related in some way, but can't be the same, then\nfind a different way to implement the semantics you need.\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "package_api_docs",
    "description": "_Missing documentation for public API._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "package_names",
    "description": "_The package name '{0}' isn't a lower\\_case\\_with\\_underscores identifier._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the name of a package doesn't\nuse the lower_case_with_underscores naming convention.\n\n## Example\n\nThe following code produces this diagnostic because the name of the\npackage uses the lowerCamelCase naming convention:\n\n```yaml\nname: [!somePackage!]\n```\n\n## Common fixes\n\nRewrite the name of the package using the lower_case_with_underscores\nnaming convention:\n\n```yaml\nname: some_package\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "package_prefixed_library_names",
    "description": "_The library name is not a dot-separated path prefixed by the package name._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a library has a name that\ndoesn't follow these guidelines:\n\n- Prefix all library names with the package name.\n- Make the entry library have the same name as the package.\n- For all other libraries in a package, after the package name add the\n  dot-separated path to the library's Dart file.\n- For libraries under `lib`, omit the top directory name.\n\nFor example, given a package named `my_package`, here are the library\nnames for various files in the package:\n\n\n## Example\n\nAssuming that the file containing the following code is not in a file\nnamed `special.dart` in the `lib` directory of a package named `something`\n(which would be an exception to the rule), the analyzer produces this\ndiagnostic because the name of the library doesn't conform to the\nguidelines above:\n\n```dart\nlibrary [!something.special!];\n```\n\n## Common fixes\n\nChange the name of the library to conform to the guidelines.\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "parameter_assignments",
    "description": "_Invalid assignment to the parameter '{0}'._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_adjacent_string_concatenation",
    "description": "_String literals shouldn't be concatenated by the '+' operator._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the `+` operator is used to\nconcatenate two string literals.\n\n## Example\n\nThe following code produces this diagnostic because two string literals\nare being concatenated by using the `+` operator:\n\n```dart\nvar s = 'a' [!+!] 'b';\n```\n\n## Common fixes\n\nRemove the operator:\n\n```dart\nvar s = 'a' 'b';\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_asserts_in_initializer_lists",
    "description": "_Assert should be in the initializer list._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the body of a constructor\nbegins with one or more assert statements.\n\n## Example\n\nThe following code produces this diagnostic because the body of the\nconstructor begins with an assert statement:\n\n```dart\nclass C {\n  C(int i) {\n    [!assert!](i != 0);\n  }\n}\n```\n\n## Common fixes\n\nMove the assert to the initializer list, removing the body if there are\nonly assert statements in it:\n\n```dart\nclass C {\n  C(int i) : assert(i != 0);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_asserts_with_message",
    "description": "_Missing a message in an assert._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an assert statement doesn't\nhave a message.\n\n## Example\n\nThe following code produces this diagnostic because there's no message\nin the assert statement:\n\n```dart\nvoid f(String s) {\n  [!assert(s.isNotEmpty);!]\n}\n```\n\n## Common fixes\n\nAdd a message to the assert statement:\n\n```dart\nvoid f(String s) {\n  assert(s.isNotEmpty, 'The argument must not be empty.');\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_bool_in_asserts",
    "description": "",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_collection_literals",
    "description": "_Unnecessary constructor invocation._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor is used to create\na list, map, or set, but a literal would produce the same result.\n\n## Example\n\nThe following code produces this diagnostic because the constructor for\n`Map` is being used to create a map that could also be created using a\nliteral:\n\n```dart\nvar m = [!Map<String, String>()!];\n```\n\n## Common fixes\n\nUse the literal representation:\n\n```dart\nvar m = <String, String>{};\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_conditional_assignment",
    "description": "_The 'if' statement could be replaced by a null-aware assignment._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an assignment to a variable is\nconditional based on whether the variable has the value `null` and the\n`??=` operator could be used instead.\n\n## Example\n\nThe following code produces this diagnostic because the parameter `s` is\nbeing compared to `null` in order to determine whether to assign a\ndifferent value:\n\n```dart\nint f(String? s) {\n  [!if (s == null) {!]\n    [!s = '';!]\n  [!}!]\n  return s.length;\n}\n```\n\n## Common fixes\n\nUse the `??=` operator instead of an explicit `if` statement:\n\n```dart\nint f(String? s) {\n  s ??= '';\n  return s.length;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_const_constructors",
    "description": "_Use 'const' with the constructor to improve performance._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an invocation of a const\nconstructor isn't either preceded by `const` or in a [constant context][].\n\n## Example\n\nThe following code produces this diagnostic because the invocation of the\n`const` constructor is neither prefixed by `const` nor in a\n[constant context][]:\n\n```dart\nclass C {\n  const C();\n}\n\nC c = [!C()!];\n```\n\n## Common fixes\n\nIf the context can be made a [constant context][], then do so:\n\n```dart\nclass C {\n  const C();\n}\n\nconst C c = C();\n```\n\nIf the context can't be made a [constant context][], then add `const`\nbefore the constructor invocation:\n\n```dart\nclass C {\n  const C();\n}\n\nC c = const C();\n```\n\n[constant context]: /resources/glossary#constant-context\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_const_constructors_in_immutables",
    "description": "_Constructors in '@immutable' classes should be declared as 'const'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a non-`const` constructor is\nfound in a class that has the `@immutable` annotation.\n\n## Example\n\nThe following code produces this diagnostic because the constructor in `C`\nisn't declared as `const` even though `C` has the `@immutable` annotation:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@immutable\nclass C {\n  final f;\n\n  [!C!](this.f);\n}\n```\n\n## Common fixes\n\nIf the class really is intended to be immutable, then add the `const`\nmodifier to the constructor:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@immutable\nclass C {\n  final f;\n\n  const C(this.f);\n}\n```\n\nIf the class is mutable, then remove the `@immutable` annotation:\n\n```dart\nclass C {\n  final f;\n\n  C(this.f);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_const_declarations",
    "description": "_Use 'const' for final variables initialized to a constant value._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a top-level variable, static\nfield, or local variable is marked as `final` and is initialized to a\nconstant value.\n\n## Examples\n\nThe following code produces this diagnostic because the top-level variable\n`v` is both `final` and initialized to a constant value:\n\n```dart\n[!final v = const <int>[]!];\n```\n\nThe following code produces this diagnostic because the static field `f`\nis both `final` and initialized to a constant value:\n\n```dart\nclass C {\n  static [!final f = const <int>[]!];\n}\n```\n\nThe following code produces this diagnostic because the local variable `v`\nis both `final` and initialized to a constant value:\n\n```dart\nvoid f() {\n  [!final v = const <int>[]!];\n  print(v);\n}\n```\n\n## Common fixes\n\nReplace the keyword `final` with `const` and remove `const` from the\ninitializer:\n\n```dart\nclass C {\n  static const f = <int>[];\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_const_literals_to_create_immutables",
    "description": "_Use 'const' literals as arguments to constructors of '@immutable' classes._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a non-const list, map, or set\nliteral is passed as an argument to a constructor declared in a class\nannotated with `@immutable`.\n\n## Example\n\nThe following code produces this diagnostic because the list literal\n(`[1]`) is being passed to a constructor in an immutable class but isn't\na constant list:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@immutable\nclass C {\n  final f;\n\n  const C(this.f);\n}\n\nC c = C([![1]!]);\n```\n\n## Common fixes\n\nIf the context can be made a [constant context][], then do so:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@immutable\nclass C {\n  final f;\n\n  const C(this.f);\n}\n\nconst C c = C([1]);\n```\n\nIf the context can't be made a [constant context][] but the constructor\ncan be invoked using `const`, then add `const` before the constructor\ninvocation:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@immutable\nclass C {\n  final f;\n\n  const C(this.f);\n}\n\nC c = const C([1]);\n```\n\nIf the context can't be made a [constant context][] and the constructor\ncan't be invoked using `const`, then add the keyword `const` before the\ncollection literal:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@immutable\nclass C {\n  final f;\n\n  const C(this.f);\n}\n\nC c = C(const [1]);\n```\n\n[constant context]: /resources/glossary#constant-context\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_constructors_over_static_methods",
    "description": "_Static method should be a constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a static method returns a newly\ncreated instance of the class and could, therefore, be a constructor.\n\n## Example\n\nThe following code produces this diagnostic because the static method\n`all` could be a constructor:\n\n```dart\nclass C {\n  final int a, b, c;\n  C(this.a, this.b, this.c);\n  static C [!all!](int i) => C(i, i, i);\n}\n```\n\n## Common fixes\n\nConvert the static method to a named constructor:\n\n```dart\nclass C {\n  final int a, b, c;\n  C(this.a, this.b, this.c);\n  C.all(int i) : a = i, b = i, c = i;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_contains",
    "description": "_Always 'false' because 'indexOf' is always greater than or equal to -1._\n\n_Always 'true' because 'indexOf' is always greater than or equal to -1._\n\n_Unnecessary use of 'indexOf' to test for containment._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the method `indexOf` is used and\nthe result is only compared with `-1` or `0` in a way where the semantics\nare equivalent to using `contains`.\n\n## Example\n\nThe following code produces this diagnostic because the condition in the\n`if` statement is checking to see whether the list contains the string:\n\n```dart\nvoid f(List<String> l, String s) {\n  if ([!l.indexOf(s) < 0!]) {\n    // ...\n  }\n}\n```\n\n## Common fixes\n\nUse `contains` instead, negating the condition when necessary:\n\n```dart\nvoid f(List<String> l, String s) {\n  if (l.contains(s)) {\n    // ...\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_double_quotes",
    "description": "_Unnecessary use of single quotes._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a string literal uses single\nquotes (`'`) when it could use double quotes (`\"`) without needing extra\nescapes and without hurting readability.\n\n## Example\n\nThe following code produces this diagnostic because the string literal\nuses single quotes but doesn't need to:\n\n```dart\nvoid f(String name) {\n  print([!'Hello $name'!]);\n}\n```\n\n## Common fixes\n\nUse double quotes in place of single quotes:\n\n```dart\nvoid f(String name) {\n  print(\"Hello $name\");\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_equal_for_default_values",
    "description": "",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_expression_function_bodies",
    "description": "_Unnecessary use of a block function body._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the body of a function consists\nof a single return statement with an expression.\n\n## Example\n\nThe following code produces this diagnostic because the body of `f` has a\nsingle return statement:\n\n```dart\nint f() [!{!]\n  [!return 0;!]\n[!}!]\n```\n\n## Common fixes\n\nIf the body is complete, then replace the body with an expression body:\n\n```dart\nint f() => 0;\n```\n\nIf the body isn't complete, then add the missing statements.\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_final_fields",
    "description": "_The private field {0} could be 'final'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a private field is only\nassigned one time. The field can be initialized in multiple constructors\nand still be flagged because only one of those constructors can ever run.\n\n## Example\n\nThe following code produces this diagnostic because the field `_f` is only\nassigned one time, in the field's initializer:\n\n```dart\nclass C {\n  int [!_f = 1!];\n\n  int get f => _f;\n}\n```\n\n## Common fixes\n\nMark the field `final`:\n\n```dart\nclass C {\n  final int _f = 1;\n\n  int get f => _f;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_final_in_for_each",
    "description": "_The pattern should be final._\n\n_The variable '{0}' should be final._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the loop variable in a for-each\nstatement isn't marked as being `final`.\n\n## Example\n\nThe following code produces this diagnostic because the loop variable `e`\nisn't marked as being `final`:\n\n```dart\nvoid f(List<int> l) {\n  for (var [!e!] in l) {\n    print(e);\n  }\n}\n```\n\n## Common fixes\n\nAdd the modifier `final` to the loop variable, removing the `var` if there\nis one:\n\n```dart\nvoid f(List<int> l) {\n  for (final e in l) {\n    print(e);\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_final_locals",
    "description": "_Local variables should be final._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a local variable isn't marked\nas being `final`.\n\n## Example\n\nThe following code produces this diagnostic because the variable `s` isn't\nmarked as being `final`:\n\n```dart\nint f(int i) {\n  [!var!] s = i + 1;\n  return s;\n}\n```\n\n## Common fixes\n\nAdd the modifier `final` to the variable, removing the `var` if there is\none:\n\n```dart\nint f(int i) {\n  final s = i + 1;\n  return s;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_final_parameters",
    "description": "_The parameter '{0}' should be final._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a parameter of a constructor,\nmethod, function, or closure isn't marked as being `final`.\n\n## Example\n\nThe following code produces this diagnostic because the parameter `s`\nisn't a `final` parameter:\n\n```dart\nString f([!String s!]) => s;\n```\n\n## Common fixes\n\nAdd the modifier `final` to the parameter:\n\n```dart\nString f(final String s) => s;\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_for_elements_to_map_fromiterable",
    "description": "_Use 'for' elements when building maps from iterables._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when `Map.fromIterable` is used to\nbuild a map that could be built using the `for` element.\n\n## Example\n\nThe following code produces this diagnostic because `fromIterable` is\nbeing used to build a map that could be built using a `for` element:\n\n```dart\nvoid f(Iterable<String> data) {\n  [!Map<String, int>.fromIterable(!]\n    [!data,!]\n    [!key: (element) => element,!]\n    [!value: (element) => element.length,!]\n  [!)!];\n}\n```\n\n## Common fixes\n\nUse a `for` element to build the map:\n\n```dart\nvoid f(Iterable<String> data) {\n  <String, int>{\n    for (var element in data)\n      element: element.length\n  };\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_foreach",
    "description": "_Use 'forEach' and a tear-off rather than a 'for' loop to apply a function to every element._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `for` loop is used to operate\non every member of a collection and the method `forEach` could be used\ninstead.\n\n## Example\n\nThe following code produces this diagnostic because a `for` loop is being\nused to invoke a single function for each key in `m`:\n\n```dart\nvoid f(Map<String, int> m) {\n  [!for (final key in m.keys) {!]\n    [!print(key);!]\n  [!}!]\n}\n```\n\n## Common fixes\n\nReplace the for loop with an invocation of `forEach`:\n\n```dart\nvoid f(Map<String, int> m) {\n  m.keys.forEach(print);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_function_declarations_over_variables",
    "description": "_Use a function declaration rather than a variable assignment to bind a function to a name._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a closure is assigned to a\nlocal variable and the local variable is not re-assigned anywhere.\n\n## Example\n\nThe following code produces this diagnostic because the local variable `f`\nis initialized to be a closure and isn't assigned any other value:\n\n```dart\nvoid g() {\n  var [!f = (int i) => i * 2!];\n  f(1);\n}\n```\n\n## Common fixes\n\nReplace the local variable with a local function:\n\n```dart\nvoid g() {\n  int f(int i) => i * 2;\n  f(1);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_generic_function_type_aliases",
    "description": "_Use the generic function type syntax in 'typedef's._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a typedef is written using the\nolder syntax for function type aliases in which the name being declared is\nembedded in the function type.\n\n## Example\n\nThe following code produces this diagnostic because it uses the older\nsyntax:\n\n```dart\ntypedef void [!F!]<T>();\n```\n\n## Common fixes\n\nRewrite the typedef to use the newer syntax:\n\n```dart\ntypedef F<T> = void Function();\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_if_elements_to_conditional_expressions",
    "description": "_Use an 'if' element to conditionally add elements._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_if_null_operators",
    "description": "_Use the '??' operator rather than '?:' when testing for 'null'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a conditional expression (using\nthe `?:` operator) is used to select a different value when a local\nvariable is `null`.\n\n## Example\n\nThe following code produces this diagnostic because the variable `s` is\nbeing compared to `null` so that a different value can be returned when\n`s` is `null`:\n\n```dart\nString f(String? s) => [!s == null ? '' : s!];\n```\n\n## Common fixes\n\nUse the if-null operator instead:\n\n```dart\nString f(String? s) => s ?? '';\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_initializing_formals",
    "description": "_Use an initializing formal to assign a parameter to a field._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor parameter is used\nto initialize a field without modification.\n\n## Example\n\nThe following code produces this diagnostic because the parameter `c` is\nonly used to set the field `c`:\n\n```dart\nclass C {\n  int c;\n\n  C(int c) : [!this.c = c!];\n}\n```\n\n## Common fixes\n\nUse an initializing formal parameter to initialize the field:\n\n```dart\nclass C {\n  int c;\n\n  C(this.c);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_inlined_adds",
    "description": "_The addition of a list item could be inlined._\n\n_The addition of multiple list items could be inlined._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the methods `add` and `addAll`\nare invoked on a list literal where the elements being added could be\nincluded in the list literal.\n\n## Example\n\nThe following code produces this diagnostic because the `add` method is\nbeing used to add `b`, when it could have been included directly in the\nlist literal:\n\n```dart\nList<String> f(String a, String b) {\n  return [a]..[!add!](b);\n}\n```\n\nThe following code produces this diagnostic because the `addAll` method is\nbeing used to add the elements of `b`, when it could have been included\ndirectly in the list literal:\n\n```dart\nList<String> f(String a, List<String> b) {\n  return [a]..[!addAll!](b);\n}\n```\n\n## Common fixes\n\nIf the `add` method is being used, then make the argument an element of\nthe list and remove the invocation:\n\n```dart\nList<String> f(String a, String b) {\n  return [a, b];\n}\n```\n\nIf the `addAll` method is being used, then use the spread operator on the\nargument to add its elements to the list and remove the invocation:\n\n```dart\nList<String> f(String a, List<String> b) {\n  return [a, ...b];\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_int_literals",
    "description": "_Unnecessary use of a 'double' literal._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_interpolation_to_compose_strings",
    "description": "_Use interpolation to compose strings and values._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when string literals and computed\nstrings are being concatenated using the `+` operator, but string\ninterpolation would achieve the same result.\n\n## Example\n\nThe following code produces this diagnostic because the String `s` is\nconcatenated with other strings using the `+` operator:\n\n```dart\nString f(String s) {\n  return [!'(' + s!] + ')';\n}\n```\n\n## Common fixes\n\nUse string interpolation:\n\n```dart\nString f(List<String> l) {\n  return '(${l[0]}, ${l[1]})';\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_is_empty",
    "description": "_The comparison is always 'false' because the length is always greater than or equal to 0._\n\n_The comparison is always 'true' because the length is always greater than or equal to 0._\n\n_Use 'isEmpty' instead of 'length' to test whether the collection is empty._\n\n_Use 'isNotEmpty' instead of 'length' to test whether the collection is empty._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the result of invoking either\n`Iterable.length` or `Map.length` is compared for equality with zero\n(`0`).\n\n## Example\n\nThe following code produces this diagnostic because the result of invoking\n`length` is checked for equality with zero:\n\n```dart\nint f(Iterable<int> p) => [!p.length == 0!] ? 0 : p.first;\n```\n\n## Common fixes\n\nReplace the use of `length` with a use of either `isEmpty` or\n`isNotEmpty`:\n\n```dart\nvoid f(Iterable<int> p) => p.isEmpty ? 0 : p.first;\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_is_not_empty",
    "description": "_Use 'isNotEmpty' rather than negating the result of 'isEmpty'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the result of invoking\n`Iterable.isEmpty` or `Map.isEmpty` is negated.\n\n## Example\n\nThe following code produces this diagnostic because the result of invoking\n`Iterable.isEmpty` is negated:\n\n```dart\nvoid f(Iterable<int> p) => [!!p.isEmpty!] ? p.first : 0;\n```\n\n## Common fixes\n\nRewrite the code to use `isNotEmpty`:\n\n```dart\nvoid f(Iterable<int> p) => p.isNotEmpty ? p.first : 0;\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_is_not_operator",
    "description": "_Use the 'is!' operator rather than negating the value of the 'is' operator._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the prefix `!` operator is used\nto negate the result of an `is` test.\n\n## Example\n\nThe following code produces this diagnostic because the result of testing\nto see whether `o` is a `String` is negated using the prefix `!` operator:\n\n```dart\nString f(Object o) {\n  if ([!!(o is String)!]) {\n    return o.toString();\n  }\n  return o;\n}\n```\n\n## Common fixes\n\nUse the `is!` operator instead:\n\n```dart\nString f(Object o) {\n  if (o is! String) {\n    return o.toString();\n  }\n  return o;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_iterable_wheretype",
    "description": "_Use 'whereType' to select elements of a given type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the method `Iterable.where` is\nbeing used to filter elements based on their type.\n\n## Example\n\nThe following code produces this diagnostic because the method `where` is\nbeing used to access only the strings within the iterable:\n\n```dart\nIterable<Object> f(Iterable<Object> p) => p.[!where!]((e) => e is String);\n```\n\n## Common fixes\n\nRewrite the code to use `whereType`:\n\n```dart\nIterable<String> f(Iterable<Object> p) => p.whereType<String>();\n```\n\nThis might also allow you to tighten the types in your code or remove\nother type checks.\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_mixin",
    "description": "_Only mixins should be mixed in._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_null_aware_method_calls",
    "description": "_Use a null-aware invocation of the 'call' method rather than explicitly testing for 'null'._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_null_aware_operators",
    "description": "_Use the null-aware operator '?.' rather than an explicit 'null' comparison._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a comparison with `null` is\nused to guard a member reference, and `null` is used as a result when the\nguarded target is `null`.\n\n## Example\n\nThe following code produces this diagnostic because the invocation of\n`length` is guarded by a `null` comparison even though the default value\nis `null`:\n\n```dart\nint? f(List<int>? p) {\n  return [!p == null ? null : p.length!];\n}\n```\n\n## Common fixes\n\nUse a null-aware access operator instead:\n\n```dart\nint? f(List<int>? p) {\n  return p?.length;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_relative_imports",
    "description": "_Use relative imports for files in the 'lib' directory._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an `import` in a library inside\nthe `lib` directory uses a `package:` URI to refer to another library in\nthe same package.\n\n## Example\n\nThe following code produces this diagnostic because it uses a `package:`\nURI when a relative URI could have been used:\n\n```dart\nimport 'package:my_package/bar.dart';\n```\n\n## Common fixes\n\nUse a relative URI to import the library:\n\n```dart\nimport 'bar.dart';\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_single_quotes",
    "description": "_Unnecessary use of double quotes._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a string literal uses double\nquotes (`\"`) when it could use single quotes (`'`) without needing extra\nescapes and without hurting readability.\n\n## Example\n\nThe following code produces this diagnostic because the string literal\nuses double quotes but doesn't need to:\n\n```dart\nvoid f(String name) {\n  print([!\"Hello $name\"!]);\n}\n```\n\n## Common fixes\n\nUse single quotes in place of double quotes:\n\n```dart\nvoid f(String name) {\n  print('Hello $name');\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_spread_collections",
    "description": "_The addition of multiple elements could be inlined._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_typing_uninitialized_variables",
    "description": "_An uninitialized field should have an explicit type annotation._\n\n_An uninitialized variable should have an explicit type annotation._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a variable without an\ninitializer doesn't have an explicit type annotation.\n\nWithout either a type annotation or an initializer, a variable has the\ntype `dynamic`, which allows any value to be assigned to the variable,\noften causing hard to identify bugs.\n\n## Example\n\nThe following code produces this diagnostic because the variable `r`\ndoesn't have either a type annotation or an initializer:\n\n```dart\nObject f() {\n  var [!r!];\n  r = '';\n  return r;\n}\n```\n\n## Common fixes\n\nIf the variable can be initialized, then add an initializer:\n\n```dart\nObject f() {\n  var r = '';\n  return r;\n}\n```\n\nIf the variable can't be initialized, then add an explicit type\nannotation:\n\n```dart\nObject f() {\n  String r;\n  r = '';\n  return r;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "prefer_void_to_null",
    "description": "_Unnecessary use of the type 'Null'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when `Null` is used in a location\nwhere `void` would be a valid choice.\n\n## Example\n\nThe following code produces this diagnostic because the function `f` is\ndeclared to return `null` (at some future time):\n\n```dart\nFuture<[!Null!]> f() async {}\n```\n\n## Common fixes\n\nReplace the use of `Null` with a use of `void`:\n\n```dart\nFuture<void> f() async {}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "provide_deprecation_message",
    "description": "_Missing a deprecation message._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `deprecated` annotation is\nused instead of the `Deprecated` annotation.\n\n## Example\n\nThe following code produces this diagnostic because the function `f` is\nannotated with `deprecated`:\n\n```dart\n[!@deprecated!]\nvoid f() {}\n```\n\n## Common fixes\n\nConvert the code to use the longer form:\n\n```dart\n@Deprecated('Use g instead. Will be removed in 4.0.0.')\nvoid f() {}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "public_member_api_docs",
    "description": "_Missing documentation for a public member._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the declaration of part of the\npublic API of a package doesn't have a documentation comment.\n\n## Example\n\nThe following code produces this diagnostic because the class `C` doesn't\nhave a documentation comment:\n\n```dart\nclass [!C!] {}\n```\n\n## Common fixes\n\nAdd a documentation comment.\n\n```dart\n/// Documentation comment.\nclass C {}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "recursive_getters",
    "description": "_The getter '{0}' recursively returns itself._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a getter invokes itself,\nresulting in an infinite loop.\n\n## Example\n\nThe following code produces this diagnostic because the getter `count`\ninvokes itself:\n\n```dart\nclass C {\n  int _count = 0;\n\n  int get [!count!] => count;\n}\n```\n\n## Common fixes\n\nChange the getter to not invoke itself:\n\n```dart\nclass C {\n  int _count = 0;\n\n  int get count => _count;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "remove_deprecations_in_breaking_versions",
    "description": "_Remove deprecated elements in breaking versions._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic in packages that have a \"breaking\"\nversion number (`x.0.0` or `0.x.0`) for every declaration that has a\n`@Deprecated` annotation.\n\n## Example\n\nGiven a package with a `pubspec.yaml` file containing:\n\n```yaml\nname: p\nversion: 2.0.0\nenvironment:\n  sdk: ^3.9.0\n```\n\nThe following code produces this diagnostic because the function `f` is\nannotated with `@deprecated`:\n\n```dart\n@[!deprecated!]\nvoid f() {}\n\nvoid g() {}\n```\n\n## Common fixes\n\n* If the declaration should be removed in the next release of the package,\nthen remove the declaration:\n\n```dart\nvoid g() {}\n```\n\n* If you are not making a breaking change, then use a minor or patch\n  version increment for the package:\n\n```yaml\nname: p\nversion: 1.0.1\nenvironment:\n  sdk: ^3.9.0\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "require_trailing_commas",
    "description": "_Missing a required trailing comma._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "secure_pubspec_urls",
    "description": "_The '{0}' protocol shouldn't be used because it isn't secure._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a URL in a `pubspec.yaml` file is\nusing a non-secure scheme, such as `http`.\n\n## Example\n\nThe following code produces this diagnostic because the `pubspec.yaml` file\ncontains an `http` URL:\n\n```yaml\ndependencies:\n  example: any\n    repository: [!http://github.com/dart-lang/example!]\n```\n\n## Common fixes\n\nChange the scheme of the URL to use a secure scheme, such as `https`:\n\n```yaml\ndependencies:\n  example: any\n    repository: https://github.com/dart-lang/example\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "sized_box_for_whitespace",
    "description": "_Use a 'SizedBox' to add whitespace to a layout._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `Container` is created using\nonly the `height` and/or `width` arguments.\n\n## Example\n\nThe following code produces this diagnostic because the `Container` has\nonly the `width` argument:\n\n```dart\nimport 'package:flutter/material.dart';\n\nWidget buildRow() {\n  return Row(\n    children: <Widget>[\n      const Text('...'),\n      [!Container!](\n        width: 4,\n        child: Text('...'),\n      ),\n      const Expanded(\n        child: Text('...'),\n      ),\n    ],\n  );\n}\n```\n\n## Common fixes\n\nReplace the `Container` with a `SizedBox` of the same dimensions:\n\n```dart\nimport 'package:flutter/material.dart';\n\nWidget buildRow() {\n  return Row(\n    children: <Widget>[\n      Text('...'),\n      SizedBox(\n        width: 4,\n        child: Text('...'),\n      ),\n      Expanded(\n        child: Text('...'),\n      ),\n    ],\n  );\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "sized_box_shrink_expand",
    "description": "_Use 'SizedBox.{0}' to avoid needing to specify the 'height' and 'width'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `SizedBox` constructor\ninvocation specifies the values of both `height` and `width` as either\n`0.0` or `double.infinity`.\n\n## Examples\n\nThe following code produces this diagnostic because both the `height` and\n`width` are `0.0`:\n\n```dart\nimport 'package:flutter/material.dart';\n\nWidget build() {\n  return [!SizedBox!](\n    height: 0.0,\n    width: 0.0,\n    child: const Text(''),\n  );\n}\n```\n\nThe following code produces this diagnostic because both the `height` and\n`width` are `double.infinity`:\n\n```dart\nimport 'package:flutter/material.dart';\n\nWidget build() {\n  return [!SizedBox!](\n    height: double.infinity,\n    width: double.infinity,\n    child: const Text(''),\n  );\n}\n```\n\n## Common fixes\n\nIf both are `0.0`, then use `SizedBox.shrink`:\n\n```dart\nimport 'package:flutter/material.dart';\n\nWidget build() {\n  return SizedBox.shrink(\n    child: const Text(''),\n  );\n}\n```\n\nIf both are `double.infinity`, then use `SizedBox.expand`:\n\n```dart\nimport 'package:flutter/material.dart';\n\nWidget build() {\n  return SizedBox.expand(\n    child: const Text(''),\n  );\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "slash_for_doc_comments",
    "description": "_Use the end-of-line form ('///') for doc comments._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a documentation comment uses\nthe block comment style (delimited by `/**` and `*/`).\n\n## Example\n\nThe following code produces this diagnostic because the documentation\ncomment for `f` uses a block comment style:\n\n```dart\n[!/**!]\n [!* Example.!]\n [!*/!]\nvoid f() {}\n```\n\n## Common fixes\n\nUse an end-of-line comment style:\n\n```dart\n/// Example.\nvoid f() {}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "sort_child_properties_last",
    "description": "_The '{0}' argument should be last in widget constructor invocations._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the `child` or `children`\nargument isn't the last argument in an invocation of a widget class'\nconstructor. An exception is made if all of the arguments after the\n`child` or `children` argument are function expressions.\n\n## Example\n\nThe following code produces this diagnostic because the `child` argument\nisn't the last argument in the invocation of the `Center` constructor:\n\n```dart\nimport 'package:flutter/material.dart';\n\nWidget createWidget() {\n  return Center(\n    [!child: Text('...')!],\n    widthFactor: 0.5,\n  );\n}\n```\n\n## Common fixes\n\nMove the `child` or `children` argument to be last:\n\n```dart\nimport 'package:flutter/material.dart';\n\nWidget createWidget() {\n  return Center(\n    widthFactor: 0.5,\n    child: Text('...'),\n  );\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "sort_constructors_first",
    "description": "_Constructor declarations should be before non-constructor declarations._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor declaration is\npreceded by one or more non-constructor declarations.\n\n## Example\n\nThe following code produces this diagnostic because the constructor for\n`C` appears after the method `m`:\n\n```dart\nclass C {\n  void m() {}\n\n  [!C!]();\n}\n```\n\n## Common fixes\n\nMove all of the constructor declarations before any other declarations:\n\n```dart\nclass C {\n  C();\n\n  void m() {}\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "sort_pub_dependencies",
    "description": "_Dependencies not sorted alphabetically._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the keys in a dependency map in\nthe `pubspec.yaml` file aren't sorted alphabetically. The dependency maps\nthat are checked are the `dependencies`, `dev_dependencies`, and\n`dependency_overrides` maps.\n\n## Example\n\nThe following code produces this diagnostic because the entries in the\n`dependencies` map are not sorted:\n\n```yaml\ndependencies:\n  path: any\n  collection: any\n```\n\n## Common fixes\n\nSort the entries:\n\n```yaml\ndependencies:\n  collection: any\n  path: any\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "sort_unnamed_constructors_first",
    "description": "_Invalid location for the unnamed constructor._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an unnamed constructor appears\nafter a named constructor.\n\n## Example\n\nThe following code produces this diagnostic because the unnamed\nconstructor is after the named constructor:\n\n```dart\nclass C {\n  C.named();\n\n  [!C!]();\n}\n```\n\n## Common fixes\n\nMove the unnamed constructor before any other constructors:\n\n```dart\nclass C {\n  C();\n\n  C.named();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "specify_nonobvious_local_variable_types",
    "description": "_Specify the type of a local variable when the type is non-obvious._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "specify_nonobvious_property_types",
    "description": "_A type annotation is needed because it isn't obvious._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "strict_top_level_inference",
    "description": "_Missing type annotation._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "super_goes_last",
    "description": "",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "switch_on_type",
    "description": "_Avoid switch statements on a 'Type'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a switch statement or switch\nexpression is used on either the value of a `Type` or a `toString` call\non a `Type`.\n\n## Example\n\nThe following code produces this diagnostic because the switch statement\nis used on a `Type`:\n\n```dart\nvoid f(Object o) {\n  switch ([!o.runtimeType!]) {\n    case const (int):\n      print('int');\n    case const (String):\n      print('String');\n  }\n}\n```\n\n## Common fixes\n\nUse pattern matching on the variable instead:\n\n```dart\nvoid f(Object o) {\n  switch (o) {\n    case int():\n      print('int');\n    case String():\n      print('String');\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "test_types_in_equals",
    "description": "_Missing type test for '{0}' in '=='._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an override of the `==`\noperator doesn't include a type test on the value of the parameter.\n\n## Example\n\nThe following code produces this diagnostic because `other` is not type\ntested:\n\n```dart\nclass C {\n  final int f;\n\n  C(this.f);\n\n  @override\n  bool operator ==(Object other) {\n    return ([!other as C!]).f == f;\n  }\n}\n```\n\n## Common fixes\n\nPerform an `is` test as part of computing the return value:\n\n```dart\nclass C {\n  final int f;\n\n  C(this.f);\n\n  @override\n  bool operator ==(Object other) {\n    return other is C && other.f == f;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "throw_in_finally",
    "description": "_Use of '{0}' in 'finally' block._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `throw` statement is found\ninside a `finally` block.\n\n## Example\n\nThe following code produces this diagnostic because there is a `throw`\nstatement inside a `finally` block:\n\n```dart\nvoid f() {\n  try {\n    // ...\n  } catch (e) {\n    // ...\n  } finally {\n    [!throw 'error'!];\n  }\n}\n```\n\n## Common fixes\n\nRewrite the code so that the `throw` statement isn't inside a `finally`\nblock:\n\n```dart\nvoid f() {\n  try {\n    // ...\n  } catch (e) {\n    // ...\n  }\n  throw 'error';\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "tighten_type_of_initializing_formals",
    "description": "_Use a type annotation rather than 'assert' to enforce non-nullability._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an `assert` is being used in\nthe initializer list of a constructor to ensure that only a non-`null`\nvalue is being used to initialize a field.\n\n## Example\n\nThe following code produces this diagnostic because an `assert` is being\nused to catch an error that could be caught by the type system:\n\n```dart\nclass C {\n  final String? s;\n\n  C([!this.s!]) : assert(s != null);\n}\n```\n\n## Common fixes\n\nRemove the `assert` and add the non-nullable type before the initializing\nformal:\n\n```dart\nclass C {\n  final String? s;\n\n  C(String this.s);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "type_annotate_public_apis",
    "description": "_Missing type annotation on a public API._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the declaration of part of the\npublic API of a package doesn't have explicit type annotations.\n\n## Example\n\nThe following code produces this diagnostic because the function `f`\ndoesn't have an explicit return type and the parameters `x` and `y` don't\nhave explicit types:\n\n```dart\n[!f!](x, y) => '';\n```\n\n## Common fixes\n\nAdd type annotations to the API:\n\n```dart\nString f(int x, int y) => '';\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "type_init_formals",
    "description": "_Don't needlessly type annotate initializing formals._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an initializing formal\nparameter (`this.x`) or a super parameter (`super.x`) has an explicit type\nannotation that is the same as the field or overridden parameter.\n\nIf a constructor parameter is using `this.x` to initialize a field, then\nthe type of the parameter is implicitly the same type as the field. If a\nconstructor parameter is using `super.x` to forward to a super\nconstructor, then the type of the parameter is implicitly the same as the\nsuper constructor parameter.\n\n## Example\n\nThe following code produces this diagnostic because the parameter `this.c`\nhas an explicit type that is the same as the field `c`:\n\n```dart\nclass C {\n  int c;\n\n  C([!int!] this.c);\n}\n```\n\nThe following code produces this diagnostic because the parameter\n`super.a` has an explicit type that is the same as the parameter `a` from\nthe superclass:\n\n```dart\nclass A {\n  A(int a);\n}\n\nclass B extends A {\n  B([!int!] super.a);\n}\n```\n\n## Common fixes\n\nRemove the type annotation from the parameter:\n\n```dart\nclass C {\n  int c;\n\n  C(this.c);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "type_literal_in_constant_pattern",
    "description": "_Use 'TypeName \\_' instead of a type literal._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a type literal appears as a\npattern.\n\n## Example\n\nThe following code produces this diagnostic because a type literal is used\nas a constant pattern:\n\n```dart\nvoid f(Object? x) {\n  if (x case [!num!]) {\n    // ...\n  }\n}\n```\n\n## Common fixes\n\nIf the type literal is intended to match an object of the given type, then\nuse either a variable pattern:\n\n```dart\nvoid f(Object? x) {\n  if (x case num _) {\n    // ...\n  }\n}\n```\n\nOr an object pattern:\n\n```dart\nvoid f(Object? x) {\n  if (x case num()) {\n    // ...\n  }\n}\n```\n\nIf the type literal is intended to match the type literal, then write it\nas a constant pattern:\n\n```dart\nvoid f(Object? x) {\n  if (x case const (num)) {\n    // ...\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unawaited_futures",
    "description": "_Missing an 'await' for the 'Future' computed by this expression._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic on an expression with a `Future`\ntype, only in a few specific cases:\n\n* when the expression is itself a statement (like `f();`),\n* when the expression is part of a cascade (like `C()..f()`),\n* when the expression is a String interpolation (like `'${f()}'`).\n\nThe analyzer only produces this diagnostic on expressions inside an\n`async` or `async*` function.\n\nThe two common corrections are to 'await' the expression, or to wrap the\nexpression in a call to `unawaited()`.\n\n## Example\n\nThe following code produces this diagnostic because the function `g`\nreturns a future, but the future isn't awaited:\n\n```dart\nFuture<void> f() async {\n  [!g!]();\n}\n\nFuture<int> g() => Future.value(0);\n```\n\n## Common fixes\n\nIf the future needs to complete before the following code is executed,\nthen add an `await` before the invocation:\n\n```dart\nFuture<void> f() async {\n  await g();\n}\n\nFuture<int> g() => Future.value(0);\n```\n\nIf the future doesn't need to complete before the following code is\nexecuted, then wrap the `Future`-returning invocation in an invocation of\nthe `unawaited` function:\n\n```dart\nimport 'dart:async';\n\nFuture<void> f() async {\n  unawaited(g());\n}\n\nFuture<int> g() => Future.value(0);\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "undefined_variable",
    "description": "_The variable '{0}' isn't defined._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unexpected_transform_set_token",
    "description": "_Didn't expect to find {0}._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unintended_html_in_doc_comment",
    "description": "_Angle brackets will be interpreted as HTML._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a documentation comment\ncontains angle bracketed text (`<...>`) that isn't one of the allowed\nexceptions.\n\nSuch text is interpreted by markdown to be an HTML tag, which is rarely\nwhat was intended.\n\nSee the [lint rule description](https://dart.dev/tools/linter-rules/unintended_html_in_doc_comment)\nfor the list of allowed exceptions.\n\n## Example\n\nThe following code produces this diagnostic because the documentation\ncomment contains the text `<int>`, which isn't one of the allowed\nexceptions:\n\n```dart\n/// Converts a List[!<int>!] to a comma-separated String.\nString f(List<int> l) => '';\n```\n\n## Common fixes\n\nIf the text was intended to be part of a code span, then add backticks\naround the code:\n\n```dart\n/// Converts a `List<int>` to a comma-separated String.\nString f(List<int> l) => '';\n```\n\nIf the text was intended to be part of a link, then add square brackets\naround the code:\n\n```dart\n/// Converts a [List<int>] to a comma-separated String.\nString f(List<int> l) => '';\n```\n\nIf the text was intended to be printed as-is, including the angle\nbrackets, then add backslash escapes before the angle brackets:\n\n```dart\n/// Converts a List\\<int\\> to a comma-separated String.\nString f(List<int> l) => '';\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unknown_accessor",
    "description": "_The accessor '{0}' is invalid._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unnecessary_async",
    "description": "_Don't make a function 'async' if it doesn't use 'await'._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_await_in_return",
    "description": "_Unnecessary 'await'._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_brace_in_string_interps",
    "description": "_Unnecessary braces in a string interpolation._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a string interpolation with\nbraces is used to interpolate a simple identifier and isn't followed by\nalphanumeric text.\n\n## Example\n\nThe following code produces this diagnostic because the interpolation\nelement `${s}` uses braces when they are not necessary:\n\n```dart\nString f(String s) {\n  return '\"[!${s}!]\"';\n}\n```\n\n## Common fixes\n\nRemove the unnecessary braces:\n\n```dart\nString f(String s) {\n  return '\"$s\"';\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_breaks",
    "description": "_Unnecessary 'break' statement._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_const",
    "description": "_Unnecessary 'const' keyword._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the keyword `const` is used in\na [constant context][]. The keyword isn't required because it's implied.\n\n## Example\n\nThe following code produces this diagnostic because the keyword `const` in\nthe list literal isn't needed:\n\n```dart\nconst l = [!const!] <int>[];\n```\n\nThe list is implicitly `const` because of the keyword `const` on the\nvariable declaration.\n\n## Common fixes\n\nRemove the unnecessary keyword:\n\n```dart\nconst l = <int>[];\n```\n\n[constant context]: /resources/glossary#constant-context\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_constructor_name",
    "description": "_Unnecessary '.new' constructor name._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a reference to an unnamed\nconstructor uses `.new`. The only place where `.new` is required is in a\nconstructor tear-off.\n\n## Example\n\nThe following code produces this diagnostic because `.new` is being used\nto refer to the unnamed constructor where it isn't required:\n\n```dart\nvar o = Object.[!new!]();\n```\n\n## Common fixes\n\nRemove the unnecessary `.new`:\n\n```dart\nvar o = Object();\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_final",
    "description": "_Local variables should not be marked as 'final'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a local variable is marked as\nbeing `final`.\n\n## Example\n\nThe following code produces this diagnostic because the local variable `c`\nis marked as being `final`:\n\n```dart\nvoid f(int a, int b) {\n  [!final!] c = a + b;\n  print(c);\n}\n```\n\n## Common fixes\n\nIf the variable doesn't have a type annotation, then replace the `final`\nwith `var`:\n\n```dart\nvoid f(int a, int b) {\n  var c = a + b;\n  print(c);\n}\n```\n\nIf the variable has a type annotation, then remove the `final`\nmodifier:\n\n```dart\nvoid f(int a, int b) {\n  int c = a + b;\n  print(c);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_getters_setters",
    "description": "_Unnecessary use of getter and setter to wrap a field._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a getter and setter pair\nreturns and sets the value of a field without any additional processing.\n\n## Example\n\nThe following code produces this diagnostic because the getter/setter pair\nnamed `c` only expose the field named `_c`:\n\n```dart\nclass C {\n  int? _c;\n\n  int? get [!c!] => _c;\n\n  set c(int? v) => _c = v;\n}\n```\n\n## Common fixes\n\nMake the field public and remove the getter and setter:\n\n```dart\nclass C {\n  int? c;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_ignore",
    "description": "_The diagnostic '{0}' isn't produced at this location so it doesn't need to be ignored._\n\n_The diagnostic '{0}' isn't produced in this file so it doesn't need to be ignored._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an ignore is specified to\nignore a diagnostic that isn't produced.\n\n## Example\n\nThe following code produces this diagnostic because the\n`unused_local_variable` diagnostic isn't reported at the ignored location:\n\n```dart\n// ignore: [!unused_local_variable!]\nvoid f() {}\n```\n\n## Common fixes\n\nRemove the ignore comment:\n\n```dart\nvoid f() {}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_lambdas",
    "description": "_Closure should be a tearoff._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a closure (lambda) could be\nreplaced by a tear-off.\n\n## Example\n\nThe following code produces this diagnostic because the closure passed to\n`forEach` contains only an invocation of the function `print` with the\nparameter of the closure:\n\n```dart\nvoid f(List<String> strings) {\n  strings.forEach([!(string) {!]\n    [!print(string);!]\n  [!}!]);\n}\n```\n\n## Common fixes\n\nReplace the closure with a tear-off of the function or method being\ninvoked with the closure:\n\n```dart\nvoid f(List<String> strings) {\n  strings.forEach(print);\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_late",
    "description": "_Unnecessary 'late' modifier._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a top-level variable or static\nfield with an initializer is marked as `late`. Top-level variables and\nstatic fields are implicitly late, so they don't need to be explicitly\nmarked.\n\n## Example\n\nThe following code produces this diagnostic because the static field `c`\nhas the modifier `late` even though it has an initializer:\n\n```dart\nclass C {\n  static [!late!] String c = '';\n}\n```\n\n## Common fixes\n\nRemove the keyword `late`:\n\n```dart\nclass C {\n  static String c = '';\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_library_directive",
    "description": "_Library directives without comments or annotations should be avoided._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_library_name",
    "description": "_Library names are not necessary._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `library` directive specifies\na name.\n\n## Example\n\nThe following code produces this diagnostic because the `library`\ndirective includes a name:\n\n```dart\nlibrary [!some.name!];\n\nclass C {}\n```\n\n## Common fixes\n\nRemove the name from the `library` directive:\n\n```dart\nlibrary;\n\nclass C {}\n```\n\nIf the library has any parts, then any `part of` declarations that use\nthe library name should be updated to use the URI of the library instead.\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_new",
    "description": "_Unnecessary 'new' keyword._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the keyword `new` is used to\ninvoke a constructor.\n\n## Example\n\nThe following code produces this diagnostic because the keyword `new` is\nused to invoke the unnamed constructor from `Object`:\n\n```dart\nvar o = [!new!] Object();\n```\n\n## Common fixes\n\nRemove the keyword `new`:\n\n```dart\nvar o = Object();\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_null_aware_assignments",
    "description": "_Unnecessary assignment of 'null'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the right-hand side of a\nnull-aware assignment is the `null` literal.\n\n## Example\n\nThe following code produces this diagnostic because the null aware\noperator is being used to assign `null` to `s` when `s` is already `null`:\n\n```dart\nvoid f(String? s) {\n  [!s ??= null!];\n}\n```\n\n## Common fixes\n\nIf a non-null value should be assigned to the left-hand operand, then\nchange the right-hand side:\n\n```dart\nvoid f(String? s) {\n  s ??= '';\n}\n```\n\nIf there is no non-null value to assign to the left-hand operand, then\nremove the assignment:\n\n```dart\nvoid f(String? s) {\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_null_aware_operator_on_extension_on_nullable",
    "description": "_Unnecessary use of a null-aware operator to invoke an extension method on a nullable type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a null-aware operator is used\nto invoke an extension method on an extension whose type is nullable.\n\n## Example\n\nThe following code produces this diagnostic because the extension method\n`m` is invoked using `?.` when it doesn't need to be:\n\n```dart\nextension E on int? {\n  int m() => 1;\n}\n\nint? f(int? i) => i[!?.!]m();\n```\n\n## Common fixes\n\nIf it isn't a requirement not invoke the method when the receiver is\n`null`, then remove the question mark from the invocation:\n\n```dart\nextension E on int? {\n  int m() => 1;\n}\n\nint? f(int? i) => i.m();\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_null_checks",
    "description": "_Unnecessary use of a null check ('!')._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a null check operator (`!`) is\nused in a context where a nullable value is acceptable.\n\n## Example\n\nThe following code produces this diagnostic because a null check is being\nused even though `null` is a valid value to return:\n\n```dart\nint? f(int? i) {\n  return i[!!!];\n}\n```\n\n## Common fixes\n\nRemove the null check operator:\n\n```dart\nint? f(int? i) {\n  return i;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_null_in_if_null_operators",
    "description": "_Unnecessary use of '??' with 'null'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the right operand of the `??`\noperator is the literal `null`.\n\n## Example\n\nThe following code produces this diagnostic because the right-hand operand\nof the `??` operator is `null`:\n\n```dart\nString? f(String? s) => s ?? [!null!];\n```\n\n## Common fixes\n\nIf a non-null value should be used for the right-hand operand, then\nchange the right-hand side:\n\n```dart\nString f(String? s) => s ?? '';\n```\n\nIf there is no non-null value to use for the right-hand operand, then\nremove the operator and the right-hand operand:\n\n```dart\nString? f(String? s) => s;\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_nullable_for_final_variable_declarations",
    "description": "_Type could be non-nullable._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a final field or variable has a\nnullable type but is initialized to a non-nullable value.\n\n## Example\n\nThe following code produces this diagnostic because the final variable `i`\nhas a nullable type (`int?`), but can never be `null`:\n\n```dart\nfinal int? [!i!] = 1;\n```\n\n## Common fixes\n\nMake the type non-nullable:\n\n```dart\nfinal int i = 1;\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_overrides",
    "description": "_Unnecessary override._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an instance member overrides an\ninherited member but only invokes the overridden member with exactly the\nsame arguments.\n\n## Example\n\nThe following code produces this diagnostic because the method `D.m`\ndoesn't do anything other than invoke the overridden method:\n\n```dart\nclass C {\n  int m(int x) => x;\n}\n\nclass D extends C {\n  @override\n  int [!m!](int x) => super.m(x);\n}\n```\n\n## Common fixes\n\nIf the method should do something more than what the overridden method\ndoes, then implement the missing functionality:\n\n```dart\nclass C {\n  int m(int x) => x;\n}\n\nclass D extends C {\n  @override\n  int m(int x) => super.m(x) + 1;\n}\n```\n\nIf the overridden method should be modified by changing the return type or\none or more of the parameter types, making one of the parameters\n`covariant`, having a documentation comment, or by having additional\nannotations, then update the code:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass C {\n  int m(int x) => x;\n}\n\nclass D extends C {\n  @mustCallSuper\n  @override\n  int m(int x) => super.m(x);\n}\n```\n\nIf the overriding method doesn't change or enhance the semantics of the\ncode, then remove it:\n\n```dart\nclass C {\n  int m(int x) => x;\n}\n\nclass D extends C {}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_parenthesis",
    "description": "_Unnecessary use of parentheses._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when parentheses are used where they\ndo not affect the semantics of the code.\n\n## Example\n\nThe following code produces this diagnostic because the parentheses around\nthe binary expression are not necessary:\n\n```dart\nint f(int a, int b) => [!(a + b)!];\n```\n\n## Common fixes\n\nRemove the unnecessary parentheses:\n\n```dart\nint f(int a, int b) => a + b;\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_raw_strings",
    "description": "_Unnecessary use of a raw string._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a string literal is marked as\nbeing raw (is prefixed with an `r`), but making the string raw doesn't\nchange the value of the string.\n\n## Example\n\nThe following code produces this diagnostic because the string literal\nwill have the same value without the `r` as it does with the `r`:\n\n```dart\nvar s = [!r'abc'!];\n```\n\n## Common fixes\n\nRemove the `r` in front of the string literal:\n\n```dart\nvar s = 'abc';\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_statements",
    "description": "_Unnecessary statement._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an expression statement has no\nclear effect.\n\n## Example\n\nThe following code produces this diagnostic because the addition of the\nreturned values from the two invocations has no clear effect:\n\n```dart\nvoid f(int Function() first, int Function() second) {\n  [!first() + second()!];\n}\n```\n\n## Common fixes\n\nIf the expression doesn't need to be computed, then remove it:\n\n```dart\nvoid f(int Function() first, int Function() second) {\n}\n```\n\nIf the value of the expression is needed, then make use of it, possibly\nassigning it to a local variable first:\n\n```dart\nvoid f(int Function() first, int Function() second) {\n  print(first() + second());\n}\n```\n\nIf portions of the expression need to be executed, then remove the\nunnecessary portions:\n\n```dart\nvoid f(int Function() first, int Function() second) {\n  first();\n  second();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_string_escapes",
    "description": "_Unnecessary escape in string literal._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when characters in a string are\nescaped when escaping them is unnecessary.\n\n## Example\n\nThe following code produces this diagnostic because single quotes don't\nneed to be escaped inside strings delimited by double quotes:\n\n```dart\nvar s = \"Don[!\\!]'t use a backslash here.\";\n```\n\n## Common fixes\n\nRemove the unnecessary backslashes:\n\n```dart\nvar s = \"Don't use a backslash here.\";\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_string_interpolations",
    "description": "_Unnecessary use of string interpolation._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a string literal contains a\nsingle interpolation of a `String`-valued variable and no other\ncharacters.\n\n## Example\n\nThe following code produces this diagnostic because the string literal\ncontains a single interpolation and doesn't contain any character outside\nthe interpolation:\n\n```dart\nString f(String s) => [!'$s'!];\n```\n\n## Common fixes\n\nReplace the string literal with the content of the interpolation:\n\n```dart\nString f(String s) => s;\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_this",
    "description": "_Unnecessary 'this.' qualifier._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the keyword `this` is used to\naccess a member that isn't shadowed.\n\n## Example\n\nThe following code produces this diagnostic because the use of `this` to\naccess the field `_f` isn't necessary:\n\n```dart\nclass C {\n  int _f = 2;\n\n  int get f => [!this!]._f;\n}\n```\n\n## Common fixes\n\nRemove the `this.`:\n\n```dart\nclass C {\n  int _f = 2;\n\n  int get f => _f;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_to_list_in_spreads",
    "description": "_Unnecessary use of 'toList' in a spread._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when `toList` is used to convert an\n`Iterable` to a `List` just before a spread operator is applied to the\nlist. The spread operator can be applied to any `Iterable`, so the\nconversion isn't necessary.\n\n## Example\n\nThe following code produces this diagnostic because `toList` is invoked on\nthe result of `map`, which is an `Iterable` that the spread operator could\nbe applied to directly:\n\n```dart\nList<String> toLowercase(List<String> strings) {\n  return [\n    ...strings.map((String s) => s.toLowerCase()).[!toList!](),\n  ];\n}\n```\n\n## Common fixes\n\nRemove the invocation of `toList`:\n\n```dart\nList<String> toLowercase(List<String> strings) {\n  return [\n    ...strings.map((String s) => s.toLowerCase()),\n  ];\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_unawaited",
    "description": "_Unnecessary use of 'unawaited'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when `unawaited` is used to mark a\ncall to a function, method, or operator, or a reference to a field,\ngetter, or top-level variable as safely not being awaited, but the called\nmember is also annotated with `@awaitNotRequired`. This annotation itself\nsignals that wrapping with `unawaited` is unnecessary at any call site.\n\n## Example\n\nThe following code produces this diagnostic because `unawaited` is invoked\non a call to a function that's annotated with `@awaitNotRequired`:\n\n```dart\nimport 'dart:async';\nimport 'package:meta/meta.dart';\n\n@awaitNotRequired\nFuture<bool> log(String message) async => true;\n\nvoid f() {\n  [!unawaited!](log('Message.'));\n}\n```\n\n## Common fixes\n\nRemove the invocation of `unawaited`:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@awaitNotRequired\nFuture<bool> log(String message) async => true;\n\nvoid f() {\n  log('Message.');\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unnecessary_underscores",
    "description": "_Unnecessary use of multiple underscores._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an unused variable is named\nwith multiple underscores (for example `__`). A single `_` wildcard variable\ncan be used instead.\n\n## Example\n\nThe following code produces this diagnostic because the `__` parameter is unused:\n\n```dart\nvoid function(int [!__!]) { }\n```\n\n## Common fixes\n\nReplace the name with a single underscore:\n\n```dart\nvoid function(int _) { }\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unreachable_from_main",
    "description": "_Unreachable member '{0}' in an executable library._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unrelated_type_equality_checks",
    "description": "_The type of the operand ('{0}') isn't a subtype or a supertype of the value being matched ('{1}')._\n\n_The type of the right operand ('{0}') isn't a subtype or a supertype of the left operand ('{1}')._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when two objects are being compared\nand neither of the static types of the two objects is a subtype of the\nother.\n\nSuch a comparison will usually return `false` and might not reflect the\nprogrammer's intent.\n\nThere can be false positives. For example, a class named `Point` might\nhave subclasses named `CartesianPoint` and `PolarPoint`, neither of which\nis a subtype of the other, but it might still be appropriate to test the\nequality of instances.\n\nAs a concrete case, the classes `Int64` and `Int32` from `package:fixnum`\nallow comparing instances to an `int` provided the `int` is on the\nright-hand side. This case is specifically allowed by the diagnostic, but\nother such cases are not.\n\n## Example\n\nThe following code produces this diagnostic because the string `s` is\nbeing compared to the integer `1`:\n\n```dart\nbool f(String s) {\n  return s [!==!] 1;\n}\n```\n\n## Common fixes\n\nReplace one of the operands with something compatible with the other\noperand:\n\n```dart\nbool f(String s) {\n  return s.length == 1;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unsafe_html",
    "description": "_Assigning to the attribute '{0}' is unsafe._\n\n_Invoking the constructor '{0}' is unsafe._\n\n_Invoking the method '{0}' is unsafe._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unsafe_variance",
    "description": "_This type is unsafe: a type parameter occurs in a non-covariant position._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when an instance member has a result\ntype which is [contravariant or invariant](https://dart.dev/resources/glossary#variance)\nin a type parameter of the enclosing declaration. The result type of a\nvariable is its type, and the result type of a getter or method is its\nreturn type. This lint warns against such members because they are likely\nto cause a failing type check at run time, with no static warning or error\nat the call site.\n\n## Example\n\nThe following code produces this diagnostic because `X` occurs\nas a parameter type in the type of `f`, which is a\ncontravariant occurrence of this type parameter:\n\n```dart\nclass C<X> {\n  bool Function([!X!]) f;\n  C(this.f);\n}\n```\n\nThis is unsafe: If `c` has static type `C<num>` and run-time type `C<int>`\nthen `c.f` will throw. Hence, every invocation `c.f(a)` will also throw,\neven in the case where `a` has a correct type as an argument to `c.f`.\n\n## Common fixes\n\nIf the linted member is or can be private then you may be able\nto enforce that it is never accessed on any other receiver than `this`.\nThis is sufficient to ensure that that the run-time type error does not\noccur. For example:\n\n```dart\nclass C<X> {\n  // NB: Ensure manually that `_f` is only accessed on `this`.\n  // ignore: unsafe_variance\n  bool Function(X) _f;\n\n  C(this._f);\n\n  // We can write a forwarding method to allow clients to call `_f`.\n  bool f(X x) => _f(x);\n}\n```\n\nYou can eliminate the unsafe variance by using a more general type for\nthe linted member. In this case you may need to check the run-time type\nand perform a downcast at call sites.\n\n```dart\nclass C<X> {\n  bool Function(Never) f;\n  C(this.f);\n}\n```\n\nIf `c` has static type `C<num>` then you may test the type. For example,\n`c.f is bool Function(num)`. You may safely call it with an argument of\ntype `num` if it has that type.\n\nYou can also eliminate the unsafe variance by using a much more general\ntype like `Function`, which is essentially the type `dynamic` for\nfunctions.\n\n```dart\nclass C<X> {\n  Function f;\n  C(this.f);\n}\n```\n\nThis will make `c.f(a)` dynamically safe: It will throw if and only if the\nargument `a` does not have the type required by the function. This is\nbetter than the original version because it will not throw because of a\nmismatched static type. It only throws when it _must_ throw for soundness\nreasons.\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "unsupported_key",
    "description": "_The key '{0}' isn't supported._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unsupported_static",
    "description": "_The key 'static' is only supported for elements in a class, enum, extension, or mixin._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "unsupported_version",
    "description": "_Only version '1' is supported at this time._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "use_build_context_synchronously",
    "description": "_Don't use 'BuildContext's across async gaps, guarded by an unrelated 'mounted' check._\n\n_Don't use 'BuildContext's across async gaps._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `BuildContext` is referenced\nby a `StatefulWidget` after an asynchronous gap without first checking the\n`mounted` property.\n\nStoring a `BuildContext` for later use can lead to difficult-to-diagnose\ncrashes. Asynchronous gaps implicitly store a `BuildContext`, making them\neasy to overlook for diagnosis.\n\n## Example\n\nThe following code produces this diagnostic because the `context` is\npassed to a constructor after the `await`:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass MyWidget extends Widget {\n  void onButtonTapped(BuildContext context) async {\n    await Future.delayed(const Duration(seconds: 1));\n    Navigator.of([!context!]).pop();\n  }\n}\n```\n\n## Common fixes\n\nIf you can remove the asynchronous gap, do so:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass MyWidget extends Widget {\n  void onButtonTapped(BuildContext context) {\n    Navigator.of(context).pop();\n  }\n}\n```\n\nIf you can't remove the asynchronous gap, then use `mounted` to guard the\nuse of the `context`:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass MyWidget extends Widget {\n  void onButtonTapped(BuildContext context) async {\n    await Future.delayed(const Duration(seconds: 1));\n    if (context.mounted) {\n      Navigator.of(context).pop();\n    }\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "use_colored_box",
    "description": "_Use a 'ColoredBox' rather than a 'Container' with only a 'Color'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `Container` is created that\nonly sets the color.\n\n## Example\n\nThe following code produces this diagnostic because the only attribute of\nthe container that is set is the `color`:\n\n```dart\nimport 'package:flutter/material.dart';\n\nWidget build() {\n  return [!Container!](\n    color: Colors.red,\n    child: const Text('hello'),\n  );\n}\n```\n\n## Common fixes\n\nReplace the `Container` with a `ColoredBox`:\n\n```dart\nimport 'package:flutter/material.dart';\n\nWidget build() {\n  return ColoredBox(\n    color: Colors.red,\n    child: const Text('hello'),\n  );\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "use_decorated_box",
    "description": "_Use 'DecoratedBox' rather than a 'Container' with only a 'Decoration'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `Container` is created that\nonly sets the decoration.\n\n## Example\n\nThe following code produces this diagnostic because the only attribute of\nthe container that is set is the `decoration`:\n\n```dart\nimport 'package:flutter/material.dart';\n\nWidget buildArea() {\n  return [!Container!](\n    decoration: const BoxDecoration(\n      color: Colors.red,\n      borderRadius: BorderRadius.all(\n        Radius.circular(5),\n      ),\n    ),\n    child: const Text('...'),\n  );\n}\n```\n\n## Common fixes\n\nReplace the `Container` with a `DecoratedBox`:\n\n```dart\nimport 'package:flutter/material.dart';\n\nWidget buildArea() {\n  return DecoratedBox(\n    decoration: const BoxDecoration(\n      color: Colors.red,\n      borderRadius: BorderRadius.all(\n        Radius.circular(5),\n      ),\n    ),\n    child: const Text('...'),\n  );\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "use_enums",
    "description": "_Class should be an enum._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "use_full_hex_values_for_flutter_colors",
    "description": "_Instances of 'Color' should be created using an 8-digit hexadecimal integer (such as '0xFFFFFFFF')._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the argument to the constructor\nof the `Color` class is a literal integer that isn't represented as an\n8-digit hexadecimal integer.\n\n## Example\n\nThe following code produces this diagnostic because the argument (`1`)\nisn't represented as an 8-digit hexadecimal integer:\n\n```dart\nimport 'package:flutter/material.dart';\n\nColor c = Color([!1!]);\n```\n\n## Common fixes\n\nConvert the representation to be an 8-digit hexadecimal integer:\n\n```dart\nimport 'package:flutter/material.dart';\n\nColor c = Color(0x00000001);\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "use_function_type_syntax_for_parameters",
    "description": "_Use the generic function type syntax to declare the parameter '{0}'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the older style function-valued\nparameter syntax is used.\n\n## Example\n\nThe following code produces this diagnostic because the function-valued\nparameter `f` is declared using an older style syntax:\n\n```dart\nvoid g([!bool f(String s)!]) {}\n```\n\n## Common fixes\n\nUse the generic function type syntax to declare the parameter:\n\n```dart\nvoid g(bool Function(String) f) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "use_if_null_to_convert_nulls_to_bools",
    "description": "_Use an if-null operator to convert a 'null' to a 'bool'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a nullable `bool`-valued\nexpression is compared (using `==` or `!=`) to a boolean literal.\n\n## Example\n\nThe following code produces this diagnostic because the nullable boolean\nvariable `b` is compared to `true`:\n\n```dart\nvoid f(bool? b) {\n  if ([!b == true!]) {\n    // Treats `null` as `false`.\n  }\n}\n```\n\n## Common fixes\n\nRewrite the condition to use `??` instead:\n\n```dart\nvoid f(bool? b) {\n  if (b ?? false) {\n    // Treats `null` as `false`.\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "use_is_even_rather_than_modulo",
    "description": "_Use '{0}' rather than '% 2'._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "use_key_in_widget_constructors",
    "description": "_Constructors for public widgets should have a named 'key' parameter._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constructor in a subclass of\n`Widget` that isn't private to its library doesn't have a parameter named\n`key`.\n\n## Example\n\nThe following code produces this diagnostic because the constructor for\nthe class `MyWidget` doesn't have a parameter named `key`:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass MyWidget extends StatelessWidget {\n  [!MyWidget!]({required int height});\n}\n```\n\nThe following code produces this diagnostic because the default\nconstructor for the class `MyWidget` doesn't have a parameter named `key`:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass [!MyWidget!] extends StatelessWidget {}\n```\n\n## Common fixes\n\nAdd a parameter named `key` to the constructor, explicitly declaring the\nconstructor if necessary:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass MyWidget extends StatelessWidget {\n  MyWidget({super.key, required int height});\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "use_late_for_private_fields_and_variables",
    "description": "_Use 'late' for private members with a non-nullable type._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a private field or variable is\nmarked as being nullable, but every reference assumes that the variable is\nnever `null`.\n\n## Example\n\nThe following code produces this diagnostic because the private top-level\nvariable `_i` is nullable, but every reference assumes that it will not be\n`null`:\n\n```dart\nvoid f() {\n  _i!.abs();\n}\n\nint? [!_i!];\n```\n\n## Common fixes\n\nMark the variable or field as being both non-nullable and `late` to\nindicate that it will always be assigned a non-null:\n\n```dart\nvoid f() {\n  _i.abs();\n}\n\nlate int _i;\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "use_named_constants",
    "description": "_Use the constant '{0}' rather than a constructor returning the same object._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a constant is created with the\nsame value as a known `const` variable.\n\n## Example\n\nThe following code produces this diagnostic because there is a known\n`const` field (`Duration.zero`) whose value is the same as what the\nconstructor invocation will evaluate to:\n\n```dart\nDuration d = [!const Duration(seconds: 0)!];\n```\n\n## Common fixes\n\nReplace the constructor invocation with a reference to the known `const`\nvariable:\n\n```dart\nDuration d = Duration.zero;\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "use_null_aware_elements",
    "description": "_Use the null-aware marker '?' rather than a null check via an 'if'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a null check is used instead\nof a null-aware marker inside of a collection literal.\n\n## Example\n\nThe following code produces this diagnostic because a null check is used\nto decide whether `x` should be inserted into the list, while the\nnull-aware marker '?' would be less brittle and less verbose.\n\n```dart\nf(int? x) => [[!if!] (x != null) x];\n```\n\n## Common fixes\n\nReplace the null-check with the null-aware marker '?':\n\n```dart\nf(int? x) => [?x];\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "use_raw_strings",
    "description": "_Use a raw string to avoid using escapes._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a string literal containing\nescapes, and no interpolations, could be marked as being raw in order to\navoid the need for the escapes.\n\n## Example\n\nThe following code produces this diagnostic because the string contains\nescaped characters that wouldn't need to be escaped if the string is\nmade a raw string:\n\n```dart\nvar s = [!'A string with only \\\\ and \\$'!];\n```\n\n## Common fixes\n\nMark the string as being raw and remove the unnecessary backslashes:\n\n```dart\nvar s = r'A string with only \\ and $';\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "use_rethrow_when_possible",
    "description": "_Use 'rethrow' to rethrow a caught exception._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a caught exception is thrown\nusing a `throw` expression rather than a `rethrow` statement.\n\n## Example\n\nThe following code produces this diagnostic because the caught exception\n`e` is thrown using a `throw` expression:\n\n```dart\nvoid f() {\n  try {\n    // ...\n  } catch (e) {\n    [!throw e!];\n  }\n}\n```\n\n## Common fixes\n\nUse `rethrow` instead of `throw`:\n\n```dart\nvoid f() {\n  try {\n    // ...\n  } catch (e) {\n    rethrow;\n  }\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "use_setters_to_change_properties",
    "description": "_The method is used to change a property._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a method is used to set the\nvalue of a field, or a function is used to set the value of a top-level\nvariable, and nothing else.\n\n## Example\n\nThe following code produces this diagnostic because the method `setF` is\nused to set the value of the field `_f` and does no other work:\n\n```dart\nclass C {\n  int _f = 0;\n\n  void [!setF!](int value) => _f = value;\n}\n```\n\n## Common fixes\n\nConvert the method to a setter:\n\n```dart\nclass C {\n  int _f = 0;\n\n  set f(int value) => _f = value;\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "use_string_buffers",
    "description": "_Use a string buffer rather than '+' to compose strings._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when values are concatenated to a\nstring inside a loop without using a `StringBuffer` to do the\nconcatenation.\n\n## Example\n\nThe following code produces this diagnostic because the string `result` is\ncomputed by repeated concatenation within the `for` loop:\n\n```dart\nString f() {\n  var result = '';\n  for (int i = 0; i < 10; i++) {\n    [!result += 'a'!];\n  }\n  return result;\n}\n```\n\n## Common fixes\n\nUse a `StringBuffer` to compute the result:\n\n```dart\nString f() {\n  var buffer = StringBuffer();\n  for (int i = 0; i < 10; i++) {\n    buffer.write('a');\n  }\n  return buffer.toString();\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "use_string_in_part_of_directives",
    "description": "_The part-of directive uses a library name._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a `part of` directive uses a\nlibrary name to refer to the library that the part is a part of.\n\n## Example\n\nGiven a file named `lib.dart` that contains the following:\n\n```dart\nlibrary lib;\n\npart 'test.dart';\n```\n\nThe following code produces this diagnostic because the `part of`\ndirective uses the name of the library rather than the URI of the library\nit's part of:\n\n```dart\n[!part of lib;!]\n```\n\n## Common fixes\n\nUse a URI to reference the library:\n\n```dart\npart of 'lib.dart';\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "use_super_parameters",
    "description": "_Parameter '{0}' could be a super parameter._\n\n_Parameters '{0}' could be super parameters._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a parameter to a constructor is\npassed to a super constructor without being referenced or modified and a\n`super` parameter isn't used.\n\n## Example\n\nThe following code produces this diagnostic because the parameters of the\nconstructor for `B` are only used as arguments to the super constructor:\n\n```dart\nclass A {\n  A({int? x, int? y});\n}\nclass B extends A {\n  [!B!]({int? x, int? y}) : super(x: x, y: y);\n}\n```\n\n## Common fixes\n\nUse a `super` parameter to pass the arguments:\n\n```dart\nclass A {\n  A({int? x, int? y});\n}\nclass B extends A {\n  B({super.x, super.y});\n}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "use_test_throws_matchers",
    "description": "_Use the 'throwsA' matcher instead of using 'fail' when there is no exception thrown._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "use_to_and_as_if_applicable",
    "description": "_Start the name of the method with 'to' or 'as'._",
    "hasDocumentation": false,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "use_truncating_division",
    "description": "_Use truncating division._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the result of dividing two\nnumbers is converted to an integer using `toInt`.\n\nDart has a built-in integer division operator that is both more efficient\nand more concise.\n\n## Example\n\nThe following code produces this diagnostic because the result of dividing\n`x` and `y` is converted to an integer using `toInt`:\n\n```dart\nint divide(int x, int y) => [!(x / y).toInt()!];\n```\n\n## Common fixes\n\nUse the integer division operator (`~/`):\n\n```dart\nint divide(int x, int y) => x ~/ y;\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "valid_regexps",
    "description": "_Invalid regular expression syntax._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when the string passed to the\ndefault constructor of the class `RegExp` doesn't contain a valid regular\nexpression.\n\nA regular expression created with invalid syntax will throw a\n`FormatException` at runtime.\n\n## Example\n\nThe following code produces this diagnostic because the regular expression\nisn't valid:\n\n```dart\nvar r = RegExp([!r'('!]);\n```\n\n## Common fixes\n\nFix the regular expression:\n\n```dart\nvar r = RegExp(r'\\(');\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "visit_registered_nodes",
    "description": "_Declare 'visit' methods for all registered node types._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "void_checks",
    "description": "_Assignment to a variable of type 'void'._",
    "documentation": "## Description\n\nThe analyzer produces this diagnostic when a value is assigned to a\nvariable of type `void`.\n\nIt isn't possible to access the value of such a variable, so the\nassignment has no value.\n\n## Example\n\nThe following code produces this diagnostic because the field `value` has\nthe type `void`, but a value is being assigned to it:\n\n```dart\nclass A<T> {\n  T? value;\n}\n\nvoid f(A<void> a) {\n  [!a.value = 1!];\n}\n```\n\nThe following code produces this diagnostic because the type of the\nparameter `p` in the method `m` is `void`, but a value is being assigned\nto it in the invocation:\n\n```dart\nclass A<T> {\n  void m(T p) { }\n}\n\nvoid f(A<void> a) {\n  a.m([!1!]);\n}\n```\n\n## Common fixes\n\nIf the type of the variable is incorrect, then change the type of the\nvariable:\n\n```dart\nclass A<T> {\n  T? value;\n}\n\nvoid f(A<int> a) {\n  a.value = 1;\n}\n```\n\nIf the type of the variable is correct, then remove the assignment:\n\n```dart\nclass A<T> {\n  T? value;\n}\n\nvoid f(A<void> a) {}\n```\n",
    "hasDocumentation": true,
    "fromLint": true,
    "previousNames": []
  },
  {
    "id": "wrong_token",
    "description": "_Expected to find {0}, but found {1}._",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  },
  {
    "id": "yaml_syntax_error",
    "description": "_Parse error: {0}_",
    "hasDocumentation": false,
    "fromLint": false,
    "previousNames": []
  }
]