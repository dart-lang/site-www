{%- comment %}
WARNING: Do NOT EDIT this file directly. It is autogenerated by
  tool/create_code_with_tooltips.dart
from sources in the example folder.
{% endcomment -%}
<pre class="prettyprint lang-dart">
<code><a tabindex="0" role="button" data-toggle="popover" data-content="Dart has one canonical way to import libraries, and one canonical (and easy) way to install library packages.">import</a> '<a tabindex="0" role="button" data-toggle="popover" data-content="The whole standard library is meticulously maintained. It has been called “well-crafted” by none other than Erik Meijer.">dart:math</a>' show Random;

void <a tabindex="0" role="button" data-toggle="popover" data-content="The <code>main()</code> function is the single point of entry.">main()</a> async {
  print('Compute <a tabindex="0" role="button" data-toggle="popover" data-content="Unicode support is baked in.">π</a> using the Monte Carlo method.');
  <a tabindex="0" role="button" data-toggle="popover" data-content="Language-level asynchrony support makes you more productive when dealing with deeply asynchronous code (like most UI code, for example).">await</a> for (final estimate in computePi().take(500)) {
    print('π ≅ <a tabindex="0" role="button" data-toggle="popover" data-content="String interpolation is easy. Just put <code>${expression}</code> or <code>$variable</code> in your string literal.">$estimate</a>');
  }
}

<a tabindex="0" role="button" data-toggle="popover" data-content="Add doc comments like this to flesh out the API reference docs that the SDK’s dart doc tool generates.">///</a> Generates a stream of increasingly accurate estimates of π.
Stream<a tabindex="0" role="button" data-toggle="popover" data-content="Generics are optional but extremely useful in large codebases.">&lt;double&gt;</a> computePi(<a tabindex="0" role="button" data-toggle="popover" data-content="Named parameters make call sites more readable.">{int batch = 100000}</a>) <a tabindex="0" role="button" data-toggle="popover" data-content="Dart has language-level support for asynchronous generators.">async*</a> {
  <a tabindex="0" role="button" data-toggle="popover" data-content="The type is inferred in this variable declaration. Note: no JavaScript-style hoisting.">var</a> total = 0;
  var count = 0;
  <a tabindex="0" role="button" data-toggle="popover" data-content="Because generators are lazy, we can safely do this.">while (true)</a> {
    var points = generateRandom().<a tabindex="0" role="button" data-toggle="popover" data-content="Synchronous generators produce (lazy) Iterables, and Iterables have a well-crafted API.">take</a>(batch);
    var inside = points.where((p) <a tabindex="0" role="button" data-toggle="popover" data-content="The optional arrow syntax makes simple functions more readable.">=&gt;</a> p.isInsideUnitCircle);
    total += batch;
    count += inside.<a tabindex="0" role="button" data-toggle="popover" data-content="Since the <code>Iterable</code> is lazy, the program doesn’t actually iterate over it until it’s needed by the length getter. No new array will be constructed.">length</a>;
    var ratio = count / total;
    // Area of a circle is A = π⋅r², therefore π = A/r².
    // So, when given random points with x ∈ &lt;0,1&gt;,
    // y ∈ &lt;0,1&gt;, the ratio of those inside a unit circle
    // should approach π / 4. Therefore, the value of π
    // should be:
    <a tabindex="0" role="button" data-toggle="popover" data-content="In an <code>async</code> generator, yield takes care of sending the values through the stream (including the logic of suspending execution when needed).">yield</a> ratio * 4;
  }
}

<a tabindex="0" role="button" data-toggle="popover" data-content="<code>Iterable</code> is a core type extended by all iterable collections, which makes for some elegant Dart code.">Iterable</a>&lt;Point&gt; generateRandom(<a tabindex="0" role="button" data-toggle="popover" data-content="Optional parameters make call sites cleaner.">[int? seed]</a>) <a tabindex="0" role="button" data-toggle="popover" data-content="Dart has language-level support for synchronous generators, too.">sync*</a> {
  <a tabindex="0" role="button" data-toggle="popover" data-content="Variables and fields can be final. Any attempt to change them later in the code will produce a static error.">final</a> random = Random(seed);
  while (true) {
    <a tabindex="0" role="button" data-toggle="popover" data-content="Producing lazy Iterables through yield is readable and corresponds nicely with the same concept in asynchronous generators.">yield</a> Point(random.nextDouble(), random.nextDouble());
  }
}

<a tabindex="0" role="button" data-toggle="popover" data-content="Dart is purely object-oriented and class-based, with mixin-based inheritance.">class</a> Point {
  final <a tabindex="0" role="button" data-toggle="popover" data-content="Although Dart can compile to JavaScript, it doesn’t lack the distinction between <code>double</code> and <code>int</code>.">double</a> x, y;
  <a tabindex="0" role="button" data-toggle="popover" data-content="Constructors can be constant.">const</a> Point(<a tabindex="0" role="button" data-toggle="popover" data-content="Initializing fields through this shorthand syntax is both easier and more readable.">this.x</a>, this.y);
  bool <a tabindex="0" role="button" data-toggle="popover" data-content="Language-level support for getters means you can freely switch between properties and methods without changing the API.">get</a> isInsideUnitCircle =&gt; x * x + y * y &lt;= 1;
}</code>
</pre>
