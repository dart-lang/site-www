{%- comment %}
WARNING: Do NOT EDIT this file directly. It is autogenerated by
  scripts/create_site_main_example.dart
from sources in the example folder.
{% endcomment -%}
<pre class="prettyprint">
<span class="frontpage-highlight" data-text="Dart has one canonical way to import libraries, and one canonical (and easy) way to install library packages.">import</span> 'dart:async';
import '<span class="frontpage-highlight" data-text="The whole standard library is meticulously maintained. It has been called “well-crafted” by none other than Erik Meijer.">dart:math</span>' show Random;


main() async {
 
  print('Compute <span class="frontpage-highlight" data-text="Unicode support is baked in.">π</span> using the Monte Carlo method.');
  await for (var estimate in computePi().take(500)) {
   
    print('π ≅ <span class="frontpage-highlight" data-text="String interpolation is easy. Just put ${expression} or $variable in your string literal.">$estimate</span>');
  }
}

<span class="frontpage-highlight" data-text="Add doc comments like this to flesh out the API reference docs that the SDK’s dartdoc tool generates.">///</span> Generates a stream of increasingly accurate estimates of π.
Stream&lt;double&gt; computePi({int batch: 100000}) async* {
 
  <span class="frontpage-highlight" data-text="The type is inferred in this variable declaration. Note: no JavaScript-style hoisting.">var</span> total = 0;
  var count = 0;
  while (true) {
   
    var points = generateRandom().<span class="frontpage-highlight" data-text="Synchronous generators produce (lazy) Iterables, and Iterables have a well-crafted API.">take</span>(batch);
    var inside = points.where((p) <span class="frontpage-highlight" data-text="The optional arrow syntax makes simple functions more readable.">=&gt;</span> p.isInsideUnitCircle);
    total += batch;
    count += inside.<span class="frontpage-highlight" data-text="Since the Iterable is lazy, the program doesn’t actually iterate over it until it’s needed by the length getter. No new array will be constructed.">length</span>;
    var ratio = count / total;
    // Area of a circle is A = π⋅r², therefore π = A/r².
    // So, when given random points with x ∈ &lt;0,1&gt;,
    // y ∈ &lt;0,1&gt;, the ratio of those inside a unit circle
    // should approach π / 4. Therefore, the value of π
    // should be:
    <span class="frontpage-highlight" data-text="In an async generator, yield takes care of sending the values through the stream (including the logic of suspending execution when needed).">yield</span> ratio * 4;
  }
}

Iterable&lt;Point&gt; generateRandom([int seed]) sync* {
 
  <span class="frontpage-highlight" data-text="Variables and fields can be final. Any attempt to change them later in the code will produce a static error.">final</span> random = new Random(seed);
  while (true) {
    <span class="frontpage-highlight" data-text="Producing lazy Iterables through yield is readable and corresponds nicely with the same concept in asynchronous generators.">yield</span> new Point(random.nextDouble(), random.nextDouble());
  }
}

class Point {
 
  final <span class="frontpage-highlight" data-text="Although Dart can compile to JavaScript, it doesn’t lack the distinction between double and int.">double</span> x, y;
  <span class="frontpage-highlight" data-text="Constructors can be constant.">const</span> Point(<span class="frontpage-highlight" data-text="Initializing fields through this shorthand syntax is both easier and more readable.">this.x</span>, this.y);
  bool <span class="frontpage-highlight" data-text="Language-level support for getters means you can freely switch between properties and methods without changing the API.">get</span> isInsideUnitCircle =&gt; x * x + y * y &lt;= 1;
}</pre>
