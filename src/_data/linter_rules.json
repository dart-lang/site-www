[
  {
    "name": "always_use_package_imports",
    "description": "Avoid relative imports for files in `lib/`.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "*DO* avoid relative imports for files in `lib/`.\n\nWhen mixing relative and absolute imports it's possible to create confusion\nwhere the same member gets imported in two different ways. One way to avoid\nthat is to ensure you consistently use absolute imports for files withing the\n`lib/` directory.\n\nThis is the opposite of 'prefer_relative_imports'.\nMight be used with 'avoid_relative_lib_imports' to avoid relative imports of\nfiles within `lib/` directory outside of it. (for example `test/`)\n\n**GOOD:**\n\n```dart\nimport 'package:foo/bar.dart';\n\nimport 'package:foo/baz.dart';\n\nimport 'package:foo/src/baz.dart';\n...\n```\n\n**BAD:**\n\n```dart\nimport 'baz.dart';\n\nimport 'src/bag.dart'\n\nimport '../lib/baz.dart';\n\n...\n```\n\n"
  },
  {
    "name": "avoid_dynamic_calls",
    "description": "Avoid method calls or property accesses on a \"dynamic\" target.",
    "group": "errors",
    "maturity": "experimental",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** avoid method calls or accessing properties on an object that is either\nexplicitly or implicitly statically typed \"dynamic\". Dynamic calls are treated\nslightly different in every runtime environment and compiler, but most\nproduction modes (and even some development modes) have both compile size and\nruntime performance penalties associated with dynamic calls.\n\nAdditionally, targets typed \"dynamic\" disables most static analysis, meaning it\nis easier to lead to a runtime \"NoSuchMethodError\" or \"NullError\" than properly\nstatically typed Dart code.\n\nThere is an exception to methods and properties that exist on \"Object?\":\n- a.hashCode\n- a.runtimeType\n- a.noSuchMethod(someInvocation)\n- a.toString()\n\n... these members are dynamically dispatched in the web-based runtimes, but not\nin the VM-based ones. Additionally, they are so common that it would be very\npunishing to disallow `any.toString()` or `any == true`, for example.\n\nNote that despite \"Function\" being a type, the semantics are close to identical\nto \"dynamic\", and calls to an object that is typed \"Function\" will also trigger\nthis lint.\n\n**BAD:**\n```dart\nvoid explicitDynamicType(dynamic object) {\n  print(object.foo());\n}\n\nvoid implicitDynamicType(object) {\n  print(object.foo());\n}\n\nabstract class SomeWrapper {\n  T doSomething<T>();\n}\n\nvoid inferredDynamicType(SomeWrapper wrapper) {\n  var object = wrapper.doSomething();\n  print(object.foo());\n}\n\nvoid callDynamic(dynamic function) {\n  function();\n}\n\nvoid functionType(Function function) {\n  function();\n}\n```\n\n**GOOD:**\n```dart\nvoid explicitType(Fooable object) {\n  object.foo();\n}\n\nvoid castedType(dynamic object) {\n  (object as Fooable).foo();\n}\n\nabstract class SomeWrapper {\n  T doSomething<T>();\n}\n\nvoid inferredType(SomeWrapper wrapper) {\n  var object = wrapper.doSomething<Fooable>();\n  object.foo();\n}\n\nvoid functionTypeWithParameters(Function() function) {\n  function();\n}\n```\n\n"
  },
  {
    "name": "avoid_empty_else",
    "description": "Avoid empty else statements.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter"
    ],
    "details": "\n**AVOID** empty else statements.\n\n**BAD:**\n```dart\nif (x > y)\n  print(\"1\");\nelse ;\n  print(\"2\");\n```\n\n"
  },
  {
    "name": "avoid_print",
    "description": "Avoid `print` calls in production code.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "flutter"
    ],
    "details": "**DO** avoid `print` calls in production code.\n\n**BAD:**\n```dart\nvoid f(int x) {\n  print('debug: $x');\n  ...\n}\n```\n"
  },
  {
    "name": "avoid_relative_lib_imports",
    "description": "Avoid relative imports for files in `lib/`.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "*DO* avoid relative imports for files in `lib/`.\n\nWhen mixing relative and absolute imports it's possible to create confusion\nwhere the same member gets imported in two different ways.  An easy way to avoid\nthat is to ensure you have no relative imports that include `lib/` in their\npaths.\n\n**GOOD:**\n\n```dart\nimport 'package:foo/bar.dart';\n\nimport 'baz.dart';\n\n...\n```\n\n**BAD:**\n\n```dart\nimport 'package:foo/bar.dart';\n\nimport '../lib/baz.dart';\n\n...\n```\n\n"
  },
  {
    "name": "avoid_returning_null_for_future",
    "description": "Avoid returning null for Future.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**AVOID** returning null for Future.\n\nIt is almost always wrong to return `null` for a `Future`.  Most of the time the\ndeveloper simply forgot to put an `async` keyword on the function.\n\n"
  },
  {
    "name": "avoid_slow_async_io",
    "description": "Avoid slow async `dart:io` methods.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**AVOID** using the following asynchronous file I/O methods because they are\nmuch slower than their synchronous counterparts.\n\n* `Directory.exists`\n* `Directory.stat`\n* `File.lastModified`\n* `File.exists`\n* `File.stat`\n* `FileSystemEntity.isDirectory`\n* `FileSystemEntity.isFile`\n* `FileSystemEntity.isLink`\n* `FileSystemEntity.type`\n\n**BAD:**\n```dart\nimport 'dart:io';\n\nFuture<Null> someFunction() async {\n  var file = File('/path/to/my/file');\n  var now = DateTime.now();\n  if ((await file.lastModified()).isBefore(now)) print('before'); // LINT\n}\n```\n\n**GOOD:**\n```dart\nimport 'dart:io';\n\nFuture<Null> someFunction() async {\n  var file = File('/path/to/my/file');\n  var now = DateTime.now();\n  if (file.lastModifiedSync().isBefore(now)) print('before'); // OK\n}\n```\n\n"
  },
  {
    "name": "avoid_type_to_string",
    "description": "Avoid <Type>.toString() in production code since results may be minified.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** avoid calls to <Type>.toString() in production code, since it does not\ncontractually return the user-defined name of the Type (or underlying class).\nDevelopment-mode compilers where code size is not a concern use the full name,\nbut release-mode compilers often choose to minify these symbols.\n\n**BAD:**\n```dart\nvoid bar(Object other) {\n  if (other.runtimeType.toString() == 'Bar') {\n    doThing();\n  }\n}\n\nObject baz(Thing myThing) {\n  return getThingFromDatabase(key: myThing.runtimeType.toString());\n}\n```\n\n**GOOD:**\n```dart\nvoid bar(Object other) {\n  if (other is Bar) {\n    doThing();\n  }\n}\n\nclass Thing {\n  String get thingTypeKey => ...\n}\n\nObject baz(Thing myThing) {\n  return getThingFromDatabase(key: myThing.thingTypeKey);\n}\n```\n\n"
  },
  {
    "name": "avoid_types_as_parameter_names",
    "description": "Avoid types as parameter names.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter",
      "pedantic"
    ],
    "details": "\n**AVOID** using a parameter name that is the same as an existing type.\n\n**BAD:**\n```dart\nm(f(int));\n```\n\n**GOOD:**\n```dart\nm(f(int v));\n```\n\n"
  },
  {
    "name": "avoid_web_libraries_in_flutter",
    "description": "Avoid using web-only libraries outside Flutter web plugin packages.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "flutter"
    ],
    "details": "Avoid using web libraries, `dart:html`, `dart:js` and \n`dart:js_util` in Flutter packages that are not web plugins. These libraries are \nnot supported outside a web context; functionality that depends on them will\nfail at runtime in Flutter mobile, and their use is generally discouraged in\nFlutter web.\n\nWeb library access *is* allowed in:\n\n* plugin packages that declare `web` as a supported context\n\notherwise, imports of `dart:html`, `dart:js` and  `dart:js_util` are disallowed.\n"
  },
  {
    "name": "cancel_subscriptions",
    "description": "Cancel instances of dart.async.StreamSubscription.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** invoke `cancel` on instances of `dart.async.StreamSubscription`.\n\nCancelling instances of StreamSubscription prevents memory leaks and unexpected\nbehavior.\n\n**BAD:**\n```dart\nclass A {\n  StreamSubscription _subscriptionA; // LINT\n  void init(Stream stream) {\n    _subscriptionA = stream.listen((_) {});\n  }\n}\n```\n\n**BAD:**\n```dart\nvoid someFunction() {\n  StreamSubscription _subscriptionF; // LINT\n}\n```\n\n**GOOD:**\n```dart\nclass B {\n  StreamSubscription _subscriptionB; // OK\n  void init(Stream stream) {\n    _subscriptionB = stream.listen((_) {});\n  }\n\n  void dispose(filename) {\n    _subscriptionB.cancel();\n  }\n}\n```\n\n**GOOD:**\n```dart\nvoid someFunctionOK() {\n  StreamSubscription _subscriptionB; // OK\n  _subscriptionB.cancel();\n}\n```\n\n"
  },
  {
    "name": "close_sinks",
    "description": "Close instances of `dart.core.Sink`.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** invoke `close` on instances of `dart.core.Sink`.\n\nClosing instances of Sink prevents memory leaks and unexpected behavior.\n\n**BAD:**\n```dart\nclass A {\n  IOSink _sinkA;\n  void init(filename) {\n    _sinkA = File(filename).openWrite(); // LINT\n  }\n}\n```\n\n**BAD:**\n```dart\nvoid someFunction() {\n  IOSink _sinkF; // LINT\n}\n```\n\n**GOOD:**\n```dart\nclass B {\n  IOSink _sinkB;\n  void init(filename) {\n    _sinkB = File(filename).openWrite(); // OK\n  }\n\n  void dispose(filename) {\n    _sinkB.close();\n  }\n}\n```\n\n**GOOD:**\n```dart\nvoid someFunctionOK() {\n  IOSink _sinkFOK; // OK\n  _sinkFOK.close();\n}\n```\n\n"
  },
  {
    "name": "comment_references",
    "description": "Only reference in scope identifiers in doc comments.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** reference only in scope identifiers in doc comments.\n\nIf you surround things like variable, method, or type names in square brackets,\nthen [dartdoc](https://dart.dev/guides/language/effective-dart/documentation) will look\nup the name and link to its docs.  For this all to work, ensure that all\nidentifiers in docs wrapped in brackets are in scope.\n\nFor example,\n\n**GOOD:**\n```dart\n/// Return the larger of [a] or [b].\nint max_int(int a, int b) { ... }\n```\n\nOn the other hand, assuming `outOfScopeId` is out of scope:\n\n**BAD:**\n```dart\n/// Return true if [value] is larger than [outOfScopeId].\nbool isOutOfRange(int value) { ... }\n```\n\nNote that the square bracket comment format is designed to allow \ncomments to refer to declarations using a fairly natural format \nbut does not allow *arbitrary expressions*.  In particular, code \nreferences within square brackets can consist of either\n\n- a single identifier where the identifier is any identifier in scope for the comment (see the spec for what is in scope in doc comments),\n- two identifiers separated by a period where the first identifier is the name of a class that is in scope and the second is the name of a member declared in the class,\n- a single identifier followed by a pair of parentheses where the identifier is the name of a class that is in scope (used to refer to the unnamed constructor for the class), or\n- two identifiers separated by a period and followed by a pair of parentheses where the first identifier is the name of a class that is in scope and the second is the name of a named constructor (not strictly necessary, but allowed for consistency).\n\n"
  },
  {
    "name": "control_flow_in_finally",
    "description": "Avoid control flow in finally blocks.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter"
    ],
    "details": "\n**AVOID** control flow leaving finally blocks.\n\nUsing control flow in finally blocks will inevitably cause unexpected behavior\nthat is hard to debug.\n\n**GOOD:**\n```dart\nclass Ok {\n  double compliantMethod() {\n    var i = 5;\n    try {\n      i = 1 / 0;\n    } catch (e) {\n      print(e); // OK\n    }\n    return i;\n  }\n}\n```\n\n**BAD:**\n```dart\nclass BadReturn {\n  double nonCompliantMethod() {\n    try {\n      return 1 / 0;\n    } catch (e) {\n      print(e);\n    } finally {\n      return 1.0; // LINT\n    }\n  }\n}\n```\n\n**BAD:**\n```dart\nclass BadContinue {\n  double nonCompliantMethod() {\n    for (var o in [1, 2]) {\n      try {\n        print(o / 0);\n      } catch (e) {\n        print(e);\n      } finally {\n        continue; // LINT\n      }\n    }\n    return 1.0;\n  }\n}\n```\n\n**BAD:**\n```dart\nclass BadBreak {\n  double nonCompliantMethod() {\n    for (var o in [1, 2]) {\n      try {\n        print(o / 0);\n      } catch (e) {\n        print(e);\n      } finally {\n        break; // LINT\n      }\n    }\n    return 1.0;\n  }\n}\n```\n\n"
  },
  {
    "name": "diagnostic_describe_all_properties",
    "description": "DO reference all public properties in debug methods.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "**DO** reference all public properties in `debug` method implementations.\n\nImplementers of `Diagnosticable` should reference all public properties in\na `debugFillProperties(...)` or `debugDescribeChildren(...)` method\nimplementation to improve debuggability at runtime.\n\nPublic properties are defined as fields and getters that are\n\n* not package-private (e.g., prefixed with `_`)\n* not `static` or overriding\n* not themselves `Widget`s or collections of `Widget`s\n\nIn addition, the \"debug\" prefix is treated specially for properties in Flutter.\nFor the purposes of diagnostics, a property `foo` and a prefixed property\n`debugFoo` are treated as effectively describing the same property and it is\nsufficient to refer to one or the other.\n\n**BAD:**\n```dart\nclass Absorber extends Widget {\n  bool get absorbing => _absorbing;\n  bool _absorbing;\n  bool get ignoringSemantics => _ignoringSemantics;\n  bool _ignoringSemantics;\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty<bool>('absorbing', absorbing));\n    // Missing reference to ignoringSemantics\n  }\n}  \n```\n\n**GOOD:**\n```dart\nclass Absorber extends Widget {\n  bool get absorbing => _absorbing;\n  bool _absorbing;\n  bool get ignoringSemantics => _ignoringSemantics;\n  bool _ignoringSemantics;\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty<bool>('absorbing', absorbing));\n    properties.add(DiagnosticsProperty<bool>('ignoringSemantics', ignoringSemantics));\n  }\n}  \n```\n"
  },
  {
    "name": "empty_statements",
    "description": "Avoid empty statements.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter"
    ],
    "details": "\n**AVOID** empty statements.\n\nEmpty statements almost always indicate a bug.\n\nFor example,\n\n**BAD:**\n```dart\nif (complicated.expression.foo());\n  bar();\n```\n\nFormatted with `dart format` the bug becomes obvious:\n\n```dart\nif (complicated.expression.foo()) ;\nbar();\n\n```\n\nBetter to avoid the empty statement altogether.\n\n**GOOD:**\n```dart\nif (complicated.expression.foo())\n  bar();\n```\n\n"
  },
  {
    "name": "hash_and_equals",
    "description": "Always override `hashCode` if overriding `==`.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter",
      "effective_dart"
    ],
    "details": "\n**DO** override `hashCode` if overriding `==` and prefer overriding `==` if\noverriding `hashCode`.\n\nEvery object in Dart has a `hashCode`.  Both the `==` operator and the\n`hashCode` property of objects must be consistent in order for a common hash\nmap implementation to function properly.  Thus, when overriding `==`, the\n`hashCode` should also be overridden to maintain consistency. Similarly, if\n`hashCode` is overridden, `==` should be also.\n\n**BAD:**\n```dart\nclass Bad {\n  final int value;\n  Bad(this.value);\n\n  @override\n  bool operator ==(Object other) => other is Bad && other.value == value;\n}\n```\n\n**GOOD:**\n```dart\nclass Better {\n  final int value;\n  Better(this.value);\n\n  @override\n  bool operator ==(Object other) => other is Better && other.value == value;\n\n  @override\n  int get hashCode => value.hashCode;\n}\n```\n"
  },
  {
    "name": "invariant_booleans",
    "description": "Conditions should not unconditionally evaluate to `true` or to `false`.",
    "group": "errors",
    "maturity": "experimental",
    "incompatible": [],
    "sets": [],
    "details": "\n**DON'T** test for conditions that can be inferred at compile time or test the\nsame condition twice.\n\nConditional statements using a condition which cannot be anything but `false`\nhave the effect of making blocks of code non-functional.  If the condition\ncannot evaluate to anything but `true`, the conditional statement is completely\nredundant, and makes the code less readable.\nIt is quite likely that the code does not match the programmer's intent.\nEither the condition should be removed or it should be updated so that it does\nnot always evaluate to `true` or `false` and does not perform redundant tests.\nThis rule will hint to the test conflicting with the linted one.\n\n**BAD:**\n```dart\n// foo can't be both equal and not equal to bar in the same expression\nif(foo == bar && something && foo != bar) {...}\n```\n\n**BAD:**\n```dart\nvoid compute(int foo) {\n  if (foo == 4) {\n    doSomething();\n    // we know foo is equal to 4 at this point, so the next condition is always false\n    if (foo > 4) {...}\n    ...\n  }\n  ...\n}\n```\n\n**BAD:**\n```dart\nvoid compute(bool foo) {\n  if (foo) {\n    return;\n  }\n  doSomething();\n  // foo is always false here\n  if (foo){...}\n  ...\n}\n```\n\n**GOOD:**\n```dart\nvoid nestedOK() {\n  if (foo == bar) {\n    foo = baz;\n    if (foo != bar) {...}\n  }\n}\n```\n\n**GOOD:**\n```dart\nvoid nestedOk2() {\n  if (foo == bar) {\n    return;\n  }\n\n  foo = baz;\n  if (foo == bar) {...} // OK\n}\n```\n\n**GOOD:**\n```dart\nvoid nestedOk5() {\n  if (foo != null) {\n    if (bar != null) {\n      return;\n    }\n  }\n\n  if (bar != null) {...} // OK\n}\n```\n\n"
  },
  {
    "name": "iterable_contains_unrelated_type",
    "description": "Invocation of Iterable<E>.contains with references of unrelated types.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter"
    ],
    "details": "\n**DON'T** invoke `contains` on `Iterable` with an instance of different type\nthan the parameter type.\n\nDoing this will invoke `==` on its elements and most likely will return `false`.\n\n**BAD:**\n```dart\nvoid someFunction() {\n  var list = <int>[];\n  if (list.contains('1')) print('someFunction'); // LINT\n}\n```\n\n**BAD:**\n```dart\nvoid someFunction3() {\n  List<int> list = <int>[];\n  if (list.contains('1')) print('someFunction3'); // LINT\n}\n```\n\n**BAD:**\n```dart\nvoid someFunction8() {\n  List<DerivedClass2> list = <DerivedClass2>[];\n  DerivedClass3 instance;\n  if (list.contains(instance)) print('someFunction8'); // LINT\n}\n```\n\n**BAD:**\n```dart\nabstract class SomeIterable<E> implements Iterable<E> {}\n\nabstract class MyClass implements SomeIterable<int> {\n  bool badMethod(String thing) => this.contains(thing); // LINT\n}\n```\n\n**GOOD:**\n```dart\nvoid someFunction10() {\n  var list = [];\n  if (list.contains(1)) print('someFunction10'); // OK\n}\n```\n\n**GOOD:**\n```dart\nvoid someFunction1() {\n  var list = <int>[];\n  if (list.contains(1)) print('someFunction1'); // OK\n}\n```\n\n**GOOD:**\n```dart\nvoid someFunction4() {\n  List<int> list = <int>[];\n  if (list.contains(1)) print('someFunction4'); // OK\n}\n```\n\n**GOOD:**\n```dart\nvoid someFunction5() {\n  List<ClassBase> list = <ClassBase>[];\n  DerivedClass1 instance;\n  if (list.contains(instance)) print('someFunction5'); // OK\n}\n\nabstract class ClassBase {}\n\nclass DerivedClass1 extends ClassBase {}\n```\n\n**GOOD:**\n```dart\nvoid someFunction6() {\n  List<Mixin> list = <Mixin>[];\n  DerivedClass2 instance;\n  if (list.contains(instance)) print('someFunction6'); // OK\n}\n\nabstract class ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass2 extends ClassBase with Mixin {}\n```\n\n**GOOD:**\n```dart\nvoid someFunction7() {\n  List<Mixin> list = <Mixin>[];\n  DerivedClass3 instance;\n  if (list.contains(instance)) print('someFunction7'); // OK\n}\n\nabstract class ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass3 extends ClassBase implements Mixin {}\n```\n\n"
  },
  {
    "name": "list_remove_unrelated_type",
    "description": "Invocation of `remove` with references of unrelated types.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter"
    ],
    "details": "\n**DON'T** invoke `remove` on `List` with an instance of different type than\nthe parameter type.\n\nDoing this will invoke `==` on its elements and most likely will\nreturn `false`.\n\n**BAD:**\n```dart\nvoid someFunction() {\n  var list = <int>[];\n  if (list.remove('1')) print('someFunction'); // LINT\n}\n```\n\n**BAD:**\n```dart\nvoid someFunction3() {\n  List<int> list = <int>[];\n  if (list.remove('1')) print('someFunction3'); // LINT\n}\n```\n\n**BAD:**\n```dart\nvoid someFunction8() {\n  List<DerivedClass2> list = <DerivedClass2>[];\n  DerivedClass3 instance;\n  if (list.remove(instance)) print('someFunction8'); // LINT\n}\n```\n\n**BAD:**\n```dart\nabstract class SomeList<E> implements List<E> {}\n\nabstract class MyClass implements SomeList<int> {\n  bool badMethod(String thing) => this.remove(thing); // LINT\n}\n```\n\n**GOOD:**\n```dart\nvoid someFunction10() {\n  var list = [];\n  if (list.remove(1)) print('someFunction10'); // OK\n}\n```\n\n**GOOD:**\n```dart\nvoid someFunction1() {\n  var list = <int>[];\n  if (list.remove(1)) print('someFunction1'); // OK\n}\n```\n\n**GOOD:**\n```dart\nvoid someFunction4() {\n  List<int> list = <int>[];\n  if (list.remove(1)) print('someFunction4'); // OK\n}\n```\n\n**GOOD:**\n```dart\nvoid someFunction5() {\n  List<ClassBase> list = <ClassBase>[];\n  DerivedClass1 instance;\n  if (list.remove(instance)) print('someFunction5'); // OK\n}\n\nabstract class ClassBase {}\n\nclass DerivedClass1 extends ClassBase {}\n```\n\n**GOOD:**\n```dart\nvoid someFunction6() {\n  List<Mixin> list = <Mixin>[];\n  DerivedClass2 instance;\n  if (list.remove(instance)) print('someFunction6'); // OK\n}\n\nabstract class ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass2 extends ClassBase with Mixin {}\n```\n\n**GOOD:**\n```dart\nvoid someFunction7() {\n  List<Mixin> list = <Mixin>[];\n  DerivedClass3 instance;\n  if (list.remove(instance)) print('someFunction7'); // OK\n}\n\nabstract class ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass3 extends ClassBase implements Mixin {}\n```\n\n"
  },
  {
    "name": "literal_only_boolean_expressions",
    "description": "Boolean expression composed only with literals.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DON'T** test for conditions composed only by literals, since the value can be\ninferred at compile time.\n\nConditional statements using a condition which cannot be anything but FALSE have\nthe effect of making blocks of code non-functional.  If the condition cannot\nevaluate to anything but `true`, the conditional statement is completely\nredundant, and makes the code less readable.\nIt is quite likely that the code does not match the programmer's intent.\nEither the condition should be removed or it should be updated so that it does\nnot always evaluate to `true` or `false`.\n\n**BAD:**\n```dart\nvoid bad() {\n  if (true) {} // LINT\n}\n```\n\n**BAD:**\n```dart\nvoid bad() {\n  if (true && 1 != 0) {} // LINT\n}\n```\n\n**BAD:**\n```dart\nvoid bad() {\n  if (1 != 0 && true) {} // LINT\n}\n```\n\n**BAD:**\n```dart\nvoid bad() {\n  if (1 < 0 && true) {} // LINT\n}\n```\n\n**BAD:**\n```dart\nvoid bad() {\n  if (true && false) {} // LINT\n}\n```\n\n**BAD:**\n```dart\nvoid bad() {\n  if (1 != 0) {} // LINT\n}\n```\n\n**BAD:**\n```dart\nvoid bad() {\n  if (true && 1 != 0 || 3 < 4) {} // LINT\n}\n```\n\n**BAD:**\n```dart\nvoid bad() {\n  if (1 != 0 || 3 < 4 && true) {} // LINT\n}\n```\n\n"
  },
  {
    "name": "no_adjacent_strings_in_list",
    "description": "Don't use adjacent strings in list.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DON'T** use adjacent strings in list.\n\nThis can be sign of forgotten comma.\n\n**GOOD:**\n```dart\nList<String> list = <String>[\n  'a' +\n  'b',\n  'c',\n];\n```\n\n**BAD:**\n```dart\nList<String> list = <String>[\n  'a'\n  'b',\n  'c',\n];\n```\n\n"
  },
  {
    "name": "no_duplicate_case_values",
    "description": "Don't use more than one case with same value.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter",
      "pedantic"
    ],
    "details": "\n**DON'T** use more than one case with same value.\n\nThis is usually a typo or changed value of constant.\n\n**GOOD:**\n```dart\nconst int A = 1;\nswitch (v) {\n  case A:\n  case 2:\n}\n```\n\n**BAD:**\n```dart\nconst int A = 1;\nswitch (v) {\n  case 1:\n  case 2:\n  case A:\n  case 2:\n}\n```\n\n"
  },
  {
    "name": "no_logic_in_create_state",
    "description": "Don't put any logic in createState.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "flutter"
    ],
    "details": "**DON'T** put any logic in `createState()`.\n\nImplementations of  `createState()` should return a new instance\nof a State object and do nothing more.  Since state access is preferred \nvia the `widget` field,  passing data to `State` objects using custom\nconstructor parameters should also be avoided and so further, the State\nconstructor is required to be passed no arguments.\n\n**BAD:**\n```dart\nMyState global;\n\nclass MyStateful extends StatefulWidget {\n  @override\n  MyState createState() {\n    global = MyState();\n    return global;\n  } \n}\n```\n\n```dart\nclass MyStateful extends StatefulWidget {\n  @override\n  MyState createState() => MyState()..field = 42;\n}\n```\n\n```dart\nclass MyStateful extends StatefulWidget {\n  @override\n  MyState createState() => MyState(42);\n}\n```\n\n\n**GOOD:**\n```dart\nclass MyStateful extends StatefulWidget {\n  @override\n  MyState createState() {\n    return MyState();\n  }\n}\n```\n"
  },
  {
    "name": "prefer_relative_imports",
    "description": "Prefer relative imports for files in `lib/`.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "Prefer relative imports for files in `lib/`.\n\nWhen mixing relative and absolute imports it's possible to create confusion\nwhere the same member gets imported in two different ways. One way to avoid\nthat is to ensure you consistently use relative imports for files withing the\n`lib/` directory.\n\n**GOOD:**\n\n```dart\nimport 'bar.dart';\n```\n\n**BAD:**\n\n```dart\nimport 'package:my_package/bar.dart';\n```\n\n"
  },
  {
    "name": "prefer_void_to_null",
    "description": "Don't use the Null type, unless you are positive that you don't want void.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter"
    ],
    "details": "\n**DO NOT** use the type Null where void would work.\n\n**BAD:**\n```dart\nNull f() {}\nFuture<Null> f() {}\nStream<Null> f() {}\nf(Null x) {}\n```\n\n**GOOD:**\n```dart\nvoid f() {}\nFuture<void> f() {}\nStream<void> f() {}\nf(void x) {}\n```\n\nSome exceptions include formulating special function types:\n\n```dart\nNull Function(Null, Null);\n```\n\nand for making empty literals which are safe to pass into read-only locations\nfor any type of map or list:\n\n```dart\n<Null>[];\n<int, Null>{};\n```\n"
  },
  {
    "name": "test_types_in_equals",
    "description": "Test type arguments in operator ==(Object other).",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** test type arguments in operator ==(Object other).\n\nNot testing types might result in null pointer exceptions which will be\nunexpected for consumers of your class.\n\n**GOOD:**\n```dart\nclass Field {\n}\n\nclass Good {\n  final Field someField;\n\n  Good(this.someField);\n\n  @override\n  bool operator ==(Object other) {\n    if (identical(this, other)) {\n      return true;\n    }\n    return other is Good &&\n        this.someField == other.someField;\n  }\n\n  @override\n  int get hashCode {\n    return someField.hashCode;\n  }\n}\n```\n\n**BAD:**\n```dart\nclass Field {\n}\n\nclass Bad {\n  final Field someField;\n\n  Bad(this.someField);\n\n  @override\n  bool operator ==(Object other) {\n    Bad otherBad = other as Bad; // LINT\n    bool areEqual = otherBad != null && otherBad.someField == someField;\n    return areEqual;\n  }\n\n  @override\n  int get hashCode {\n    return someField.hashCode;\n  }\n}\n```\n\n"
  },
  {
    "name": "throw_in_finally",
    "description": "Avoid `throw` in finally block.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**AVOID** throwing exceptions in finally blocks.\n\nThrowing exceptions in finally blocks will inevitably cause unexpected behavior\nthat is hard to debug.\n\n**GOOD:**\n```dart\nclass Ok {\n  double compliantMethod() {\n    var i = 5;\n    try {\n      i = 1 / 0;\n    } catch (e) {\n      print(e); // OK\n    }\n    return i;\n  }\n}\n```\n\n**BAD:**\n```dart\nclass BadThrow {\n  double nonCompliantMethod() {\n    try {\n      print('hello world! ${1 / 0}');\n    } catch (e) {\n      print(e);\n    } finally {\n      throw 'Find the hidden error :P'; // LINT\n    }\n  }\n}\n```\n\n"
  },
  {
    "name": "unnecessary_statements",
    "description": "Avoid using unnecessary statements.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**AVOID** using unnecessary statements.\n\nStatements which have no clear effect are usually unnecessary, or should be\nbroken up.\n\nFor example,\n\n**BAD:**\n```dart\nmyvar;\nlist.clear;\n1 + 2;\nmethodOne() + methodTwo();\nfoo ? bar : baz;\n```\n\nThough the added methods have a clear effect, the addition itself does not\nunless there is some magical overload of the + operator.\n\nUsually code like this indicates an incomplete thought, and is a bug.\n\n**GOOD:**\n```dart\nsome.method();\nconst SomeClass();\nmethodOne();\nmethodTwo();\nfoo ? bar() : baz();\nreturn myvar;\n```\n\n"
  },
  {
    "name": "unrelated_type_equality_checks",
    "description": "Equality operator `==` invocation with references of unrelated types.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter",
      "pedantic"
    ],
    "details": "\n**DON'T** Compare references of unrelated types for equality.\n\nComparing references of a type where neither is a subtype of the other most\nlikely will return `false` and might not reflect programmer's intent.\n\n`Int64` and `Int32` from `package:fixnum` allow comparing to `int` provided\nthe `int` is on the right hand side. The lint allows this as a special case. \n\n**BAD:**\n```dart\nvoid someFunction() {\n  var x = '1';\n  if (x == 1) print('someFunction'); // LINT\n}\n```\n\n**BAD:**\n```dart\nvoid someFunction1() {\n  String x = '1';\n  if (x == 1) print('someFunction1'); // LINT\n}\n```\n\n**BAD:**\n```dart\nvoid someFunction13(DerivedClass2 instance) {\n  var other = DerivedClass3();\n\n  if (other == instance) print('someFunction13'); // LINT\n}\n\nclass ClassBase {}\n\nclass DerivedClass1 extends ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass2 extends ClassBase with Mixin {}\n\nclass DerivedClass3 extends ClassBase implements Mixin {}\n```\n\n**GOOD:**\n```dart\nvoid someFunction2() {\n  var x = '1';\n  var y = '2';\n  if (x == y) print(someFunction2); // OK\n}\n```\n\n**GOOD:**\n```dart\nvoid someFunction3() {\n  for (var i = 0; i < 10; i++) {\n    if (i == 0) print(someFunction3); // OK\n  }\n}\n```\n\n**GOOD:**\n```dart\nvoid someFunction4() {\n  var x = '1';\n  if (x == null) print(someFunction4); // OK\n}\n```\n\n**GOOD:**\n```dart\nvoid someFunction7() {\n  List someList;\n\n  if (someList.length == 0) print('someFunction7'); // OK\n}\n```\n\n**GOOD:**\n```dart\nvoid someFunction8(ClassBase instance) {\n  DerivedClass1 other;\n\n  if (other == instance) print('someFunction8'); // OK\n}\n```\n\n**GOOD:**\n```dart\nvoid someFunction10(unknown) {\n  var what = unknown - 1;\n  for (var index = 0; index < unknown; index++) {\n    if (what == index) print('someFunction10'); // OK\n  }\n}\n```\n\n**GOOD:**\n```dart\nvoid someFunction11(Mixin instance) {\n  var other = DerivedClass2();\n\n  if (other == instance) print('someFunction11'); // OK\n  if (other != instance) print('!someFunction11'); // OK\n}\n\nclass ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass2 extends ClassBase with Mixin {}\n```\n\n"
  },
  {
    "name": "unsafe_html",
    "description": "Avoid unsafe HTML APIs.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "pedantic"
    ],
    "details": "\n**AVOID**\n\n* assigning directly to the `href` field of an AnchorElement\n* assigning directly to the `src` field of an EmbedElement, IFrameElement,\n  ImageElement, or ScriptElement\n* assigning directly to the `srcdoc` field of an IFrameElement\n* calling the `createFragment` method of Element\n* calling the `open` method of Window\n* calling the `setInnerHtml` method of Element\n* calling the `Element.html` constructor\n* calling the `DocumentFragment.html` constructor\n\n\n**BAD:**\n```dart\nvar script = ScriptElement()..src = 'foo.js';\n```\n"
  },
  {
    "name": "use_build_context_synchronously",
    "description": "Do not use BuildContexts across async gaps.",
    "group": "errors",
    "maturity": "experimental",
    "incompatible": [],
    "sets": [],
    "details": "**DO NOT** use BuildContext across asynchronous gaps.\n\nStoring `BuildContext` for later usage can easily lead to difficult to diagnose\ncrashes. Asynchronous gaps are implicitly storing `BuildContext` and are some of\nthe easiest to overlook when writing code.\n\nWhen a `BuildContext` is used from a `StatefulWidget`, the `mounted` property\nmust be checked after an asynchronous gap.\n\n**GOOD:**\n```dart\nvoid onButtonTapped(BuildContext context) {\n  Navigator.of(context).pop();\n}\n```\n\n**BAD:**\n```dart\nvoid onButtonTapped(BuildContext context) async {\n  await Future.delayed(const Duration(seconds: 1));\n  Navigator.of(context).pop();\n}\n```\n\n**GOOD:**\n```dart\nclass _MyWidgetState extends State<MyWidget> {\n  ...\n\n  void onButtonTapped() async {\n    await Future.delayed(const Duration(seconds: 1));\n\n    if (!mounted) return;\n    Navigator.of(context).pop();\n  }\n}\n```\n"
  },
  {
    "name": "use_key_in_widget_constructors",
    "description": "Use key in widget constructors.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "flutter"
    ],
    "details": "**DO** use key in widget constructors.\n\nIt's a good practice to expose the ability to provide a key when creating public\nwidgets.\n\n**BAD:**\n```dart\nclass MyPublicWidget extends StatelessWidget {\n}\n```\n\n**GOOD:**\n```dart\nclass MyPublicWidget extends StatelessWidget {\n  MyPublicWidget({Key? key}) : super(key: key);\n}\n```\n"
  },
  {
    "name": "valid_regexps",
    "description": "Use valid regular expression syntax.",
    "group": "errors",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter",
      "pedantic"
    ],
    "details": "\n**DO** use valid regular expression syntax when creating regular expression\ninstances.\n\nRegular expressions created with invalid syntax will throw a `FormatException`\nat runtime so should be avoided.\n\n**BAD:**\n```dart\nprint(RegExp(r'(').hasMatch('foo()'));\n```\n\n**GOOD:**\n```dart\nprint(RegExp(r'\\(').hasMatch('foo()'));\n```\n\n"
  },
  {
    "name": "depend_on_referenced_packages",
    "description": "Depend on referenced packages.",
    "group": "pub",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** Depend on referenced packages.\n\nWhen importing a package, add a dependency on it to your pubspec.\n\nDepending explicitly on packages that you reference ensures they will always\nexist and allows you to put a dependency constraint on them to guard you\nagainst breaking changes.\n\nWhether this should be a regular dependency or dev_dependency depends on if it\nis referenced from a public file (one under either `lib` or `bin`), or some\nother private file.\n\n**BAD:**\n```dart\nimport 'package:a/a.dart';\n```\n\n```yaml\ndependencies:\n```\n\n**GOOD:**\n```dart\nimport 'package:a/a.dart';\n```\n\n```yaml\ndependencies:\n  a: ^1.0.0\n```\n\n"
  },
  {
    "name": "package_names",
    "description": "Use `lowercase_with_underscores` for package names.",
    "group": "pub",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter"
    ],
    "details": "\nFrom the [Pubspec format description](https://dart.dev/tools/pub/pubspec):\n\n**DO** use `lowercase_with_underscores` for package names.\n\nPackage names should be all lowercase, with underscores to separate words,\n`just_like_this`.  Use only basic Latin letters and Arabic digits: [a-z0-9_].\nAlso, make sure the name is a valid Dart identifier -- that it doesn't start\nwith digits and isn't a reserved word.\n\n"
  },
  {
    "name": "sort_pub_dependencies",
    "description": "Sort pub dependencies.",
    "group": "pub",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "**DO** sort pub dependencies in `pubspec.yaml`.\n\nSorting list of pub dependencies makes maintenance easier.\n"
  },
  {
    "name": "always_declare_return_types",
    "description": "Declare method return types.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "pedantic"
    ],
    "details": "\n**DO** declare method return types.\n\nWhen declaring a method or function *always* specify a return type.\nDeclaring return types for functions helps improve your codebase by allowing the\nanalyzer to more adequately check your code for errors that could occur during\nruntime.\n\n**BAD:**\n```dart\nmain() { }\n\n_bar() => _Foo();\n\nclass _Foo {\n  _foo() => 42;\n}\n```\n\n**GOOD:**\n```dart\nvoid main() { }\n\n_Foo _bar() => _Foo();\n\nclass _Foo {\n  int _foo() => 42;\n}\n\ntypedef predicate = bool Function(Object o);\n```\n\n"
  },
  {
    "name": "always_put_control_body_on_new_line",
    "description": "Separate the control structure expression from its statement.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\nFrom the [flutter style guide](https://flutter.dev/style-guide/):\n\n**DO** separate the control structure expression from its statement.\n\nDon't put the statement part of an `if`, `for`, `while`, `do` on the same line\nas the expression, even if it is short.  Doing so makes it unclear that there\nis relevant code there.  This is especially important for early returns.\n\n**GOOD:**\n```dart\nif (notReady)\n  return;\n\nif (notReady)\n  return;\nelse\n  print('ok')\n\nwhile (condition)\n  i += 1;\n```\n\n**BAD:**\n```dart\nif (notReady) return;\n\nif (notReady)\n  return;\nelse print('ok')\n\nwhile (condition) i += 1;\n```\n\n"
  },
  {
    "name": "always_put_required_named_parameters_first",
    "description": "Put required named parameters first.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** specify `required` on named parameter before other named parameters.\n\n**GOOD:**\n```dart\nm({required a, b, c}) ;\n```\n\n**BAD:**\n```dart\nm({b, c, required a}) ;\n```\n\n**GOOD:**\n```dart\nm({@required a, b, c}) ;\n```\n\n**BAD:**\n```dart\nm({b, c, @required a}) ;\n```\n\n"
  },
  {
    "name": "always_require_non_null_named_parameters",
    "description": "Specify `@required` on named parameters without defaults.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic"
    ],
    "details": "\n**DO** specify `@required` on named parameters without a default value on which \nan `assert(param != null)` is done.\n\n**GOOD:**\n```dart\nm1({@required a}) {\n  assert(a != null);\n}\n\nm2({a: 1}) {\n  assert(a != null);\n}\n```\n\n**BAD:**\n```dart\nm1({a}) {\n  assert(a != null);\n}\n```\n\nNOTE: Only asserts at the start of the bodies will be taken into account.\n\n"
  },
  {
    "name": "always_specify_types",
    "description": "Specify type annotations.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [
      "omit_local_variable_types"
    ],
    "sets": [],
    "details": "\nFrom the [flutter style guide](https://flutter.dev/style-guide/):\n\n**DO** specify type annotations.\n\nAvoid `var` when specifying that a type is unknown and short-hands that elide\ntype annotations.  Use `dynamic` if you are being explicit that the type is\nunknown.  Use `Object` if you are being explicit that you want an object that\nimplements `==` and `hashCode`.\n\n**GOOD:**\n```dart\nint foo = 10;\nfinal Bar bar = Bar();\nString baz = 'hello';\nconst int quux = 20;\n```\n\n**BAD:**\n```dart\nvar foo = 10;\nfinal bar = Bar();\nconst quux = 20;\n```\n\nNOTE: Using the the `@optionalTypeArgs` annotation in the `meta` package, API\nauthors can special-case type variables whose type needs to by dynamic but whose\ndeclaration should be treated as optional.  For example, suppose you have a\n`Key` object whose type parameter you'd like to treat as optional.  Using the\n`@optionalTypeArgs` would look like this:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@optionalTypeArgs\nclass Key<T> {\n ...\n}\n\nmain() {\n  Key s = Key(); // OK!\n}\n```\n\n"
  },
  {
    "name": "annotate_overrides",
    "description": "Annotate overridden members.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic"
    ],
    "details": "\n**DO** annotate overridden methods and fields.\n\nThis practice improves code readability and helps protect against\nunintentionally overriding superclass members.\n\n**GOOD:**\n```dart\nabstract class Dog {\n  String get breed;\n  void bark() {}\n}\n\nclass Husky extends Dog {\n  @override\n  final String breed = 'Husky';\n  @override\n  void bark() {}\n}\n```\n\n**BAD:**\n```dart\nclass Cat {\n  int get lives => 9;\n}\n\nclass Lucky extends Cat {\n  final int lives = 14;\n}\n```\n\n"
  },
  {
    "name": "avoid_annotating_with_dynamic",
    "description": "Avoid annotating with dynamic when not required.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**AVOID** annotating with dynamic when not required.\n\nAs `dynamic` is the assumed return value of a function or method, it is usually\nnot necessary to annotate it.\n\n**BAD:**\n```dart\ndynamic lookUpOrDefault(String name, Map map, dynamic defaultValue) {\n  var value = map[name];\n  if (value != null) return value;\n  return defaultValue;\n}\n```\n\n**GOOD:**\n```dart\nlookUpOrDefault(String name, Map map, defaultValue) {\n  var value = map[name];\n  if (value != null) return value;\n  return defaultValue;\n}\n```\n\n"
  },
  {
    "name": "avoid_as",
    "description": "Avoid using `as`.",
    "group": "style",
    "maturity": "deprecated",
    "incompatible": [],
    "sets": [],
    "details": "\n**AVOID** using `as`.\n\nIf you know the type is correct, use an assertion or assign to a more\nnarrowly-typed variable (this avoids the type check in release mode; `as` is not\ncompiled out in release mode).  If you don't know whether the type is\ncorrect, check using `is` (this avoids the exception that `as` raises).\n\n**BAD:**\n```dart\n(pm as Person).firstName = 'Seth';\n```\n\n**GOOD:**\n```dart\nif (pm is Person)\n  pm.firstName = 'Seth';\n```\n\nbut certainly not\n\n**BAD:**\n```dart\ntry {\n   (pm as Person).firstName = 'Seth';\n} on CastError { }\n```\n\nNote that an exception is made in the case of `dynamic` since the cast has no\nperformance impact.\n\n**OK:**\n```dart\nHasScrollDirection scrollable = renderObject as dynamic;\n```\n\n\n**DEPRECATED:** This advice is no longer recommended.\n \nThe rule will be removed in a future Linter release.\n"
  },
  {
    "name": "avoid_bool_literals_in_conditional_expressions",
    "description": "Avoid bool literals in conditional expressions.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**AVOID** bool literals in conditional expressions.\n\n**BAD:**\n```dart\ncondition ? true : boolExpression\ncondition ? false : boolExpression\ncondition ? boolExpression : true\ncondition ? boolExpression : false\n```\n\n**GOOD:**\n```dart\ncondition || boolExpression\n!condition && boolExpression\n!condition || boolExpression\ncondition && boolExpression\n```\n\n"
  },
  {
    "name": "avoid_catches_without_on_clauses",
    "description": "Avoid catches without on clauses.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\n**AVOID** catches without on clauses.\n\nUsing catch clauses without on clauses make your code prone to encountering\nunexpected errors that won't be thrown (and thus will go unnoticed).\n\n**BAD:**\n```dart\ntry {\n somethingRisky()\n}\ncatch(e) {\n  doSomething(e);\n}\n```\n\n**GOOD:**\n```dart\ntry {\n somethingRisky()\n}\non Exception catch(e) {\n  doSomething(e);\n}\n```\n\n"
  },
  {
    "name": "avoid_catching_errors",
    "description": "Don't explicitly catch Error or types that implement it.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\n**DON'T** explicitly catch Error or types that implement it.\n\nErrors differ from Exceptions in that Errors can be analyzed and prevented prior\nto runtime.  It should almost never be necessary to catch an error at runtime.\n\n**BAD:**\n```dart\ntry {\n  somethingRisky();\n} on Error catch(e) {\n  doSomething(e);\n}\n```\n\n**GOOD:**\n```dart\ntry {\n  somethingRisky();\n} on Exception catch(e) {\n  doSomething(e);\n}\n```\n\n"
  },
  {
    "name": "avoid_classes_with_only_static_members",
    "description": "Avoid defining a class that contains only static members.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\n**AVOID** defining a class that contains only static members.\n\nCreating classes with the sole purpose of providing utility or otherwise static\nmethods is discouraged.  Dart allows functions to exist outside of classes for\nthis very reason.\n\n**BAD:**\n```dart\nclass DateUtils {\n  static DateTime mostRecent(List<DateTime> dates) {\n    return dates.reduce((a, b) => a.isAfter(b) ? a : b);\n  }\n}\n\nclass _Favorites {\n  static const mammal = 'weasel';\n}\n```\n\n**GOOD:**\n```dart\nDateTime mostRecent(List<DateTime> dates) {\n  return dates.reduce((a, b) => a.isAfter(b) ? a : b);\n}\n\nconst _favoriteMammal = 'weasel';\n```\n\n"
  },
  {
    "name": "avoid_double_and_int_checks",
    "description": "Avoid double and int checks.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**AVOID** to check if type is double or int.\n\nWhen compiled to JS, integer values are represented as floats. That can lead to\nsome unexpected behavior when using either `is` or `is!` where the type is\neither `int` or `double`.\n\n**BAD:**\n```dart\nf(num x) {\n  if (x is double) {\n    ...\n  } else if (x is int) {\n    ...\n  }\n}\n```\n\n**GOOD:**\n```dart\nf(dynamic x) {\n  if (x is num) {\n    ...\n  } else {\n    ...\n  }\n}\n```\n\n"
  },
  {
    "name": "avoid_equals_and_hash_code_on_mutable_classes",
    "description": "Avoid overloading operator == and hashCode on classes not marked `@immutable`.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\n**AVOID** overloading operator == and hashCode on classes not marked `@immutable`.\n\nIf a class is not immutable, overloading operator == and hashCode can lead to\nunpredictable and undesirable behavior when used in collections. See\nhttps://dart.dev/guides/language/effective-dart/design#avoid-defining-custom-equality-for-mutable-classes\nfor more information.\n\n**GOOD:**\n```dart\n@immutable\nclass A {\n  final String key;\n  const A(this.key);\n  @override\n  operator ==(other) => other is A && other.key == key;\n  @override\n  int hashCode() => key.hashCode;\n}\n```\n\n**BAD:**\n```dart\nclass B {\n  String key;\n  const B(this.key);\n  @override\n  operator ==(other) => other is B && other.key == key;\n  @override\n  int hashCode() => key.hashCode;\n}\n```\n\nNOTE: The lint checks the use of the @immutable annotation, and will trigger\neven if the class is otherwise not mutable. Thus:\n\n**BAD:**\n```dart\nclass C {\n  final String key;\n  const C(this.key);\n  @override\n  operator ==(other) => other is B && other.key == key;\n  @override\n  int hashCode() => key.hashCode;\n}\n```\n\n"
  },
  {
    "name": "avoid_escaping_inner_quotes",
    "description": "Avoid escaping inner quotes by converting surrounding quotes.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\nAvoid escaping inner quotes by converting surrounding quotes.\n\n**BAD:**\n```dart\nvar s = 'It\\'s not fun';\n```\n\n**GOOD:**\n```dart\nvar s = \"It's not fun\";\n```\n\n"
  },
  {
    "name": "avoid_field_initializers_in_const_classes",
    "description": "Avoid field initializers in const classes.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**AVOID** field initializers in const classes.\n\nInstead of `final x = const expr;`, you should write `get x => const expr;` and\nnot allocate a useless field. As of April 2018 this is true for the VM, but not\nfor code that will be compiled to JS.\n\n**BAD:**\n```dart\nclass A {\n  final a = const [];\n  const A();\n}\n```\n\n**GOOD:**\n```dart\nclass A {\n  get a => const [];\n  const A();\n}\n```\n\n"
  },
  {
    "name": "avoid_function_literals_in_foreach_calls",
    "description": "Avoid using `forEach` with a function literal.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "effective_dart"
    ],
    "details": "\n**AVOID** using `forEach` with a function literal.\n\n**BAD:**\n```dart\npeople.forEach((person) {\n  ...\n});\n```\n\n**GOOD:**\n```dart\nfor (var person in people) {\n  ...\n}\n\npeople.forEach(print);\n```\n"
  },
  {
    "name": "avoid_implementing_value_types",
    "description": "Don't implement classes that override `==`.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "**DON'T** implement classes that override `==`.\n\nThe `==` operator is contractually required to be an equivalence relation;\nthat is, symmetrically for all objects `o1` and `o2`, `o1 == o2` and `o2 == o1`\nmust either both be true, or both be false.\n\n> _NOTE_: Dart does not have true _value types_, so instead we consider a class\n> that implements `==`  as a _proxy_ for identifying value types.\n\nWhen using `implements`, you do not inherit the method body of `==`, making it\nnearly impossible to follow the contract of `==`. Classes that override `==`\ntypically are usable directly in tests _without_ creating mocks or fakes as\nwell. For example, for a given class `Size`:\n\n```dart\nclass Size {\n  final int inBytes;\n  const Size(this.inBytes);\n\n  @override\n  bool operator ==(Object other) => other is Size && other.inBytes == inBytes;\n\n  @override\n  int get hashCode => inBytes.hashCode;\n}\n```\n\n**BAD**:\n```dart\nclass CustomSize implements Size {\n  final int inBytes;\n  const CustomSize(this.inBytes);\n\n  int get inKilobytes => inBytes ~/ 1000;\n}\n```\n\n**BAD**:\n```dart\nimport 'package:test/test.dart';\nimport 'size.dart';\n\nclass FakeSize implements Size {\n  int inBytes = 0;\n}\n\nvoid main() {\n  test('should not throw on a size >1Kb', () {\n    expect(() => someFunction(FakeSize()..inBytes = 1001), returnsNormally);\n  });\n}\n```\n\n**GOOD**:\n```dart\nclass ExtendedSize extends Size {\n  ExtendedSize(int inBytes) : super(inBytes);\n\n  int get inKilobytes => inBytes ~/ 1000;\n}\n```\n\n**GOOD**:\n```dart\nimport 'package:test/test.dart';\nimport 'size.dart';\n\nvoid main() {\n  test('should not throw on a size >1Kb', () {\n    expect(() => someFunction(Size(1001)), returnsNormally);\n  });\n}\n```\n\n"
  },
  {
    "name": "avoid_init_to_null",
    "description": "Don't explicitly initialize variables to null.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\nFrom [effective dart](https://dart.dev/guides/language/effective-dart/usage#dont-explicitly-initialize-variables-to-null):\n\n**DON'T** explicitly initialize variables to null.\n\nIn Dart, a variable or field that is not explicitly initialized automatically\ngets initialized to null.  This is reliably specified by the language.  There's\nno concept of \"uninitialized memory\" in Dart.  Adding `= null` is redundant and\nunneeded.\n\n**GOOD:**\n```dart\nint _nextId;\n\nclass LazyId {\n  int _id;\n\n  int get id {\n    if (_nextId == null) _nextId = 0;\n    if (_id == null) _id = _nextId++;\n\n    return _id;\n  }\n}\n```\n\n**BAD:**\n```dart\nint _nextId = null;\n\nclass LazyId {\n  int _id = null;\n\n  int get id {\n    if (_nextId == null) _nextId = 0;\n    if (_id == null) _id = _nextId++;\n\n    return _id;\n  }\n}\n```\n\n"
  },
  {
    "name": "avoid_js_rounded_ints",
    "description": "Avoid JavaScript rounded ints.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**AVOID** integer literals that cannot be represented exactly when compiled to\nJavaScript.\n\nWhen a program is compiled to JavaScript `int` and `double` become JavaScript\nNumbers. Too large integers (`value < Number.MIN_SAFE_INTEGER` or\n`value > Number.MAX_SAFE_INTEGER`) may be rounded to the closest Number value.\n\nFor instance `1000000000000000001` cannot be represented exactly as a JavaScript\nNumber, so `1000000000000000000` will be used instead.\n\n**BAD:**\n```dart\nint value = 9007199254740995;\n```\n\n**GOOD:**\n```dart\nBigInt value = BigInt.parse('9007199254740995');\n```\n\n"
  },
  {
    "name": "avoid_multiple_declarations_per_line",
    "description": "Don't declare multiple variables on a single line.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DON'T** declare multiple variables on a single line.\n\n**BAD:**\n```dart\nString? foo, bar, baz;\n```\n\n**GOOD:**\n```dart\nString? foo;\nString? bar;\nString? baz;\n```\n\n"
  },
  {
    "name": "avoid_null_checks_in_equality_operators",
    "description": "Don't check for null in custom == operators.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\n**DON'T** check for null in custom == operators.\n\nAs null is a special type, no class can be equivalent to it.  Thus, it is\nredundant to check whether the other instance is null. \n\n**BAD:**\n```dart\nclass Person {\n  final String name;\n\n  @override\n  operator ==(other) =>\n      other != null && other is Person && name == other.name;\n}\n```\n\n**GOOD:**\n```dart\nclass Person {\n  final String name;\n\n  @override\n  operator ==(other) => other is Person && name == other.name;\n}\n```\n\n"
  },
  {
    "name": "avoid_positional_boolean_parameters",
    "description": "Avoid positional boolean parameters.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\n**AVOID** positional boolean parameters.\n\nPositional boolean parameters are a bad practice because they are very\nambiguous.  Using named boolean parameters is much more readable because it\ninherently describes what the boolean value represents.\n\n**BAD:**\n```dart\nTask(true);\nTask(false);\nListBox(false, true, true);\nButton(false);\n```\n\n**GOOD:**\n```dart\nTask.oneShot();\nTask.repeating();\nListBox(scroll: true, showScrollbars: true);\nButton(ButtonState.enabled);\n```\n\n"
  },
  {
    "name": "avoid_private_typedef_functions",
    "description": "Avoid private typedef functions.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\n**AVOID** private typedef functions used only once. Prefer inline function\nsyntax.\n\n**BAD:**\n```dart\ntypedef void _F();\nm(_F f);\n```\n\n**GOOD:**\n```dart\nm(void Function() f);\n```\n\n"
  },
  {
    "name": "avoid_redundant_argument_values",
    "description": "Avoid redundant argument values.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "Avoid redundant argument values.\n\n**DON'T** declare arguments with values that match the defaults for the\ncorresponding parameter.\n\n**BAD:**\n```dart\nvoid f({bool valWithDefault = true, bool val}) {\n  ...\n}\n\nvoid main() {\n  f(valWithDefault: true);\n}\n```\n\n**GOOD:**\n```dart\nvoid f({bool valWithDefault = true, bool val}) {\n  ...\n}\n\nvoid main() {\n  f(valWithDefault: false);\n  f();\n}\n```\n"
  },
  {
    "name": "avoid_renaming_method_parameters",
    "description": "Don't rename parameters of overridden methods.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter"
    ],
    "details": "**DON'T** rename parameters of overridden methods.\n\nMethods that override another method, but do not have their own documentation\ncomment, will inherit the overridden method's comment when dartdoc produces\ndocumentation. If the inherited method contains the name of the parameter (in\nsquare brackets), then dartdoc cannot link it correctly.\n\n**BAD:**\n```dart\nabstract class A {\n  m(a);\n}\n\nabstract class B extends A {\n  m(b);\n}\n```\n\n**GOOD:**\n```dart\nabstract class A {\n  m(a);\n}\n\nabstract class B extends A {\n  m(a);\n}\n```\n\n"
  },
  {
    "name": "avoid_return_types_on_setters",
    "description": "Avoid return types on setters.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\n**AVOID** return types on setters.\n\nAs setters do not return a value, declaring the return type of one is redundant.\n\n**GOOD:**\n```dart\nset speed(int ms);\n```\n\n**BAD:**\n```dart\nvoid set speed(int ms);\n```\n\n"
  },
  {
    "name": "avoid_returning_null",
    "description": "Avoid returning null from members whose return type is bool, double, int, or num.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\n**AVOID** returning null from members whose return type is bool, double, int,\nor num.\n\nFunctions that return primitive types such as bool, double, int, and num are\ngenerally expected to return non-nullable values.  Thus, returning null where a\nprimitive type was expected can lead to runtime exceptions.\n\n**BAD:**\n```dart\nbool getBool() => null;\nnum getNum() => null;\nint getInt() => null;\ndouble getDouble() => null;\n```\n\n**GOOD:**\n```dart\nbool getBool() => false;\nnum getNum() => -1;\nint getInt() => -1;\ndouble getDouble() => -1.0;\n```\n\n"
  },
  {
    "name": "avoid_returning_null_for_void",
    "description": "Avoid returning null for void.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter"
    ],
    "details": "\n**AVOID** returning null for void.\n\nIn a large variety of languages `void` as return type is used to indicate that\na function doesn't return anything. Dart allows returning `null` in functions\nwith `void` return type but it also allow using `return;` without specifying any\nvalue. To have a consistent way you should not return `null` and only use an\nempty return.\n\n**BAD:**\n```dart\nvoid f1() {\n  return null;\n}\nFuture<void> f2() async {\n  return null;\n}\n```\n\n**GOOD:**\n```dart\nvoid f1() {\n  return;\n}\nFuture<void> f2() async {\n  return;\n}\n```\n\n"
  },
  {
    "name": "avoid_returning_this",
    "description": "Avoid returning this from methods just to enable a fluent interface.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\n**AVOID** returning this from methods just to enable a fluent interface.\n\nReturning `this` from a method is redundant; Dart has a cascade operator which\nallows method chaining universally.\n\nReturning `this` is allowed for:\n\n- operators\n- methods with a return type different of the current class\n- methods defined in parent classes / mixins or interfaces\n- methods defined in extensions\n\n**BAD:**\n```dart\nvar buffer = StringBuffer()\n  .write('one')\n  .write('two')\n  .write('three');\n```\n\n**GOOD:**\n```dart\nvar buffer = StringBuffer()\n  ..write('one')\n  ..write('two')\n  ..write('three');\n```\n\n"
  },
  {
    "name": "avoid_setters_without_getters",
    "description": "Avoid setters without getters.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\n**DON'T** define a setter without a corresponding getter.\n\nDefining a setter without defining a corresponding getter can lead to logical\ninconsistencies.  Doing this could allow you to set a property to some value,\nbut then upon observing the property's value, it could easily be different.\n\n**BAD:**\n```dart\nclass Bad {\n  int l, r;\n\n  set length(int newLength) {\n    r = l + newLength;\n  }\n}\n```\n\n**GOOD:**\n```dart\nclass Good {\n  int l, r;\n\n  int get length => r - l;\n\n  set length(int newLength) {\n    r = l + newLength;\n  }\n}\n```\n\n"
  },
  {
    "name": "avoid_shadowing_type_parameters",
    "description": "Avoid shadowing type parameters.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter",
      "pedantic"
    ],
    "details": "\n**AVOID** shadowing type parameters.\n\n**BAD:**\n```dart\nclass A<T> {\n  void fn<T>() {}\n}\n```\n\n**GOOD:**\n```dart\nclass A<T> {\n  void fn<U>() {}\n}\n```\n\n"
  },
  {
    "name": "avoid_single_cascade_in_expression_statements",
    "description": "Avoid single cascade in expression statements.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic"
    ],
    "details": "\n**AVOID** single cascade in expression statements.\n\n**BAD:**\n```dart\no..m();\n```\n\n**GOOD:**\n```dart\no.m();\n```\n\n"
  },
  {
    "name": "avoid_types_on_closure_parameters",
    "description": "Avoid annotating types for function expression parameters.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\n**AVOID** annotating types for function expression parameters.\n\nAnnotating types for function expression parameters is usually unnecessary\nbecause the parameter types can almost always be inferred from the context,\nthus making the practice redundant.\n\n**BAD:**\n```dart\nvar names = people.map((Person person) => person.name);\n```\n\n**GOOD:**\n```dart\nvar names = people.map((person) => person.name);\n```\n\n"
  },
  {
    "name": "avoid_unnecessary_containers",
    "description": "Avoid unnecessary containers.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "flutter"
    ],
    "details": "Avoid wrapping widgets in unnecessary containers.\n\nWrapping a widget in `Container` with no other parameters set has no effect \nand makes code needlessly more complex.\n\n**BAD:**\n```dart\nWidget buildRow() {\n  return Container(\n      child: Row(\n        children: <Widget>[\n          const MyLogo(),\n          const Expanded(\n            child: Text('...'),\n          ),\n        ],\n      )\n  );\n}\n```\n\n**GOOD:**\n```dart\nWidget buildRow() {\n  return Row(\n    children: <Widget>[\n      const MyLogo(),\n      const Expanded(\n        child: Text('...'),\n      ),\n    ],\n  );\n}\n```\n"
  },
  {
    "name": "avoid_unused_constructor_parameters",
    "description": "Avoid defining unused parameters in constructors.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**AVOID** defining unused parameters in constructors.\n\n**BAD:**\n```dart\nclass BadOne {\n  BadOne(int unusedParameter, [String unusedPositional]);\n}\n\nclass BadTwo {\n  int c;\n\n  BadTwo(int a, int b, int x) {\n    c = a + b;\n  }\n}\n```\n\n"
  },
  {
    "name": "avoid_void_async",
    "description": "Avoid async functions that return void.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** mark async functions to return Future<void>.\n\nWhen declaring an async method or function which does not return a value,\ndeclare that it returns Future<void> and not just void.\n\n**BAD:**\n```dart\nvoid f() async {}\nvoid f2() async => null;\n```\n\n**GOOD:**\n```dart\nFuture<void> f() async {}\nFuture<void> f2() async => null;\n```\n\n"
  },
  {
    "name": "await_only_futures",
    "description": "Await only futures.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter",
      "pedantic"
    ],
    "details": "**AVOID** using await on anything which is not a future.\n\nAwait is allowed on the types: `Future<X>`, `FutureOr<X>`, `Future<X>?`, \n`FutureOr<X>?` and `dynamic`.\n\nFurther, using `await null` is specifically allowed as a way to introduce a\nmicrotask delay.\n\n**BAD:**\n```dart\nmain() async {\n  print(await 23);\n}\n```\n**GOOD:**\n```dart\nmain() async {\n  await null; // If a delay is really intended.\n  print(23);\n}\n```\n"
  },
  {
    "name": "camel_case_extensions",
    "description": "Name extensions using UpperCamelCase.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\nFrom the [style guide](https://dart.dev/guides/language/effective-dart/style/):\n\n**DO** name extensions using `UpperCamelCase`.\n\nExtensions should capitalize the first letter of each word (including\nthe first word), and use no separators.\n\n**GOOD:**\n```dart\nextension MyFancyList<T> on List<T> { \n  // ... \n}\n\nextension SmartIterable<T> on Iterable<T> {\n  // ...\n}\n```\n"
  },
  {
    "name": "camel_case_types",
    "description": "Name types using UpperCamelCase.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter",
      "effective_dart"
    ],
    "details": "\nFrom the [style guide](https://dart.dev/guides/language/effective-dart/style/):\n\n**DO** name types using UpperCamelCase.\n\nClasses and typedefs should capitalize the first letter of each word (including\nthe first word), and use no separators.\n\n**GOOD:**\n```dart\nclass SliderMenu {\n  // ...\n}\n\nclass HttpRequest {\n  // ...\n}\n\ntypedef num Adder(num x, num y);\n```\n\n"
  },
  {
    "name": "cascade_invocations",
    "description": "Cascade consecutive method invocations on the same reference.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** Use the cascading style when succesively invoking methods on the same\nreference.\n\n**BAD:**\n```dart\nSomeClass someReference = SomeClass();\nsomeReference.firstMethod();\nsomeReference.secondMethod();\n```\n\n**BAD:**\n```dart\nSomeClass someReference = SomeClass();\n...\nsomeReference.firstMethod();\nsomeReference.aProperty = value;\nsomeReference.secondMethod();\n```\n\n**GOOD:**\n```dart\nSomeClass someReference = SomeClass()\n    ..firstMethod()\n    ..aProperty = value\n    ..secondMethod();\n```\n\n**GOOD:**\n```dart\nSomeClass someReference = SomeClass();\n...\nsomeReference\n    ..firstMethod()\n    ..aProperty = value\n    ..secondMethod();\n```\n\n"
  },
  {
    "name": "cast_nullable_to_non_nullable",
    "description": "Don't cast a nullable value to a non nullable type.",
    "group": "style",
    "maturity": "experimental",
    "incompatible": [],
    "sets": [],
    "details": "\nDon't cast a nullable value to a non nullable type. This hides a null check\nand most of the time it is not what is expected.\n\n**BAD:**\n```dart\nclass A {}\nclass B extends A {}\n\nA? a;\nvar v = a as B;\nvar v = a as A;\n```\n\n**GOOD:**\n```dart\nclass A {}\nclass B extends A {}\n\nA? a;\nvar v = a! as B;\nvar v = a!;\n```\n\n"
  },
  {
    "name": "constant_identifier_names",
    "description": "Prefer using lowerCamelCase for constant names.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "effective_dart"
    ],
    "details": "\n**PREFER** using lowerCamelCase for constant names.\n\nIn new code, use `lowerCamelCase` for constant variables, including enum values.\n\nIn existing code that uses `ALL_CAPS_WITH_UNDERSCORES` for constants, you may\ncontinue to use all caps to stay consistent.\n\n**GOOD:**\n```dart\nconst pi = 3.14;\nconst defaultTimeout = 1000;\nfinal urlScheme = RegExp('^([a-z]+):');\n\nclass Dice {\n  static final numberGenerator = Random();\n}\n```\n\n**BAD:**\n```dart\nconst PI = 3.14;\nconst kDefaultTimeout = 1000;\nfinal URL_SCHEME = RegExp('^([a-z]+):');\n\nclass Dice {\n  static final NUMBER_GENERATOR = Random();\n}\n\n```\n\n"
  },
  {
    "name": "curly_braces_in_flow_control_structures",
    "description": "DO use curly braces for all flow control structures.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\n**DO** use curly braces for all flow control structures.\n\nDoing so avoids the [dangling else](https://en.wikipedia.org/wiki/Dangling_else)\nproblem.\n\n**GOOD:**\n```dart\nif (isWeekDay) {\n  print('Bike to work!');\n} else {\n  print('Go dancing or read a book!');\n}\n```\n\nThere is one exception to this: an `if` statement with no `else` clause where\nthe entire `if` statement and the then body all fit in one line. In that case,\nyou may leave off the braces if you prefer:\n\n**GOOD:**\n```dart\nif (arg == null) return defaultValue;\n```\n\nIf the body wraps to the next line, though, use braces:\n\n**GOOD:**\n```dart\nif (overflowChars != other.overflowChars) {\n  return overflowChars < other.overflowChars;\n}\n```\n\n**BAD:**\n```dart\nif (overflowChars != other.overflowChars)\n  return overflowChars < other.overflowChars;\n```\n"
  },
  {
    "name": "deprecated_consistency",
    "description": "Missing deprecated annotation.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\nDo apply `@Deprecated()` consistently:\n\n- if a class is deprecated, its constructors should also be deprecated.\n- if a field is deprecated, the constructor parameter pointing to it should also be deprecated.\n- if a constructor parameter pointing to a field is deprecated, the field should also be deprecated.\n\n**BAD:**\n```dart\n@deprecated\nclass A {\n  A();\n}\n\nclass B {\n  B({this.field});\n  @deprecated\n  Object field;\n}\n```\n\n**GOOD:**\n```dart\n@deprecated\nclass A {\n  @deprecated\n  A();\n}\n\nclass B {\n  B({@deprecated this.field});\n  @deprecated\n  Object field;\n}\n```\n\n"
  },
  {
    "name": "directives_ordering",
    "description": "Adhere to Effective Dart Guide directives sorting conventions.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\n**DO** follow the conventions in the \n[Effective Dart Guide](https://dart.dev/guides/language/effective-dart/style#ordering)\n\n**DO** place “dart:” imports before other imports.\n\n**BAD:**\n```dart\nimport 'package:bar/bar.dart';\nimport 'package:foo/foo.dart';\n\nimport 'dart:async';  // LINT\nimport 'dart:html';  // LINT\n```\n\n**BAD:**\n```dart\nimport 'dart:html';  // OK\nimport 'package:bar/bar.dart';\n\nimport 'dart:async';  // LINT\nimport 'package:foo/foo.dart';\n```\n\n**GOOD:**\n```dart\nimport 'dart:async';  // OK\nimport 'dart:html';  // OK\n\nimport 'package:bar/bar.dart';\nimport 'package:foo/foo.dart';\n```\n\n**DO** place “package:” imports before relative imports.\n\n**BAD:**\n```dart\nimport 'a.dart';\nimport 'b.dart';\n\nimport 'package:bar/bar.dart';  // LINT\nimport 'package:foo/foo.dart';  // LINT\n```\n\n**BAD:**\n```dart\nimport 'package:bar/bar.dart';  // OK\nimport 'a.dart';\n\nimport 'package:foo/foo.dart';  // LINT\nimport 'b.dart';\n```\n\n**GOOD:**\n```dart\nimport 'package:bar/bar.dart';  // OK\nimport 'package:foo/foo.dart';  // OK\n\nimport 'a.dart';\nimport 'b.dart';\n```\n\n**DO** specify exports in a separate section after all imports.\n\n**BAD:**\n```dart\nimport 'src/error.dart';\nexport 'src/error.dart'; // LINT\nimport 'src/string_source.dart';\n```\n\n**GOOD:**\n```dart\nimport 'src/error.dart';\nimport 'src/string_source.dart';\n\nexport 'src/error.dart'; // OK\n```\n\n**DO** sort sections alphabetically.\n\n**BAD:**\n```dart\nimport 'package:foo/bar.dart'; // OK\nimport 'package:bar/bar.dart'; // LINT\n\nimport 'a/b.dart'; // OK\nimport 'a.dart'; // LINT\n```\n\n**GOOD:**\n```dart\nimport 'package:bar/bar.dart'; // OK\nimport 'package:foo/bar.dart'; // OK\n\nimport 'a.dart'; // OK\nimport 'a/b.dart'; // OK\n\n"
  },
  {
    "name": "do_not_use_environment",
    "description": "Do not use environment declared variables.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "Using values derived from the environment at compile-time, creates\nhidden global state and makes applications hard to understand and maintain.\n\n**DO NOT** use `fromEnvironment` or `hasEnvironment` factory constructors.\n\n**BAD:**\n```dart\nconst loggingLevel =\n  bool.hasEnvironment('logging') ? String.fromEnvironment('logging') : null;\n```\n"
  },
  {
    "name": "empty_catches",
    "description": "Avoid empty catch blocks.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter",
      "pedantic"
    ],
    "details": "\n**AVOID** empty catch blocks.\n\nIn general, empty catch blocks should be avoided.  In cases where they are\nintended, a comment should be provided to explain why exceptions are being\ncaught and suppressed.  Alternatively, the exception identifier can be named with\nunderscores (e.g., `_`) to indicate that we intend to skip it.\n\n**BAD:**\n```dart\ntry {\n  ...\n} catch(exception) { }\n```\n\n**GOOD:**\n```dart\ntry {\n  ...\n} catch(e) {\n  // ignored, really.\n}\n\n// Alternatively:\ntry {\n  ...\n} catch(_) { }\n\n// Better still:\ntry {\n  ...\n} catch(e) {\n  doSomething(e);\n}\n```\n\n"
  },
  {
    "name": "empty_constructor_bodies",
    "description": "Use `;` instead of `{}` for empty constructor bodies.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\nFrom the [style guide](https://dart.dev/guides/language/effective-dart/style/):\n\n**DO** use `;` instead of `{}` for empty constructor bodies.\n\nIn Dart, a constructor with an empty body can be terminated with just a\nsemicolon.  This is required for const constructors.  For consistency and\nbrevity, other constructors should also do this.\n\n**GOOD:**\n```dart\nclass Point {\n  int x, y;\n  Point(this.x, this.y);\n}\n```\n\n**BAD:**\n```dart\nclass Point {\n  int x, y;\n  Point(this.x, this.y) {}\n}\n```\n\n"
  },
  {
    "name": "exhaustive_cases",
    "description": "Define case clauses for all constants in enum-like classes.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter"
    ],
    "details": "Switching on instances of enum-like classes should be exhaustive.\n\nEnum-like classes are defined as concrete (non-abstract) classes that have:\n  * only private non-factory constructors\n  * two or more static const fields whose type is the enclosing class and\n  * no subclasses of the class in the defining library\n\n**DO** define case clauses for all constants in enum-like classes.\n\n**BAD:**\n```dart\nclass EnumLike {\n  final int i;\n  const E._(this.i);\n\n  static const e = E._(1);\n  static const f = E._(2);\n  static const g = E._(3);\n}\n\nvoid bad(EnumLike e) {\n  // Missing case.\n  switch(e) { // LINT\n    case E.e :\n      print('e');\n      break;\n    case E.f :\n      print('e');\n      break;\n  }\n}\n```\n\n**GOOD:**\n```dart\nclass EnumLike {\n  final int i;\n  const E._(this.i);\n\n  static const e = E._(1);\n  static const f = E._(2);\n  static const g = E._(3);\n}\n\nvoid ok(E e) {\n  // All cases covered.\n  switch(e) { // OK\n    case E.e :\n      print('e');\n      break;\n    case E.f :\n      print('e');\n      break;\n    case E.g :\n      print('e');\n      break;\n  }\n}\n```\n"
  },
  {
    "name": "file_names",
    "description": "Name source files using `lowercase_with_underscores`.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter",
      "effective_dart"
    ],
    "details": "\n**DO** name source files using `lowercase_with_underscores`.\n\nSome file systems are not case-sensitive, so many projects require filenames to\nbe all lowercase. Using a separating character allows names to still be readable\nin that form. Using underscores as the separator ensures that the name is still\na valid Dart identifier, which may be helpful if the language later supports\nsymbolic imports.\n\n**GOOD:**\n\n* `slider_menu.dart`\n* `file_system.dart`\n\n**BAD:**\n\n* `SliderMenu.dart`\n* `filesystem.dart`\n* `file-system.dart`\n\nFiles without a strict `.dart` extension are ignored.  For example:\n\n**OK:**\n\n* `file-system.g.dart`\n* `SliderMenu.css.dart`\n\nThe lint `library_names` can be used to enforce the same kind of naming on the\nlibrary.\n\n"
  },
  {
    "name": "flutter_style_todos",
    "description": "Use Flutter TODO format: // TODO(username): message, https://URL-to-issue.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** Use Flutter TODO format.\n\nFrom the [Flutter docs](https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#comments):\n\n> TODOs should include the string TODO in all caps, followed by the GitHub username of the person with the best context about the problem referenced by the TODO in parenthesis. A TODO is not a commitment that the person referenced will fix the problem, it is intended to be the person with enough context to explain the problem. Thus, when you create a TODO, it is almost always your username that is given.\n\n**GOOD:**\n```dart\n// TODO(username): message.\n// TODO(username): message, https://URL-to-issue.\n```\n\n"
  },
  {
    "name": "implementation_imports",
    "description": "Don't import implementation files from another package.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "effective_dart"
    ],
    "details": "\nFrom the the [pub package layout doc](https://dart.dev/tools/pub/package-layout#implementation-files):\n\n**DON'T** import implementation files from another package.\n\nThe libraries inside `lib` are publicly visible: other packages are free to\nimport them.  But much of a package's code is internal implementation libraries\nthat should only be imported and used by the package itself.  Those go inside a\nsubdirectory of `lib` called `src`.  You can create subdirectories in there if\nit helps you organize things.\n\nYou are free to import libraries that live in `lib/src` from within other Dart\ncode in the same package (like other libraries in `lib`, scripts in `bin`,\nand tests) but you should never import from another package's `lib/src`\ndirectory.  Those files are not part of the package's public API, and they\nmight change in ways that could break your code.\n\n**BAD:**\n```dart\n// In 'road_runner'\nimport 'package:acme/lib/src/internals.dart;\n```\n\n"
  },
  {
    "name": "join_return_with_assignment",
    "description": "Join return statement with assignment when possible.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** join return statement with assignment when possible.\n\n**BAD:**\n```dart\nclass A {\n  B _lazyInstance;\n  static B get instance {\n    _lazyInstance ??= B(); // LINT\n    return _lazyInstance;\n  }\n}\n```\n\n**GOOD:**\n```dart\nclass A {\n  B _lazyInstance;\n  static B get instance => _lazyInstance ??= B();\n}\n```\n\n"
  },
  {
    "name": "leading_newlines_in_multiline_strings",
    "description": "Start multiline strings with a newline.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "Multiline strings are easier to read when they start with a newline (a newline\nstarting a multiline string is ignored).\n\n**BAD:**\n```dart\nvar s1 = '''{\n  \"a\": 1,\n  \"b\": 2\n}''';\n```\n\n**GOOD:**\n```dart\nvar s1 = '''\n{\n  \"a\": 1,\n  \"b\": 2\n}''';\n\nvar s2 = '''This onliner multiline string is ok. It usually allows to escape both ' and \" in the string.''';\n```\n\n"
  },
  {
    "name": "library_names",
    "description": "Name libraries using `lowercase_with_underscores`.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\n**DO** name libraries using `lowercase_with_underscores`.\n\nSome file systems are not case-sensitive, so many projects require filenames to\nbe all lowercase. Using a separating character allows names to still be readable\nin that form. Using underscores as the separator ensures that the name is still\na valid Dart identifier, which may be helpful if the language later supports\nsymbolic imports.\n\n**GOOD:**\n```dart\nlibrary peg_parser;\n```\n\n**BAD:**\n```dart\nlibrary peg-parser;\n```\n\nThe lint `file_names` can be used to enforce the same kind of naming on the\nfile.\n\n"
  },
  {
    "name": "library_prefixes",
    "description": "Use `lowercase_with_underscores` when specifying a library prefix.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\n**DO** use `lowercase_with_underscores` when specifying a library prefix.\n\n**GOOD:**\n```dart\nimport 'dart:math' as math;\nimport 'dart:json' as json;\nimport 'package:js/js.dart' as js;\nimport 'package:javascript_utils/javascript_utils.dart' as js_utils;\n```\n\n**BAD:**\n```dart\nimport 'dart:math' as Math;\nimport 'dart:json' as JSON;\nimport 'package:js/js.dart' as JS;\nimport 'package:javascript_utils/javascript_utils.dart' as jsUtils;\n```\n\n"
  },
  {
    "name": "library_private_types_in_public_api",
    "description": "Avoid using private types in public APIs.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**AVOID** using library private types in public APIs.\n\nFor the purposes of this lint, a public API is considered to be any top-level or\nmember declaration unless the declaration is library private or contained in a\ndeclaration that's library private. The following uses of types are checked:\n\n- the return type of a function or method,\n- the type of any parameter of a function or method,\n- the bound of a type parameter to any function, method, class, mixin,\n  extension's extended type, or type alias,\n- the type of any top level variable or field,\n- any type used in the declaration of a type alias (for example\n  `typedef F = _Private Function();`), or\n- any type used in the `on` clause of an extension or a mixin\n\n**GOOD:**\n```dart\nf(String s) { ... }\n```\n\n**BAD:**\n```dart\nf(_Private p) { ... }\nclass _Private {}\n```\n\n"
  },
  {
    "name": "lines_longer_than_80_chars",
    "description": "Avoid lines longer than 80 characters.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\n**AVOID** lines longer than 80 characters\n\nReadability studies show that long lines of text are harder to read because your\neye has to travel farther when moving to the beginning of the next line. This is\nwhy newspapers and magazines use multiple columns of text.\n\nIf you really find yourself wanting lines longer than 80 characters, our\nexperience is that your code is likely too verbose and could be a little more\ncompact. The main offender is usually `VeryLongCamelCaseClassNames`. Ask\nyourself, “Does each word in that type name tell me something critical or\nprevent a name collision?” If not, consider omitting it.\n\nNote that `dart format` does 99% of this for you, but the last 1% is you. It \ndoes not split long string literals to fit in 80 columns, so you have to do \nthat manually.\n\nWe make an exception for URIs and file paths. When those occur in comments or\nstrings (usually in imports and exports), they may remain on a single line even\nif they go over the line limit. This makes it easier to search source files for\na given path.\n"
  },
  {
    "name": "missing_whitespace_between_adjacent_strings",
    "description": "Missing whitespace between adjacent strings.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\nAdd a trailing whitespace to prevent missing whitespace between adjacent\nstrings.\n\nWith long text split accross adjacent strings it's easy to forget a whitespace\nbetween strings.\n\n**BAD:**\n```dart\nvar s =\n  'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed'\n  'do eiusmod tempor incididunt ut labore et dolore magna';\n```\n\n**GOOD:**\n```dart\nvar s =\n  'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed '\n  'do eiusmod tempor incididunt ut labore et dolore magna';\n```\n\n"
  },
  {
    "name": "no_default_cases",
    "description": "No default cases.",
    "group": "style",
    "maturity": "experimental",
    "incompatible": [],
    "sets": [],
    "details": "Switches on enums and enum-like classes should not use a `default` clause.\n\nEnum-like classes are defined as concrete (non-abstract) classes that have:\n  * only private non-factory constructors\n  * two or more static const fields whose type is the enclosing class and\n  * no subclasses of the class in the defining library\n\n**DO** define default behavior outside switch statements.\n\n**GOOD:**\n```dart\n  switch (testEnum) {\n    case TestEnum.A:\n      return '123';\n    case TestEnum.B:\n      return 'abc';\n  }\n  // Default here.\n  return null;\n```\n\n**BAD:**\n```dart\n  switch (testEnum) {\n    case TestEnum.A:\n      return '123';\n    case TestEnum.B:\n      return 'abc';\n    default:\n      return null;\n  }\n```\n"
  },
  {
    "name": "no_runtimeType_toString",
    "description": "Avoid calling toString() on runtimeType.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\nCalling `toString` on a runtime type is a non-trivial operation that can\nnegatively impact performance. It's better to avoid it.\n\n**BAD:**\n```dart\nclass A {\n  String toString() => '$runtimeType()';\n}\n```\n\n**GOOD:**\n```dart\nclass A {\n  String toString() => 'A()';\n}\n```\n\nThis lint has some exceptions where performance is not a problem or where real\ntype information is more important than performance:\n\n* in assertion\n* in throw expressions\n* in catch clauses\n* in mixin declaration\n* in abstract class\n\n"
  },
  {
    "name": "non_constant_identifier_names",
    "description": "Name non-constant identifiers using lowerCamelCase.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter",
      "effective_dart"
    ],
    "details": "\n**DO** name non-constant identifiers using lowerCamelCase.\n\nClass members, top-level definitions, variables, parameters, named parameters\nand named constructors should capitalize the first letter of each word\nexcept the first word, and use no separators.\n\n**GOOD:**\n```dart\nvar item;\n\nHttpRequest httpRequest;\n\nalign(clearItems) {\n  // ...\n}\n```\n\n"
  },
  {
    "name": "noop_primitive_operations",
    "description": "Noop primitive operations.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\nSome operations on primitive types are idempotent and can be removed.\n\n**BAD:**\n\n```dart\ndoubleValue.toDouble();\n\nintValue.toInt();\nintValue.round();\nintValue.ceil();\nintValue.floor();\nintValue.truncate();\n\nstring.toString();\nstring = 'hello\\n'\n    'world\\n'\n    ''; // useless empty string\n```\n"
  },
  {
    "name": "null_check_on_nullable_type_parameter",
    "description": "Don't use null check on a potentially nullable type parameter.",
    "group": "style",
    "maturity": "experimental",
    "incompatible": [],
    "sets": [],
    "details": "\nDon't use null check on a potentially nullable type parameter.\n\nGiven a generic type parameter `T` which has a nullable bound (e.g. the default\nbound of `Object?`), it is very easy to introduce erroneous null checks when\nworking with a variable of type `T?`. Specifically, it is not uncommon to have\n`T? x;` and want to assert that `x` has been set to a valid value of type `T`.\nA common mistake is to do so using `x!`. This is almost always incorrect, since\nif `T` is a nullable type, `x` may validly hold `null` as a value of type `T`.\n\n**BAD:**\n```dart\nT run<T>(T callback()) {\n  T? result;\n   (() { result = callback(); })();\n  return result!;\n}\n```\n\n**GOOD:**\n```dart\nT run<T>(T callback()) {\n  T? result;\n   (() { result = callback(); })();\n  return result as T;\n}\n```\n\n"
  },
  {
    "name": "null_closures",
    "description": "Do not pass `null` as an argument where a closure is expected.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic"
    ],
    "details": "\n**DO NOT** pass null as an argument where a closure is expected.\n\nOften a closure that is passed to a method will only be called conditionally,\nso that tests and \"happy path\" production calls do not reveal that `null` will\nresult in an exception being thrown.\n\nThis rule only catches null literals being passed where closures are expected\nin the following locations:\n\n#### Constructors\n\n* From `dart:async`\n  * `Future` at the 0th positional parameter\n  * `Future.microtask` at the 0th positional parameter\n  * `Future.sync` at the 0th positional parameter\n  * `Timer` at the 0th positional parameter\n  * `Timer.periodic` at the 1st positional parameter\n* From `dart:core`\n  * `List.generate` at the 1st positional parameter\n\n#### Static functions\n\n* From `dart:async`\n  * `scheduleMicrotask` at the 0th positional parameter\n  * `Future.doWhile` at the 0th positional parameter\n  * `Future.forEach` at the 0th positional parameter\n  * `Future.wait` at the named parameter `cleanup`\n  * `Timer.run` at the 0th positional parameter\n\n#### Instance methods\n\n* From `dart:async`\n  * `Future.then` at the 0th positional parameter\n  * `Future.complete` at the 0th positional parameter\n* From `dart:collection`\n  * `Queue.removeWhere` at the 0th positional parameter\n  * `Queue.retain\n  * `Iterable.firstWhere` at the 0th positional parameter, and the named\n    parameter `orElse`\n  * `Iterable.forEach` at the 0th positional parameter\n  * `Iterable.fold` at the 1st positional parameter\n  * `Iterable.lastWhere` at the 0th positional parameter, and the named\n    parameter `orElse`\n  * `Iterable.map` at the 0th positional parameter\n  * `Iterable.reduce` at the 0th positional parameter\n  * `Iterable.singleWhere` at the 0th positional parameter, and the named\n    parameter `orElse`\n  * `Iterable.skipWhile` at the 0th positional parameter\n  * `Iterable.takeWhile` at the 0th positional parameter\n  * `Iterable.where` at the 0th positional parameter\n  * `List.removeWhere` at the 0th positional parameter\n  * `List.retainWhere` at the 0th positional parameter\n  * `String.replaceAllMapped` at the 1st positional parameter\n  * `String.replaceFirstMapped` at the 1st positional parameter\n  * `String.splitMapJoin` at the named parameters `onMatch` and `onNonMatch`\n\n**BAD:**\n```dart\n[1, 3, 5].firstWhere((e) => e.isOdd, orElse: null);\n```\n\n**GOOD:**\n```dart\n[1, 3, 5].firstWhere((e) => e.isOdd, orElse: () => null);\n```\n\n"
  },
  {
    "name": "omit_local_variable_types",
    "description": "Omit type annotations for local variables.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [
      "always_specify_types"
    ],
    "sets": [
      "pedantic",
      "effective_dart"
    ],
    "details": "\n**CONSIDER** omitting type annotations for local variables.\n\nUsually, the types of local variables can be easily inferred, so it isn't\nnecessary to annotate them.\n\n**BAD:**\n```dart\nMap<int, List<Person>> groupByZip(Iterable<Person> people) {\n  Map<int, List<Person>> peopleByZip = <int, List<Person>>{};\n  for (Person person in people) {\n    peopleByZip.putIfAbsent(person.zip, () => <Person>[]);\n    peopleByZip[person.zip].add(person);\n  }\n  return peopleByZip;\n}\n```\n\n**GOOD:**\n```dart\nMap<int, List<Person>> groupByZip(Iterable<Person> people) {\n  var peopleByZip = <int, List<Person>>{};\n  for (var person in people) {\n    peopleByZip.putIfAbsent(person.zip, () => <Person>[]);\n    peopleByZip[person.zip].add(person);\n  }\n  return peopleByZip;\n}\n```\n\n"
  },
  {
    "name": "one_member_abstracts",
    "description": "Avoid defining a one-member abstract class when a simple function will do.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\nFrom the [style guide](https://dart.dev/guides/language/effective-dart/style/):\n\n**AVOID** defining a one-member abstract class when a simple function will do.\n\nUnlike Java, Dart has first-class functions, closures, and a nice light syntax\nfor using them.  If all you need is something like a callback, just use a\nfunction.  If you're defining a class and it only has a single abstract member\nwith a meaningless name like `call` or `invoke`, there is a good chance\nyou just want a function.\n\n**GOOD:**\n```dart\ntypedef Predicate = bool Function(item);\n```\n\n**BAD:**\n```dart\nabstract class Predicate {\n  bool test(item);\n}\n```\n\n"
  },
  {
    "name": "only_throw_errors",
    "description": "Only throw instances of classes extending either Exception or Error.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** throw only instances of classes that extend `dart.core.Error` or\n`dart.core.Exception`.\n\nThrowing instances that do not extend `Error` or `Exception` is a bad practice;\ndoing this is usually a hack for something that should be implemented more\nthoroughly.\n\n**BAD:**\n```dart\nvoid throwString() {\n  throw 'hello world!'; // LINT\n}\n```\n\n**GOOD:**\n```dart\nvoid throwArgumentError() {\n  Error error = ArgumentError('oh!');\n  throw error; // OK\n}\n```\n\n"
  },
  {
    "name": "overridden_fields",
    "description": "Don't override fields.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter"
    ],
    "details": "\n**DON'T** override fields.\n\nOverriding fields is almost always done unintentionally.  Regardless, it is a\nbad practice to do so.\n\n**BAD:**\n```dart\nclass Base {\n  Object field = 'lorem';\n\n  Object something = 'change';\n}\n\nclass Bad1 extends Base {\n  @override\n  final field = 'ipsum'; // LINT\n}\n\nclass Bad2 extends Base {\n  @override\n  Object something = 'done'; // LINT\n}\n```\n\n**GOOD:**\n```dart\nclass Base {\n  Object field = 'lorem';\n\n  Object something = 'change';\n}\n\nclass Ok extends Base {\n  Object newField; // OK\n\n  final Object newFinal = 'ignore'; // OK\n}\n```\n\n**GOOD:**\n```dart\nabstract class BaseLoggingHandler {\n  Base transformer;\n}\n\nclass LogPrintHandler implements BaseLoggingHandler {\n  @override\n  Derived transformer; // OK\n}\n```\n\n"
  },
  {
    "name": "package_api_docs",
    "description": "Provide doc comments for all public APIs.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\n**DO** provide doc comments for all public APIs.\n\nAs described in the [pub package layout doc](https://dart.dev/tools/pub/package-layout#implementation-files),\npublic APIs consist in everything in your package's `lib` folder, minus\nimplementation files in `lib/src`, adding elements explicitly exported with an\n`export` directive.\n\nFor example, given `lib/foo.dart`:\n```dart\nexport 'src/bar.dart' show Bar;\nexport 'src/baz.dart';\n\nclass Foo { }\n\nclass _Foo { }\n```\nits API includes:\n\n* `Foo` (but not `_Foo`)\n* `Bar` (exported) and\n* all *public* elements in `src/baz.dart`\n\nAll public API members should be documented with `///` doc-style comments.\n\n**GOOD:**\n```dart\n/// A Foo.\nabstract class Foo {\n  /// Start foo-ing.\n  void start() => _start();\n\n  _start();\n}\n```\n\n**BAD:**\n```dart\nclass Bar {\n  void bar();\n}\n```\n\nAdvice for writing good doc comments can be found in the\n[Doc Writing Guidelines](https://dart.dev/guides/language/effective-dart/documentation).\n\n"
  },
  {
    "name": "package_prefixed_library_names",
    "description": "Prefix library names with the package name and a dot-separated path.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter"
    ],
    "details": "\n**DO** prefix library names with the package name and a dot-separated path.\n\nThis guideline helps avoid the warnings you get when two libraries have the same\nname.  Here are the rules we recommend:\n\n* Prefix all library names with the package name.\n* Make the entry library have the same name as the package.\n* For all other libraries in a package, after the package name add the\ndot-separated path to the library's Dart file.\n* For libraries under `lib`, omit the top directory name.\n\nFor example, say the package name is `my_package`.  Here are the library names\nfor various files in the package:\n\n**GOOD:**\n```dart\n// In lib/my_package.dart\nlibrary my_package;\n\n// In lib/other.dart\nlibrary my_package.other;\n\n// In lib/foo/bar.dart\nlibrary my_package.foo.bar;\n\n// In example/foo/bar.dart\nlibrary my_package.example.foo.bar;\n\n// In lib/src/private.dart\nlibrary my_package.src.private;\n```\n\n"
  },
  {
    "name": "parameter_assignments",
    "description": "Don't reassign references to parameters of functions or methods.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DON'T** assign new values to parameters of methods or functions.\n\nAssigning new values to parameters is generally a bad practice unless an\noperator such as `??=` is used.  Otherwise, arbitrarily reassigning parameters\nis usually a mistake.\n\n**BAD:**\n```dart\nvoid badFunction(int parameter) { // LINT\n  parameter = 4;\n}\n```\n\n**BAD:**\n```dart\nvoid badFunction(int required, {int optional: 42}) { // LINT\n  optional ??= 8;\n}\n```\n\n**BAD:**\n```dart\nvoid badFunctionPositional(int required, [int optional = 42]) { // LINT\n  optional ??= 8;\n}\n```\n\n**BAD:**\n```dart\nclass A {\n    void badMethod(int parameter) { // LINT\n    parameter = 4;\n  }\n}\n```\n\n**GOOD:**\n```dart\nvoid ok(String parameter) {\n  print(parameter);\n}\n```\n\n**GOOD:**\n```dart\nvoid actuallyGood(int required, {int optional}) { // OK\n  optional ??= ...;\n}\n```\n\n**GOOD:**\n```dart\nvoid actuallyGoodPositional(int required, [int optional]) { // OK\n  optional ??= ...;\n}\n```\n\n**GOOD:**\n```dart\nclass A {\n  void ok(String parameter) {\n    print(parameter);\n  }\n}\n```\n\n"
  },
  {
    "name": "prefer_adjacent_string_concatenation",
    "description": "Use adjacent strings to concatenate string literals.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\n**DO** use adjacent strings to concatenate string literals.\n\n**BAD:**\n```dart\nraiseAlarm(\n    'ERROR: Parts of the spaceship are on fire. Other ' +\n    'parts are overrun by martians. Unclear which are which.');\n```\n\n**GOOD:**\n```dart\nraiseAlarm(\n    'ERROR: Parts of the spaceship are on fire. Other '\n    'parts are overrun by martians. Unclear which are which.');\n```\n\n"
  },
  {
    "name": "prefer_asserts_in_initializer_lists",
    "description": "Prefer putting asserts in initializer list.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "**DO** put asserts in initializer list for constructors with only asserts in\ntheir body.\n\n**GOOD:**\n```dart\nclass A {\n  A(int a) : assert(a != null);\n}\n```\n\n**BAD:**\n```dart\nclass A {\n  A(int a) {\n    assert(a != null);\n  }\n}\n```\n\n"
  },
  {
    "name": "prefer_asserts_with_message",
    "description": "Prefer asserts with message.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\nWhen assertions fail it's not always simple to understand why. Adding a message\nto the `assert` helps the developer to understand why the AssertionError occurs.\n\n**BAD:**\n```dart\nf(a) {\n  assert(a != null);\n}\n\nclass A {\n  A(a) : assert(a != null);\n}\n```\n\n**GOOD:**\n```dart\nf(a) {\n  assert(a != null, 'a must not be null');\n}\n\nclass A {\n  A(a) : assert(a != null, 'a must not be null');\n}\n```\n\n"
  },
  {
    "name": "prefer_bool_in_asserts",
    "description": "Prefer using a boolean as the assert condition.",
    "group": "style",
    "maturity": "deprecated",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** use a boolean for assert conditions.\n\nNot using booleans in assert conditions can lead to code where it isn't clear\nwhat the intention of the assert statement is.\n\n**BAD:**\n```dart\nassert(() {\n  f();\n  return true;\n});\n```\n\n**GOOD:**\n```dart\nassert(() {\n  f();\n  return true;\n}());\n```\n\n**DEPRECATED:** In Dart 2, `assert`s no longer accept  non-`bool` values so this\nrule is made redundant by the Dart analyzer's basic checks and is no longer\nnecessary.\n \nThe rule will be removed in a future Linter release.\n"
  },
  {
    "name": "prefer_collection_literals",
    "description": "Use collection literals when possible.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\n**DO** use collection literals when possible.\n\n**BAD:**\n```dart\nvar points = List();\nvar addresses = Map();\nvar uniqueNames = Set();\nvar ids = LinkedHashSet();\nvar coordinates = LinkedHashMap();\n```\n\n**GOOD:**\n```dart\nvar points = [];\nvar addresses = <String,String>{};\nvar uniqueNames = <String>{};\nvar ids = <int>{};\nvar coordinates = <int,int>{};\n```\n\n**EXCEPTIONS:**\n\nThere are cases with `LinkedHashSet` or `LinkedHashMap` where a literal constructor\nwill trigger a type error so those will be excluded from the lint.\n\n```dart\nvoid main() {\n  LinkedHashSet<int> linkedHashSet =  LinkedHashSet.from([1, 2, 3]); // OK\n  LinkedHashMap linkedHashMap = LinkedHashMap(); // OK\n  \n  printSet(LinkedHashSet<int>()); // LINT\n  printHashSet(LinkedHashSet<int>()); // OK\n\n  printMap(LinkedHashMap<int, int>()); // LINT\n  printHashMap(LinkedHashMap<int, int>()); // OK\n}\n\nvoid printSet(Set<int> ids) => print('$ids!');\nvoid printHashSet(LinkedHashSet<int> ids) => printSet(ids);\nvoid printMap(Map map) => print('$map!');\nvoid printHashMap(LinkedHashMap map) => printMap(map);\n```\n"
  },
  {
    "name": "prefer_conditional_assignment",
    "description": "Prefer using `??=` over testing for null.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic"
    ],
    "details": "\n**PREFER** using `??=` over testing for null.\n\nAs Dart has the `??=` operator, it is advisable to use it where applicable to\nimprove the brevity of your code.\n\n**BAD:**\n```dart\nString get fullName {\n  if (_fullName == null) {\n    _fullName = getFullUserName(this);\n  }\n  return _fullName;\n}\n```\n\n**GOOD:**\n```dart\nString get fullName {\n  return _fullName ??= getFullUserName(this);\n}\n```\n\n"
  },
  {
    "name": "prefer_const_constructors",
    "description": "Prefer const with constant constructors.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "flutter"
    ],
    "details": "\n**PREFER** using `const` for instantiating constant constructors.\n\nIf a const constructor is available, it is preferable to use it.\n\n**GOOD:**\n```dart\nclass A {\n  const A();\n}\n\nvoid accessA() {\n  A a = const A();\n}\n```\n\n**GOOD:**\n```dart\nclass A {\n  final int x;\n\n  const A(this.x);\n}\n\nA foo(int x) => new A(x);\n```\n\n**BAD:**\n```dart\nclass A {\n  const A();\n}\n\nvoid accessA() {\n  A a = new A();\n}\n```\n\n"
  },
  {
    "name": "prefer_const_constructors_in_immutables",
    "description": "Prefer declaring const constructors on `@immutable` classes.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "flutter"
    ],
    "details": "\n**PREFER** declaring const constructors on `@immutable` classes.\n\nIf a class is immutable, it is usually a good idea to make its constructor a\nconst constructor.\n\n**GOOD:**\n```dart\n@immutable\nclass A {\n  final a;\n  const A(this.a);\n}\n```\n\n**BAD:**\n```dart\n@immutable\nclass A {\n  final a;\n  A(this.a);\n}\n```\n\n"
  },
  {
    "name": "prefer_const_declarations",
    "description": "Prefer const over final for declarations.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "flutter"
    ],
    "details": "\n**PREFER** using `const` for const declarations.\n\nConst declarations are more hot-reload friendly and allow to use const\nconstructors if an instantiation references this declaration.\n\n**GOOD:**\n```dart\nconst o = <int>[];\n\nclass A {\n  static const o = <int>[];\n}\n```\n\n**BAD:**\n```dart\nfinal o = const <int>[];\n\nclass A {\n  static final o = const <int>[];\n}\n```\n\n"
  },
  {
    "name": "prefer_const_literals_to_create_immutables",
    "description": "Prefer const literals as parameters of constructors on @immutable classes.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "flutter"
    ],
    "details": "\n**PREFER** using `const` for instantiating list, map and set literals used as\nparameters in immutable class instantiations.\n\n**BAD:**\n```dart\n@immutable\nclass A {\n  A(this.v);\n  final v;\n}\n\nA a1 = new A([1]);\nA a2 = new A({});\n```\n\n**GOOD:**\n```dart\nA a1 = new A(const [1]);\nA a2 = new A(const {});\n```\n\n"
  },
  {
    "name": "prefer_constructors_over_static_methods",
    "description": "Prefer defining constructors instead of static methods to create instances.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**PREFER** defining constructors instead of static methods to create instances.\n\nIn most cases, it makes more sense to use a named constructor rather than a\nstatic method because it makes instantiation clearer.\n\n**BAD:**\n```dart\nclass Point {\n  num x, y;\n  Point(this.x, this.y);\n  static Point polar(num theta, num radius) {\n    return Point(radius * math.cos(theta),\n        radius * math.sin(theta));\n  }\n}\n```\n\n**GOOD:**\n```dart\nclass Point {\n  num x, y;\n  Point(this.x, this.y);\n  Point.polar(num theta, num radius)\n      : x = radius * math.cos(theta),\n        y = radius * math.sin(theta);\n}\n```\n"
  },
  {
    "name": "prefer_contains",
    "description": "Use contains for `List` and `String` instances.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic"
    ],
    "details": "\n**DON'T** use `indexOf` to see if a collection contains an element.\n\nCalling `indexOf` to see if a collection contains something is difficult to read\nand may have poor performance.\n\nInstead, prefer `contains`.\n\n**GOOD:**\n```dart\nif (!lunchBox.contains('sandwich')) return 'so hungry...';\n```\n\n**BAD:**\n```dart\nif (lunchBox.indexOf('sandwich')) == -1 return 'so hungry...';\n```\n\n"
  },
  {
    "name": "prefer_double_quotes",
    "description": "Prefer double quotes where they won't require escape sequences.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [
      "prefer_single_quotes"
    ],
    "sets": [],
    "details": "\n**DO** use double quotes where they wouldn't require additional escapes.\n\nThat means strings with a double quote may use apostrophes so that the double\nquote isn't escaped (note: we don't lint the other way around, ie, a double\nquoted string with an escaped double quote is not flagged).\n\nIt's also rare, but possible, to have strings within string interpolations.  In\nthis case, its much more readable to use a single quote somewhere.  So single\nquotes are allowed either within, or containing, an interpolated string literal.\nArguably strings within string interpolations should be its own type of lint.\n\n**BAD:**\n```dart\nuseStrings(\n    'should be double quote',\n    r'should be double quote',\n    r'''should be double quotes''')\n```\n\n**GOOD:**\n```dart\nuseStrings(\n    \"should be double quote\",\n    r\"should be double quote\",\n    r\"\"\"should be double quotes\"\"\",\n    'ok with \" inside',\n    'nested ${a ? \"strings\" : \"can\"} be wrapped by a double quote',\n    \"and nested ${a ? 'strings' : 'can be double quoted themselves'}\");\n```\n\n"
  },
  {
    "name": "prefer_equal_for_default_values",
    "description": "Use `=` to separate a named parameter from its default value.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\nFrom the [style guide](https://dart.dev/guides/language/effective-dart/usage):\n\n**DO** Use `=` to separate a named parameter from its default value.\n\n**BAD:**\n```dart\nm({a: 1})\n```\n\n**GOOD:**\n```dart\nm({a = 1})\n```\n\n"
  },
  {
    "name": "prefer_expression_function_bodies",
    "description": "Use => for short members whose body is a single return statement.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**CONSIDER** using => for short members whose body is a single return statement.\n\n**BAD:**\n```dart\nget width {\n  return right - left;\n}\n```\n\n**BAD:**\n```dart\nbool ready(num time) {\n  return minTime == null || minTime <= time;\n}\n```\n\n**BAD:**\n```dart\ncontainsValue(String value) {\n  return getValues().contains(value);\n}\n```\n\n**GOOD:**\n```dart\nget width => right - left;\n```\n\n**GOOD:**\n```dart\nbool ready(num time) => minTime == null || minTime <= time;\n```\n\n**GOOD:**\n```dart\ncontainsValue(String value) => getValues().contains(value);\n```\n\n"
  },
  {
    "name": "prefer_final_fields",
    "description": "Private field could be final.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\n**DO** prefer declaring private fields as final if they are not reassigned later\nin the library.\n\nDeclaring fields as final when possible is a good practice because it helps\navoid accidental reassignments and allows the compiler to do optimizations.\n\n**BAD:**\n```dart\nclass BadImmutable {\n  var _label = 'hola mundo! BadImmutable'; // LINT\n  var label = 'hola mundo! BadImmutable'; // OK\n}\n```\n\n**BAD:**\n```dart\nclass MultipleMutable {\n  var _label = 'hola mundo! GoodMutable', _offender = 'mumble mumble!'; // LINT\n  var _someOther; // LINT\n\n  MultipleMutable() : _someOther = 5;\n\n  MultipleMutable(this._someOther);\n\n  void changeLabel() {\n    _label= 'hello world! GoodMutable';\n  }\n}\n```\n\n**GOOD:**\n```dart\nclass GoodImmutable {\n  final label = 'hola mundo! BadImmutable', bla = 5; // OK\n  final _label = 'hola mundo! BadImmutable', _bla = 5; // OK\n}\n```\n\n**GOOD:**\n```dart\nclass GoodMutable {\n  var _label = 'hola mundo! GoodMutable';\n\n  void changeLabel() {\n    _label = 'hello world! GoodMutable';\n  }\n}\n```\n\n**BAD:**\n```dart\nclass AssignedInAllConstructors {\n  var _label; // LINT\n  AssignedInAllConstructors(this._label);\n  AssignedInAllConstructors.withDefault() : _label = 'Hello';\n}\n```\n\n**GOOD:**\n```dart\nclass NotAssignedInAllConstructors {\n  var _label; // OK\n  NotAssignedInAllConstructors();\n  NotAssignedInAllConstructors.withDefault() : _label = 'Hello';\n}\n```\n"
  },
  {
    "name": "prefer_final_in_for_each",
    "description": "Prefer final in for-each loop variable if reference is not reassigned.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** prefer declaring for-each loop variables as final if they are not\nreassigned later in the code.\n\nDeclaring for-each loop variables as final when possible is a good practice\nbecause it helps avoid accidental reassignments and allows the compiler to do\noptimizations.\n\n**BAD:**\n```dart\nfor (var element in elements) { // LINT\n  print('Element: $element');\n}\n```\n\n**GOOD:**\n```dart\nfor (final element in elements) {\n  print('Element: $element');\n}\n```\n\n**GOOD:**\n```dart\nfor (var element in elements) {\n  element = element + element;\n  print('Element: $element');\n}\n```\n\n"
  },
  {
    "name": "prefer_final_locals",
    "description": "Prefer final for variable declarations if they are not reassigned.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [
      "unnecessary_final"
    ],
    "sets": [],
    "details": "\n**DO** prefer declaring variables as final if they are not reassigned later in\nthe code.\n\nDeclaring variables as final when possible is a good practice because it helps\navoid accidental reassignments and allows the compiler to do optimizations.\n\n**BAD:**\n```dart\nvoid badMethod() {\n  var label = 'hola mundo! badMethod'; // LINT\n  print(label);\n}\n```\n\n**GOOD:**\n```dart\nvoid goodMethod() {\n  final label = 'hola mundo! goodMethod';\n  print(label);\n}\n```\n\n**GOOD:**\n```dart\nvoid mutableCase() {\n  var label = 'hola mundo! mutableCase';\n  print(label);\n  label = 'hello world';\n  print(label);\n}\n```\n\n"
  },
  {
    "name": "prefer_final_parameters",
    "description": "Prefer final for parameter declarations if they are not reassigned.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [
      "unnecessary_final"
    ],
    "sets": [],
    "details": "\n**DO** prefer declaring parameters as final if they are not reassigned in\nthe function body.\n\nDeclaring parameters as final when possible is a good practice because it helps\navoid accidental reassignments.\n\n**BAD:**\n```dart\nvoid badParameter(String label) { // LINT\n  print(label);\n}\n```\n\n**GOOD:**\n```dart\nvoid goodParameter(final String label) { // OK\n  print(label);\n}\n```\n\n**BAD:**\n```dart\nvoid badExpression(int value) => print(value); // LINT\n```\n\n**GOOD:**\n```dart\nvoid goodExpression(final int value) => print(value); // OK\n```\n\n**BAD:**\n```dart\n[1, 4, 6, 8].forEach((value) => print(value + 2)); // LINT\n```\n\n**GOOD:**\n```dart\n[1, 4, 6, 8].forEach((final value) => print(value + 2)); // OK\n```\n\n**GOOD:**\n```dart\nvoid mutableParameter(String label) { // OK\n  print(label);\n  label = 'Hello Linter!';\n  print(label);\n}\n```\n\n"
  },
  {
    "name": "prefer_for_elements_to_map_fromIterable",
    "description": "Prefer for elements when building maps from iterables.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic"
    ],
    "details": "When building maps from iterables, it is preferable to use for elements.\n\n**BAD:**\n```dart\nMap<String, WidgetBuilder>.fromIterable(\n  kAllGalleryDemos,\n  key: (demo) => '${demo.routeName}',\n  value: (demo) => demo.buildRoute,\n);\n\n```\n\n**GOOD:**\n```dart\nreturn {\n  for (var demo in kAllGalleryDemos)\n    '${demo.routeName}': demo.buildRoute,\n};\n```\n"
  },
  {
    "name": "prefer_foreach",
    "description": "Use `forEach` to only apply a function to all the elements.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** use `forEach` if you are only going to apply a function or a method\nto all the elements of an iterable.\n\nUsing `forEach` when you are only going to apply a function or method to all\nelements of an iterable is a good practice because it makes your code more\nterse.\n\n**BAD:**\n```dart\nfor (final key in map.keys.toList()) {\n  map.remove(key);\n}\n```\n\n**GOOD:**\n```dart\nmap.keys.toList().forEach(map.remove);\n```\n\n**NOTE:** Replacing a for each statement with a forEach call may change the \nbehavior in the case where there are side-effects on the iterable itself.\n```dart\nfor (final v in myList) {\n  foo().f(v); // This code invokes foo() many times.\n}\n\nmyList.forEach(foo().f); // But this one invokes foo() just once.\n```\n\n"
  },
  {
    "name": "prefer_function_declarations_over_variables",
    "description": "Use a function declaration to bind a function to a name.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "effective_dart"
    ],
    "details": "\n**DO** use a function declaration to bind a function to a name.\n\nAs Dart allows local function declarations, it is a good practice to use them in\nthe place of function literals.\n\n**BAD:**\n```dart\nvoid main() {\n  var localFunction = () {\n    ...\n  };\n}\n```\n\n**GOOD:**\n```dart\nvoid main() {\n  localFunction() {\n    ...\n  }\n}\n```\n\n"
  },
  {
    "name": "prefer_generic_function_type_aliases",
    "description": "Prefer generic function type aliases.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\n**PREFER** generic function type aliases.\n\nWith the introduction of generic functions, function type aliases\n(`typedef void F()`) couldn't express all of the possible kinds of\nparameterization that users might want to express. Generic function type aliases\n(`typedef F = void Function()`) fixed that issue.\n\nFor consistency and readability reasons, it's better to only use one syntax and\nthus prefer generic function type aliases.\n\n**BAD:**\n```dart\ntypedef void F();\n```\n\n**GOOD:**\n```dart\ntypedef F = void Function();\n```\n\n"
  },
  {
    "name": "prefer_if_elements_to_conditional_expressions",
    "description": "Prefer if elements to conditional expressions where possible.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "When building collections, it is preferable to use `if` elements rather than\nconditionals.\n\n**BAD:**\n```dart\nWidget build(BuildContext context) {\n  return Row(\n    children: [\n      IconButton(icon: Icon(Icons.menu)),\n      Expanded(child: title),\n      isAndroid ? IconButton(icon: Icon(Icons.search)) : null,\n    ].where((child) => child != null).toList(),\n  );\n}\n```\n\n**GOOD:**\n```dart\nWidget build(BuildContext context) {\n  return Row(\n    children: [\n      IconButton(icon: Icon(Icons.menu)),\n      Expanded(child: title),\n      if (isAndroid) IconButton(icon: Icon(Icons.search)),\n    ]\n  );\n}\n"
  },
  {
    "name": "prefer_if_null_operators",
    "description": "Prefer using if null operators.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic"
    ],
    "details": "\nPrefer using if null operators instead of null checks in conditional\nexpressions.\n\n**BAD:**\n```dart\nv = a == null ? b : a;\n```\n\n**GOOD:**\n```dart\nv = a ?? b;\n```\n\n"
  },
  {
    "name": "prefer_initializing_formals",
    "description": "Use initializing formals when possible.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "effective_dart"
    ],
    "details": "\n**DO** use initializing formals when possible.\n\nUsing initializing formals when possible makes your code more terse.\n\n**BAD:**\n```dart\nclass Point {\n  num x, y;\n  Point(num x, num y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n```\n\n**GOOD:**\n```dart\nclass Point {\n  num x, y;\n  Point(this.x, this.y);\n}\n```\n\n**BAD:**\n```dart\nclass Point {\n  num x, y;\n  Point({num x, num y}) {\n    this.x = x;\n    this.y = y;\n  }\n}\n```\n\n**GOOD:**\n```dart\nclass Point {\n  num x, y;\n  Point({this.x, this.y});\n}\n```\n\n**NOTE**\nThis rule will not generate a lint for named parameters unless the parameter\nname and the field name are the same. The reason for this is that resolving\nsuch a lint would require either renaming the field or renaming the parameter,\nand both of those actions would potentially be a breaking change. For example,\nthe following will not generate a lint:\n\n```dart\nclass Point {\n  bool isEnabled;\n  Point({bool enabled}) {\n    this.isEnabled = enable; // OK\n  }\n}\n```\n\n"
  },
  {
    "name": "prefer_inlined_adds",
    "description": "Inline list item declarations where possible.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic"
    ],
    "details": "Declare elements in list literals inline, rather than using `add` and \n`addAll` methods where possible.\n\n\n**BAD:**\n```dart\nvar l = ['a']..add('b')..add('c');\nvar l2 = ['a']..addAll(['b', 'c'])\n```\n\n**GOOD:**\n```dart\nvar l = ['a', 'b', 'c'];\nvar 2 = ['a', 'b', 'c'];\n```\n"
  },
  {
    "name": "prefer_int_literals",
    "description": "Prefer int literals over double literals.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** use int literals rather than the corresponding double literal.\n\n**BAD:**\n```dart\nconst double myDouble = 8.0;\nfinal anotherDouble = myDouble + 7.0e2;\nmain() {\n  someMethod(6.0);\n}\n```\n\n**GOOD:**\n```dart\nconst double myDouble = 8;\nfinal anotherDouble = myDouble + 700;\nmain() {\n  someMethod(6);\n}\n```\n\n"
  },
  {
    "name": "prefer_interpolation_to_compose_strings",
    "description": "Use interpolation to compose strings and values.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\n**PREFER** using interpolation to compose strings and values.\n\nUsing interpolation when composing strings and values is usually easier to write\nand read than concatenation.\n\n**BAD:**\n```dart\n'Hello, ' + name + '! You are ' + (year - birth) + ' years old.';\n```\n\n**GOOD:**\n```dart\n'Hello, $name! You are ${year - birth} years old.';\n```\n\n"
  },
  {
    "name": "prefer_is_empty",
    "description": "Use `isEmpty` for Iterables and Maps.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\n**DON'T** use `length` to see if a collection is empty.\n\nThe `Iterable` contract does not require that a collection know its length or be\nable to provide it in constant time.  Calling `length` just to see if the\ncollection contains anything can be painfully slow.\n\nInstead, there are faster and more readable getters: `isEmpty` and\n`isNotEmpty`.  Use the one that doesn't require you to negate the result.\n\n**GOOD:**\n```dart\nif (lunchBox.isEmpty) return 'so hungry...';\nif (words.isNotEmpty) return words.join(' ');\n```\n\n**BAD:**\n```dart\nif (lunchBox.length == 0) return 'so hungry...';\nif (words.length != 0) return words.join(' ');\n```\n\n"
  },
  {
    "name": "prefer_is_not_empty",
    "description": "Use `isNotEmpty` for Iterables and Maps.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\n**PREFER** `x.isNotEmpty` to `!x.isEmpty` for `Iterable` and `Map` instances.\n\nWhen testing whether an iterable or map is empty, prefer `isNotEmpty` over\n`!isEmpty` to improve code readability.\n\n**GOOD:**\n```dart\nif (todo.isNotEmpty) {\n  sendResults(request, todo.isEmpty);\n}\n```\n\n**BAD:**\n```dart\nif (!sources.isEmpty) {\n  process(sources);\n}\n```\n\n"
  },
  {
    "name": "prefer_is_not_operator",
    "description": "Prefer is! operator.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter"
    ],
    "details": "When checking if an object is not of a specified type, it is preferable to use the 'is!' operator.\n\n**BAD:**\n```dart\nif (!(foo is Foo)) {\n  ...\n}\n```\n\n**GOOD:**\n```dart\nif (foo is! Foo) {\n  ...\n}\n```\n\n"
  },
  {
    "name": "prefer_iterable_whereType",
    "description": "Prefer to use whereType on iterable.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\n**PREFER** `iterable.whereType<T>()` over `iterable.where((e) => e is T)`.\n\n**BAD:**\n```dart\niterable.where((e) => e is MyClass)\n```\n\n**GOOD:**\n```dart\niterable.whereType<MyClass>()\n```\n\n"
  },
  {
    "name": "prefer_mixin",
    "description": "Prefer using mixins.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\nDart 2.1 introduced a new syntax for mixins that provides a safe way for a mixin\nto invoke inherited members using `super`. The new style of mixins should always\nbe used for types that are to be mixed in. As a result, this lint will flag any\nuses of a class in a `with` clause.\n\n**BAD:**\n```dart\nclass A {}\nclass B extends Object with A {}\n```\n\n**OK:**\n```dart\nmixin M {}\nclass C with M {}\n```\n\n"
  },
  {
    "name": "prefer_null_aware_method_calls",
    "description": "Prefer null aware method calls.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\nInstead of checking nullability of a function/method `f` before calling it you\ncan use `f?.call()`.\n\n**BAD:**\n```dart\nif (f != null) f!();\n```\n\n**GOOD:**\n```dart\nf?.call();\n```\n\n"
  },
  {
    "name": "prefer_null_aware_operators",
    "description": "Prefer using null aware operators.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter"
    ],
    "details": "\nPrefer using null aware operators instead of null checks in conditional\nexpressions.\n\n**BAD:**\n```dart\nv = a == null ? null : a.b;\n```\n\n**GOOD:**\n```dart\nv = a?.b;\n```\n\n"
  },
  {
    "name": "prefer_single_quotes",
    "description": "Only use double quotes for strings containing single quotes.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [
      "prefer_double_quotes"
    ],
    "sets": [
      "pedantic"
    ],
    "details": "\n**DO** use single quotes where they wouldn't require additional escapes.\n\nThat means strings with an apostrophe may use double quotes so that the\napostrophe isn't escaped (note: we don't lint the other way around, ie, a single\nquoted string with an escaped apostrophe is not flagged).\n\nIt's also rare, but possible, to have strings within string interpolations.  In\nthis case, its much more readable to use a double quote somewhere.  So double\nquotes are allowed either within, or containing, an interpolated string literal.\nArguably strings within string interpolations should be its own type of lint.\n\n**BAD:**\n```dart\nuseStrings(\n    \"should be single quote\",\n    r\"should be single quote\",\n    r\"\"\"should be single quotes\"\"\")\n```\n\n**GOOD:**\n```dart\nuseStrings(\n    'should be single quote',\n    r'should be single quote',\n    r'''should be single quotes''',\n    \"here's ok\",\n    \"nested ${a ? 'strings' : 'can'} be wrapped by a double quote\",\n    'and nested ${a ? \"strings\" : \"can be double quoted themselves\"}');\n```\n\n"
  },
  {
    "name": "prefer_spread_collections",
    "description": "Use spread collections when possible.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic"
    ],
    "details": "\nUse spread collections when possible.\n\nCollection literals are excellent when you want to create a new collection out \nof individual items. But, when existing items are already stored in another \ncollection, spread collection syntax leads to simpler code.\n\n**BAD:**\n\n```dart\nWidget build(BuildContext context) {\n  return CupertinoPageScaffold(\n    child: ListView(\n      children: [\n        Tab2Header(),\n      ]..addAll(buildTab2Conversation()),\n    ),\n  );\n}\n```\n\n```dart\nvar ints = [1, 2, 3];\nprint(['a']..addAll(ints.map((i) => i.toString()))..addAll(['c']));\n```\n\n```dart\nvar things;\nvar l = ['a']..addAll(things ?? const []);\n```\n\n\n**GOOD:**\n\n```dart\nWidget build(BuildContext context) {\n  return CupertinoPageScaffold(\n    child: ListView(\n      children: [\n        Tab2Header(),\n        ...buildTab2Conversation(),\n      ],\n    ),\n  );\n}\n```\n\n```dart\nvar ints = [1, 2, 3];\nprint(['a', ...ints.map((i) => i.toString()), 'c');\n```\n\n```dart\nvar things;\nvar l = ['a', ...?things];\n```\n"
  },
  {
    "name": "prefer_typing_uninitialized_variables",
    "description": "Prefer typing uninitialized variables and fields.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter"
    ],
    "details": "\n**PREFER** specifying a type annotation for uninitialized variables and fields.\n\nForgoing type annotations for uninitialized variables is a bad practice because\nyou may accidentally assign them to a type that you didn't originally intend to.\n\n**BAD:**\n```dart\nclass BadClass {\n  static var bar; // LINT\n  var foo; // LINT\n\n  void method() {\n    var bar; // LINT\n    bar = 5;\n    print(bar);\n  }\n}\n```\n\n**BAD:**\n```dart\nvoid aFunction() {\n  var bar; // LINT\n  bar = 5;\n  ...\n}\n```\n\n**GOOD:**\n```dart\nclass GoodClass {\n  static var bar = 7;\n  var foo = 42;\n  int baz; // OK\n\n  void method() {\n    int baz;\n    var bar = 5;\n    ...\n  }\n}\n```\n\n"
  },
  {
    "name": "provide_deprecation_message",
    "description": "Provide a deprecation message, via @Deprecated(\"message\").",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter"
    ],
    "details": "\n**DO** specify a deprecation message (with migration instructions and/or a\nremoval schedule) in the Deprecation constructor.\n\n**BAD:**\n```dart\n@deprecated\nvoid oldFunction(arg1, arg2) {}\n```\n\n**GOOD:**\n```dart\n@Deprecated(\"\"\"\n[oldFunction] is being deprecated in favor of [newFunction] (with slightly\ndifferent parameters; see [newFunction] for more information). [oldFunction]\nwill be removed on or after the 4.0.0 release.\n\"\"\")\nvoid oldFunction(arg1, arg2) {}\n```\n\n"
  },
  {
    "name": "public_member_api_docs",
    "description": "Document all public members.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\n**DO** document all public members.\n\nAll non-overriding public members should be documented with `///` doc-style\ncomments.\n\n**GOOD:**\n```dart\n/// A good thing.\nabstract class Good {\n  /// Start doing your thing.\n  void start() => _start();\n\n  _start();\n}\n```\n\n**BAD:**\n```dart\nclass Bad {\n  void meh() { }\n}\n```\n\nIn case a public member overrides a member it is up to the declaring member\nto provide documentation.  For example, in the following, `Sub` needn't\ndocument `init` (though it certainly may, if there's need).\n\n**GOOD:**\n```dart\n/// Base of all things.\nabstract class Base {\n  /// Initialize the base.\n  void init();\n}\n\n/// A sub base.\nclass Sub extends Base {\n  @override\n  void init() { ... }\n}\n```\n\nNote that consistent with `dartdoc`, an exception to the rule is made when\ndocumented getters have corresponding undocumented setters.  In this case the\nsetters inherit the docs from the getters.\n\n"
  },
  {
    "name": "recursive_getters",
    "description": "Property getter recursively returns itself.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic"
    ],
    "details": "\n**DON'T** create recursive getters.\n\nRecursive getters are getters which return themselves as a value.  This is\nusually a typo.\n\n**BAD:**\n```dart\nint get field => field; // LINT\n```\n\n**BAD:**\n```dart\nint get otherField {\n  return otherField; // LINT\n}\n```\n\n**GOOD:**\n```dart\nint get field => _field;\n```\n\n"
  },
  {
    "name": "require_trailing_commas",
    "description": "Use trailing commas for all function calls and declarations.",
    "group": "style",
    "maturity": "experimental",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** use trailing commas for all function calls and declarations unless the\nfunction call or definition, from the start of the function name up to the\nclosing parenthesis, fits in a single line.\n\n**GOOD:**\n```dart\nvoid run() {\n  method(\n    'does not fit on one line',\n    'test test test test test test test test test test test',\n  );\n}\n```\n\n**BAD:**\n```dart\nvoid run() {\n  method('does not fit on one line',\n      'test test test test test test test test test test test');\n}\n```\n\n**Exception:** If the final parameter/argument is positional (vs named) and is\neither a function literal implemented using curly braces, a literal map, a\nliteral set or a literal array. This exception only applies if the final\nparameter does not fit entirely on one line.\n\n**Note:** This lint rule assumes `dartfmt` has been run over the code and may\nproduce false positives until that has happened.\n\n"
  },
  {
    "name": "sized_box_for_whitespace",
    "description": "SizedBox for whitespace.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "flutter"
    ],
    "details": "Use SizedBox to add whitespace to a layout.\n\nA `Container` is a heavier Widget than a `SizedBox`, and as bonus, `SizedBox`\nhas a `const` constructor.\n\n**BAD:**\n```dart\nWidget buildRow() {\n  return Row(\n    children: <Widget>[\n      const MyLogo(),\n      Container(width: 4),\n      const Expanded(\n        child: Text('...'),\n      ),\n    ],\n  );\n}\n```\n\n**GOOD:**\n```dart\nWidget buildRow() {\n  return Row(\n    children: const <Widget>[\n      MyLogo(),\n      SizedBox(width: 4),\n      Expanded(\n        child: Text('...'),\n      ),\n    ],\n  );\n}\n```\n"
  },
  {
    "name": "slash_for_doc_comments",
    "description": "Prefer using /// for doc comments.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\nFrom the [style guide](https://dart.dev/guides/language/effective-dart/style):\n\n**PREFER** using `///` for doc comments.\n\nAlthough Dart supports two syntaxes of doc comments (`///` and `/**`), we\nprefer using `///` for doc comments.\n\n**GOOD:**\n```dart\n/// Parses a set of option strings. For each option:\n///\n/// * If it is `null`, then it is ignored.\n/// * If it is a string, then [validate] is called on it.\n/// * If it is any other type, it is *not* validated.\nvoid parse(List options) {\n  // ...\n}\n```\n\nWithin a doc comment, you can use markdown for formatting.\n\n"
  },
  {
    "name": "sort_child_properties_last",
    "description": "Sort child properties last in widget instance creations.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "pedantic"
    ],
    "details": "Sort child properties last in widget instance creations.  This improves\nreadability and plays nicest with UI as Code visualization in IDEs with UI as\nCode Guides in editors (such as IntelliJ) where Properties in the correct order\nappear clearly associated with the constructor call and separated from the\nchildren.\n\n**BAD:**\n```dart\nreturn Scaffold(\n  appBar: AppBar(\n    title: Text(widget.title),\n  ),\n  body: Center(\n    child: Column(\n      children: <Widget>[\n        Text(\n          'You have pushed the button this many times:',\n         ),\n        Text(\n          '$_counter',\n          style: Theme.of(context).textTheme.display1,\n         ),\n      ],\n      mainAxisAlignment: MainAxisAlignment.center,\n    ),\n    widthFactor: 0.5,\n  ),\n  floatingActionButton: FloatingActionButton(\n    child: Icon(Icons.add),\n    onPressed: _incrementCounter,\n    tooltip: 'Increment',\n  ),\n);\n```\n\n**GOOD:**\n```dart\nreturn Scaffold(\n  appBar: AppBar(\n    title: Text(widget.title),\n  ),\n  body: Center(\n    widthFactor: 0.5,\n    child: Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: <Widget>[\n        Text(\n          'You have pushed the button this many times:',\n         ),\n        Text(\n          '$_counter',\n          style: Theme.of(context).textTheme.display1,\n         ),\n      ],\n    ),\n  ),\n  floatingActionButton: FloatingActionButton(\n    onPressed: _incrementCounter,\n    tooltip: 'Increment',\n    child: Icon(Icons.add),\n  ),\n);\n```\n\nException: It's allowed to have parameter with a function expression after the\n`child` property.\n\n"
  },
  {
    "name": "sort_constructors_first",
    "description": "Sort constructor declarations before other members.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** sort constructor declarations before other members.\n\n**GOOD:**\n```dart\nabstract class Animation<T> {\n  const Animation(this.value);\n  double value;\n  void addListener(VoidCallback listener);\n}\n```\n\n**BAD:**\n```dart\nabstract class Visitor {\n  double value;\n  visitSomething(Something s);\n  Visitor();\n}\n```\n\n"
  },
  {
    "name": "sort_unnamed_constructors_first",
    "description": "Sort unnamed constructor declarations first.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** sort unnamed constructor declarations first, before named ones.\n\n**GOOD:**\n```dart\nabstract class CancelableFuture<T> implements Future<T>  {\n  factory CancelableFuture(computation()) => ...\n  factory CancelableFuture.delayed(Duration duration, [computation()]) => ...\n  ...\n}\n```\n\n**BAD:**\n```dart\nclass _PriorityItem {\n  factory _PriorityItem.forName(bool isStatic, String name, _MemberKind kind) => ...\n  _PriorityItem(this.isStatic, this.kind, this.isPrivate);\n  ...\n}\n```\n\n"
  },
  {
    "name": "super_goes_last",
    "description": "Place the `super` call last in a constructor initialization list.",
    "group": "style",
    "maturity": "deprecated",
    "incompatible": [],
    "sets": [],
    "details": "\nFrom the [style guide](https://dart.dev/guides/language/effective-dart/style/):\n\n**DO** place the `super` call last in a constructor initialization list.\n\nField initializers are evaluated in the order that they appear in the\nconstructor initialization list.  If you place a `super()` call in the middle of\nan initializer list, the superclass's initializers will be evaluated right then\nbefore evaluating the rest of the subclass's initializers.\n\nWhat it doesn't mean is that the superclass's constructor body will be executed\nthen.  That always happens after all initializers are run regardless of where\n`super` appears.  It's vanishingly rare that the order of initializers matters,\nso the placement of `super` in the list almost never matters either.\n\nGetting in the habit of placing it last improves consistency, visually\nreinforces when the superclass's constructor body is run, and may help\nperformance.\n\n**GOOD:**\n```dart\nView(Style style, List children)\n    : _children = children,\n      super(style) {\n```\n\n**BAD:**\n```dart\nView(Style style, List children)\n    : super(style),\n      _children = children {\n```\n\n**DEPRECATED:** In Dart 2, it is a compile-time error if a superinitializer\nappears in an initializer list at any other position than at the end so this\nrule is made redundant by the Dart analyzer's basic checks and is no longer\nnecessary.\n \nThe rule will be removed in a future Linter release.\n"
  },
  {
    "name": "tighten_type_of_initializing_formals",
    "description": "Tighten type of initializing formal.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\nTighten type of initializing formal if a non-null assert exists. This allows the\ntype system to catch problems rather than have them only be caught at run-time.\n\n**BAD:**\n```dart\nclass A {\n  A.c1(this.p) : assert(p != null);\n  A.c2(this.p);\n  final String? p;\n}\n```\n\n**GOOD:**\n```dart\nclass A {\n  A.c1(String this.p) : assert(p != null);\n  A.c2(this.p);\n  final String? p;\n}\n```\n\n"
  },
  {
    "name": "type_annotate_public_apis",
    "description": "Type annotate public APIs.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\nFrom [effective dart](https://dart.dev/guides/language/effective-dart/design#prefer-type-annotating-public-fields-and-top-level-variables-if-the-type-isnt-obvious):\n\n**PREFER** type annotating public APIs.\n\nType annotations are important documentation for how a library should be used.\nAnnotating the parameter and return types of public methods and functions helps\nusers understand what the API expects and what it provides.\n\nNote that if a public API accepts a range of values that Dart's type system\ncannot express, then it is acceptable to leave that untyped.  In that case, the\nimplicit `dynamic` is the correct type for the API.\n\nFor code internal to a library (either private, or things like nested functions)\nannotate where you feel it helps, but don't feel that you *must* provide them.\n\n**BAD:**\n```dart\ninstall(id, destination) {\n  // ...\n}\n```\n\nHere, it's unclear what `id` is.  A string? And what is `destination`? A string\nor a `File` object? Is this method synchronous or asynchronous?\n\n**GOOD:**\n```dart\nFuture<bool> install(PackageId id, String destination) {\n  // ...\n}\n```\n\nWith types, all of this is clarified.\n\n"
  },
  {
    "name": "type_init_formals",
    "description": "Don't type annotate initializing formals.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\nFrom the [style guide](https://dart.dev/guides/language/effective-dart/style/):\n\n**DON'T** type annotate initializing formals.\n\nIf a constructor parameter is using `this.x` to initialize a field, then the\ntype of the parameter is understood to be the same type as the field.\n\n**GOOD:**\n```dart\nclass Point {\n  int x, y;\n  Point(this.x, this.y);\n}\n```\n\n**BAD:**\n```dart\nclass Point {\n  int x, y;\n  Point(int this.x, int this.y);\n}\n```\n\n"
  },
  {
    "name": "unawaited_futures",
    "description": "`Future` results in `async` function bodies must be `await`ed or marked `unawaited` using `package:pedantic`.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "pedantic"
    ],
    "details": "\n**DO** await functions that return a `Future` inside of an async function body.\n\nIt's easy to forget await in async methods as naming conventions usually don't\ntell us if a method is sync or async (except for some in `dart:io`).\n\nWhen you really _do_ want to start a fire-and-forget `Future`, the recommended\nway is to use `unawaited` from `package:pedantic`. The `// ignore` and\n`// ignore_for_file` comments also work.\n\n**GOOD:**\n```dart\nFuture doSomething() => ...;\n\nvoid main() async {\n  await doSomething();\n\n  unawaited(doSomething()); // Explicitly-ignored fire-and-forget.\n}\n```\n\n**BAD:**\n```dart\nvoid main() async {\n  doSomething(); // Likely a bug.\n}\n```\n\n"
  },
  {
    "name": "unnecessary_await_in_return",
    "description": "Unnecessary await keyword in return.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\nAvoid returning an awaited expression when the expression type is assignable to\nthe function's return type.\n\n\n**BAD:**\n```dart\nFuture<int> future;\nFuture<int> f1() async => await future;\nFuture<int> f2() async {\n  return await future;\n}\n```\n\n**GOOD:**\n```dart\nFuture<int> future;\nFuture<int> f1() => future;\nFuture<int> f2() {\n  return future;\n}\n```\n\n"
  },
  {
    "name": "unnecessary_brace_in_string_interps",
    "description": "Avoid using braces in interpolation when not needed.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\n**AVOID** using braces in interpolation when not needed.\n\nIf you're just interpolating a simple identifier, and it's not immediately\nfollowed by more alphanumeric text, the `{}` can and should be omitted.\n\n**GOOD:**\n```dart\nprint(\"Hi, $name!\");\n```\n\n**BAD:**\n```dart\nprint(\"Hi, ${name}!\");\n```\n\n"
  },
  {
    "name": "unnecessary_const",
    "description": "Avoid const keyword.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\n**AVOID** repeating const keyword in a const context.\n\n**BAD:**\n```dart\nclass A { const A(); }\nm(){\n  const a = const A();\n  final b = const [const A()];\n}\n```\n\n**GOOD:**\n```dart\nclass A { const A(); }\nm(){\n  const a = A();\n  final b = const [A()];\n}\n```\n\n"
  },
  {
    "name": "unnecessary_final",
    "description": "Don't use `final` for local variables.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [
      "prefer_final_locals",
      "prefer_final_parameters"
    ],
    "sets": [],
    "details": "**DON'T** use `final` for local variables.\n\n`var` is shorter, and `final` does not change the meaning of the code.\n\n**BAD:**\n```dart\nvoid badMethod() {\n  final label = 'Final or var?';\n  for (final char in ['v', 'a', 'r']) {\n    print(char);\n  }\n}\n```\n\n**GOOD:**\n```dart\nvoid goodMethod() {\n  var label = 'Final or var?';\n  for (var char in ['v', 'a', 'r']) {\n    print(char);\n  }\n}\n```\n"
  },
  {
    "name": "unnecessary_getters_setters",
    "description": "Avoid wrapping fields in getters and setters just to be \"safe\".",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\nFrom the [style guide](https://dart.dev/guides/language/effective-dart/style/):\n\n**AVOID** wrapping fields in getters and setters just to be \"safe\".\n\nIn Java and C#, it's common to hide all fields behind getters and setters (or\nproperties in C#), even if the implementation just forwards to the field.  That\nway, if you ever need to do more work in those members, you can do it without needing\nto touch the callsites.  This is because calling a getter method is different\nthan accessing a field in Java, and accessing a property isn't binary-compatible\nwith accessing a raw field in C#.\n\nDart doesn't have this limitation.  Fields and getters/setters are completely\nindistinguishable.  You can expose a field in a class and later wrap it in a\ngetter and setter without having to touch any code that uses that field.\n\n**GOOD:**\n\n```dart\nclass Box {\n  var contents;\n}\n```\n\n**BAD:**\n\n```dart\nclass Box {\n  var _contents;\n  get contents => _contents;\n  set contents(value) {\n    _contents = value;\n  }\n}\n```\n\n"
  },
  {
    "name": "unnecessary_lambdas",
    "description": "Don't create a lambda when a tear-off will do.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\n**DON'T** create a lambda when a tear-off will do.\n\n**BAD:**\n```dart\nnames.forEach((name) {\n  print(name);\n});\n```\n\n**GOOD:**\n```dart\nnames.forEach(print);\n```\n\n"
  },
  {
    "name": "unnecessary_new",
    "description": "Unnecessary new keyword.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\n**AVOID** new keyword to create instances.\n\n**BAD:**\n```dart\nclass A { A(); }\nm(){\n  final a = new A();\n}\n```\n\n**GOOD:**\n```dart\nclass A { A(); }\nm(){\n  final a = A();\n}\n```\n\n"
  },
  {
    "name": "unnecessary_null_aware_assignments",
    "description": "Avoid null in null-aware assignment.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**AVOID** `null` in null-aware assignment.\n\nUsing `null` on the right-hand side of a null-aware assignment effectively makes\nthe assignment redundant.\n\n**GOOD:**\n```dart\nvar x;\nx ??= 1;\n```\n\n**BAD:**\n```dart\nvar x;\nx ??= null;\n```\n\n"
  },
  {
    "name": "unnecessary_null_checks",
    "description": "Unnecessary null checks.",
    "group": "style",
    "maturity": "experimental",
    "incompatible": [],
    "sets": [],
    "details": "\nDon't apply a null check when a nullable value is accepted.\n\n**BAD:**\n```dart\nf(int? i);\nm() {\n  int? j;\n  f(j!);\n}\n\n```\n\n**GOOD:**\n```dart\nf(int? i);\nm() {\n  int? j;\n  f(j);\n}\n```\n\n"
  },
  {
    "name": "unnecessary_null_in_if_null_operators",
    "description": "Avoid using `null` in `if null` operators.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic"
    ],
    "details": "\n**AVOID** using `null` as an operand in `if null` operators.\n\nUsing `null` in an `if null` operator is redundant, regardless of which side\n`null` is used on.\n\n**GOOD:**\n```dart\nvar x = a ?? 1;\n```\n\n**BAD:**\n```dart\nvar x = a ?? null;\nvar y = null ?? 1;\n```\n\n"
  },
  {
    "name": "unnecessary_nullable_for_final_variable_declarations",
    "description": "Use a non-nullable type for a final variable initialized with a non-nullable value.",
    "group": "style",
    "maturity": "experimental",
    "incompatible": [],
    "sets": [],
    "details": "\nUse a non-nullable type for a final variable initialized with a non-nullable\nvalue.\n\n**BAD:**\n```dart\nfinal int? i = 1;\n```\n\n**GOOD:**\n```dart\nfinal int i = 1;\n```\n\n"
  },
  {
    "name": "unnecessary_overrides",
    "description": "Don't override a method to do a super method invocation with the same parameters.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter"
    ],
    "details": "\n**DON'T** override a method to do a super method invocation with same parameters.\n\n**BAD:**\n```dart\nclass A extends B {\n  @override\n  void foo() {\n    super.foo();\n  }\n}\n```\n\n**GOOD:**\n```dart\nclass A extends B {\n  @override\n  void foo() {\n    doSomethingElse();\n  }\n}\n```\n\nIt's valid to override a member in the following cases:\n\n* if a type (return type or a parameter type) is not the exactly the same as the\nsuper method,\n* if the `covariant` keyword is added to one of the parameters,\n* if documentation comments are present on the member,\n* if the member has annotations other than `@override`.\n\n`noSuchMethod` is a special method and is not checked by this rule.\n\n"
  },
  {
    "name": "unnecessary_parenthesis",
    "description": "Unnecessary parenthesis can be removed.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**AVOID** using parenthesis when not needed.\n\n**GOOD:**\n```dart\na = b;\n```\n\n**BAD:**\n```dart\na = (b);\n```\n\n"
  },
  {
    "name": "unnecessary_raw_strings",
    "description": "Unnecessary raw string.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\nUse raw string only when needed.\n\n**BAD:**\n```dart\nvar s1 = r'a';\n```\n\n**GOOD:**\n```dart\nvar s1 = 'a';\nvar s2 = r'$a';\nvar s3 = r'\\a';\n```\n\n"
  },
  {
    "name": "unnecessary_string_escapes",
    "description": "Remove unnecessary backslashes in strings.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter"
    ],
    "details": "\nRemove unnecessary backslashes in strings.\n\n**BAD:**\n```dart\n'this string contains 2 \\\"double quotes\\\" ';\n\"this string contains 2 \\'single quotes\\' \";\n```\n\n**GOOD:**\n```dart\n'this string contains 2 \"double quotes\" ';\n\"this string contains 2 'single quotes' \";\n```\n\n"
  },
  {
    "name": "unnecessary_string_interpolations",
    "description": "Unnecessary string interpolation.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter"
    ],
    "details": "\nDon't use string interpolation if there's only a string expression in it.\n\n**BAD:**\n```dart\nString message;\nString o = '$message';\n```\n\n**GOOD:**\n```dart\nString message;\nString o = message;\n```\n\n"
  },
  {
    "name": "unnecessary_this",
    "description": "Don't access members with `this` unless avoiding shadowing.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\nFrom the [style guide](https://dart.dev/guides/language/effective-dart/style/):\n\n**DON'T** use `this` when not needed to avoid shadowing.\n\n**BAD:**\n```dart\nclass Box {\n  var value;\n  void update(new_value) {\n    this.value = new_value;\n  }\n}\n```\n\n**GOOD:**\n```dart\nclass Box {\n  var value;\n  void update(new_value) {\n    value = new_value;\n  }\n}\n```\n\n**GOOD:**\n```dart\nclass Box {\n  var value;\n  void update(value) {\n    this.value = value;\n  }\n}\n```\n\n"
  },
  {
    "name": "use_full_hex_values_for_flutter_colors",
    "description": "Prefer an 8-digit hexadecimal integer(0xFFFFFFFF) to instantiate Color.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "flutter",
      "pedantic"
    ],
    "details": "\nPrefer an 8-digit hexadecimal integer(0xFFFFFFFF) to instantiate Color. Colors\nhave four 8-bit channels, which adds up to 32 bits, so Colors are described\nusing a 32 bit integer.\n\n**BAD:**\n```dart\nColor(1);\nColor(0x000001);\n```\n\n**GOOD:**\n```dart\nColor(0x00000001);\n```\n\n"
  },
  {
    "name": "use_function_type_syntax_for_parameters",
    "description": "Use generic function type syntax for parameters.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic"
    ],
    "details": "\nUse generic function type syntax for parameters.\n\n**BAD:**\n```dart\nIterable<T> where(bool predicate(T element)) {}\n```\n\n**GOOD:**\n```dart\nIterable<T> where(bool Function(T) predicate) {}\n```\n\n"
  },
  {
    "name": "use_if_null_to_convert_nulls_to_bools",
    "description": "Use if-null operators to convert nulls to bools.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\nUse if-null operators to convert nulls to bools.\n\n**BAD:**\n```dart\nif (nullableBool == true) {\n}\nif (nullableBool != false) {\n}\n```\n\n**GOOD:**\n```dart\nif (nullableBool ?? false) {\n}\nif (nullableBool ?? true) {\n}\n```\n\n"
  },
  {
    "name": "use_is_even_rather_than_modulo",
    "description": "Prefer intValue.isOdd/isEven instead of checking the result of % 2.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**PREFER** the use of intValue.isOdd/isEven to check for evenness.\n\n**BAD:**\n```dart\nbool isEven = 1 % 2 == 0;\nbool isOdd = 13 % 2 == 1;\n```\n\n**GOOD:**\n```dart\nbool isEven = 1.isEven;\nbool isOdd = 13.isOdd;\n```\n\n"
  },
  {
    "name": "use_late_for_private_fields_and_variables",
    "description": "Use late for private members with non-nullable type.",
    "group": "style",
    "maturity": "experimental",
    "incompatible": [],
    "sets": [],
    "details": "\nUse late for private members with non-nullable types that are always expected to\nbe non-null. Thus it's clear that the field is not expected to be `null` and it\navoids null checks.\n\n**BAD:**\n```dart\nint? _i;\nm() {\n  _i!.abs();\n}\n```\n\n**GOOD:**\n```dart\nlate int _i;\nm() {\n  _i.abs();\n}\n```\n\n"
  },
  {
    "name": "use_named_constants",
    "description": "Use predefined named constants.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\nWhere possible, use already defined const values.\n\n**BAD:**\n```dart\nconst Duration(seconds: 0);\n```\n\n**GOOD:**\n```dart\nDuration.zero;\n```\n\n"
  },
  {
    "name": "use_raw_strings",
    "description": "Use raw string to avoid escapes.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\nA raw string can be used to avoid escaping only backslashes and dollars.\n\n**BAD:**\n```dart\nvar s = 'A string with only \\\\ and \\$';\n```\n\n**GOOD:**\n```dart\nvar s = r'A string with only \\ and $';\n```\n\n"
  },
  {
    "name": "use_rethrow_when_possible",
    "description": "Use rethrow to rethrow a caught exception.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "recommended",
      "flutter",
      "pedantic",
      "effective_dart"
    ],
    "details": "\n**DO** use rethrow to rethrow a caught exception.\n\nAs Dart provides rethrow as a feature, it should be used to improve terseness\nand readability.\n\n**BAD:**\n```dart\ntry {\n  somethingRisky();\n} catch(e) {\n  if (!canHandle(e)) throw e;\n  handle(e);\n}\n```\n\n**GOOD:**\n```dart\ntry {\n  somethingRisky();\n} catch(e) {\n  if (!canHandle(e)) rethrow;\n  handle(e);\n}\n```\n\n"
  },
  {
    "name": "use_setters_to_change_properties",
    "description": "Use a setter for operations that conceptually change a property.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\n**DO** use a setter for operations that conceptually change a property.\n\n**BAD:**\n```dart\nrectangle.setWidth(3);\nbutton.setVisible(false);\n```\n\n**GOOD:**\n```dart\nrectangle.width = 3;\nbutton.visible = false;\n```\n\n"
  },
  {
    "name": "use_string_buffers",
    "description": "Use string buffers to compose strings.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\n**DO** use string buffers to compose strings.\n\nIn most cases, using a string buffer is preferred for composing strings due to\nits improved performance.\n\n**BAD:**\n```dart\nString foo() {\n  final buffer = '';\n  for (int i = 0; i < 10; i++) {\n    buffer += 'a'; // LINT\n  }\n  return buffer;\n}\n```\n\n**GOOD:**\n```dart\nString foo() {\n  final buffer = StringBuffer();\n  for (int i = 0; i < 10; i++) {\n    buffer.write('a');\n  }\n  return buffer.toString();\n}\n```\n\n"
  },
  {
    "name": "use_test_throws_matchers",
    "description": "Use throwsA matcher instead of fail().",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [],
    "details": "\nUse the `throwsA` matcher instead of try-catch with `fail()`.\n\n**BAD:**\n\n```dart\n// sync code\ntry {\n  someSyncFunctionThatThrows();\n  fail('expected Error');\n} on Error catch (error) {\n  expect(error.message, contains('some message'));\n}\n\n// async code\ntry {\n  await someAsyncFunctionThatThrows();\n  fail('expected Error');\n} on Error catch (error) {\n  expect(error.message, contains('some message'));\n}\n```\n\n**GOOD:**\n```dart\n// sync code\nexpect(\n  () => someSyncFunctionThatThrows(),\n  throwsA(isA<Error>().having((Error error) => error.message, 'message', contains('some message'))),\n);\n\n// async code\nawait expectLater(\n  () => someAsyncFunctionThatThrows(),\n  throwsA(isA<Error>().having((Error error) => error.message, 'message', contains('some message'))),\n);\n```\n\n"
  },
  {
    "name": "use_to_and_as_if_applicable",
    "description": "Start the name of the method with to/_to or as/_as if applicable.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "effective_dart"
    ],
    "details": "\nFrom the [design guide](https://dart.dev/guides/language/effective-dart/design):\n\n**PREFER** naming a method to___() if it copies the object's state to a new object.\n\n**PREFER** naming a method as___() if it returns a different representation backed by the original object.\n\n**BAD:**\n```dart\nclass Bar {\n  Foo myMethod() {\n    return Foo.from(this);\n  }\n}\n```\n\n**GOOD:**\n```dart\nclass Bar {\n  Foo toFoo() {\n    return Foo.from(this);\n  }\n}\n```\n\n**GOOD:**\n```dart\nclass Bar {\n  Foo asFoo() {\n    return Foo.from(this);\n  }\n}\n```\n\n"
  },
  {
    "name": "void_checks",
    "description": "Don't assign to void.",
    "group": "style",
    "maturity": "stable",
    "incompatible": [],
    "sets": [
      "core",
      "recommended",
      "flutter"
    ],
    "details": "\n**DO NOT** assign to void.\n\n**BAD:**\n```dart\nclass A<T> {\n  T value;\n  void test(T arg) { }\n}\n\nvoid main() {\n  A<void> a = A<void>();\n  a.value = 1; // LINT\n  a.test(1); // LINT\n}\n```\n"
  }
]