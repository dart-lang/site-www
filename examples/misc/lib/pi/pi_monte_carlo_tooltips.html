<!--
  Ensure that the <li> element name attributes actually appear in the marked up
  source file pi_monte_carlo.dart. Each //!tip() entry in that file has a
  corresponding entry below, in the same order as in the source file.
-->
<ul class="fp-tooltips" style="display: none">

  <li name="import">
    Dart has one canonical way to import libraries, and one canonical (and
    easy) way to install library packages.
  </li>

  <li name="dart:math">
    The whole standard library is meticulously maintained. It has been called
    “well-crafted” by none other than Erik Meijer.
  </li>

  <li name="main()">
    The <code>main()</code> function is the single point of entry.
  </li>

  <li name="π">Unicode support is baked in.</li>

  <li name="await">
    Language-level asynchrony support makes you more productive when dealing
    with deeply asynchronous code (like most UI code, for example).
  </li>

  <li name="$estimate">
    String interpolation is easy. Just put <code>${expression}</code>
    or <code>$variable</code> in your string literal.
  </li>

  <li name="///">
    Add doc comments like this to flesh out the API reference docs that the
    SDK’s dartdoc tool generates.
  </li>

  <li name="<double>">
    Generics are optional but extremely useful in large codebases.
  </li>

  <li name="{int batch = 100000}">
    Named parameters make call sites more readable.
  </li>

  <li name="async*">
    Dart has language-level support for asynchronous generators.
  </li>

  <li name="var">
    The type is inferred in this variable declaration. Note: no
    JavaScript-style hoisting.
  </li>

  <li name="while (true)">
    Because generators are lazy, we can safely do this.
  </li>

  <li name="take">
    Synchronous generators produce (lazy) Iterables, and Iterables have a
    well-crafted API.
  </li>

  <li name="=>">
    The optional arrow syntax makes simple functions more readable.
  </li>

  <li name="length">
    Since the <code>Iterable</code> is lazy, the program doesn’t actually
    iterate over it until it’s needed by the length getter. No new array will
    be constructed.
  </li>

  <li name="yield">
    In an <code>async</code> generator, yield takes care of sending the values
    through the stream (including the logic of suspending execution when
    needed).
  </li>

  <li name="Iterable">
    <code>Iterable</code> is a core type extended by all iterable collections,
    which makes for some elegant Dart code.
  </li>

  <li name="[int? seed]">
    Optional parameters make call sites cleaner.
  </li>

  <li name="sync*">
    Dart has language-level support for synchronous generators, too.
  </li>

  <li name="final">
    Variables and fields can be final. Any attempt to change them later in the
    code will produce a static error.
  </li>

  <li name="yield">
    Producing lazy Iterables through yield is readable and corresponds nicely
    with the same concept in asynchronous generators.
  </li>

  <li name="class">
    Dart is purely object-oriented and class-based, with mixin-based
    inheritance.
  </li>

  <li name="double">
    Although Dart can compile to JavaScript, it doesn’t lack the distinction
    between <code>double</code> and <code>int</code>.
  </li>

  <li name="const">Constructors can be constant.</li>

  <li name="this.x">
    Initializing fields through this shorthand syntax is both easier and more
    readable.
  </li>

  <li name="get">
    Language-level support for getters means you can freely switch between
    properties and methods without changing the API.
  </li>

</ul>
